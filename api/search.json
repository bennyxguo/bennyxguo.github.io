[{"id":"b695af22372019b5213d1466cd06b4ba","title":"Aurora 自定义容器（Custom Containers）","content":"Custom Container Example.\n\n\n\n\n\n\n\n\nSince version 1.5.0, Aurora added custom containers including tip, warning, danger and details.\n\n\n\n\n\n\n\n\n\n自从版本 1.5.0，Aurora 添加了与 VuePress 一样的自定义容器, 包括 提示 (tip)、注意 (warning)、特别注意 (danger) 和 隐藏内容 (details)\n\nBlock quote\n\n\n\n\n\n\n\n\nnormal quote block.\n&gt; normal quote block.\n\n\nCustom ContainersTip Container\n\n\n\n\n\nTIP\nNormal Tips Container\n\n:::tip\nNormal Tips Container\n:::\n\n\n\n\n\n\n\nCustom header\nCustom header\n\ntips content\ntips new line\n\n\n\n:::tip Custom header\n\nCustom header\n\n- tips content\n- tips new line\n\n:::\n\n\nWarning Container\n\n\n\n\n\n\nWARNING\nWarning!!!\n\n:::warning\nWarning!!!\n:::\n\n\n\n\n\n\n\n\nWarning World\nWarning!!!\n\n:::warning Warning World\n**Warning!!!**\n:::\n\n\nDanger Container\n\n\n\n\n\n\nWARNING\nDanger!!!\n\n:::danger\nDanger!!!\n:::\n\n\nDetail container\nClick to see more\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\ndetails content\ndetails new line\n\nconsole.log(&#39;hello world&#39;);\n\n\n\n:::details Click to see more\n\nFusce rutrum venenatis eros in hendrerit. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nullam eget risus egestas, aliquet ipsum sed, volutpat tortor. Proin finibus tortor ac mauris finibus rutrum. Nullam tincidunt arcu eu urna ullamcorper, eu ultricies turpis ornare. Morbi id sollicitudin orci. Proin lobortis vehicula nibh a ornare. Cras sodales eu ligula quis fermentum. Proin eu ultrices leo, quis iaculis justo. Sed dictum, nulla sit amet imperdiet commodo, libero sapien semper justo, ut lobortis elit nunc vitae ante. Nullam lobortis odio quam, ac condimentum elit posuere vitae. Sed ornare, odio et rutrum varius, lorem eros gravida urna, in pharetra sapien justo non magna.\n\n- details content\n- details new line\n\n&#96;&#96;&#96;javascript\nconsole.log(&#39;hello world&#39;);\n&#96;&#96;&#96;\n\n:::\n","slug":"aurora/custom-quotes","date":"2021-05-02T15:19:24.000Z","categories_index":"Aurora","tags_index":"aurora,project-blog","author_index":"三钻"},{"id":"ca7c828cb91c2471a064cf04f7381420","title":"实战中学习浏览器工作原理 — HTML 解析与 CSS 计算","content":"上一部分我们完成了从 HTTP 发送 Request，到接收到 Response，并且把 Response 中的文本都解析出来。\n这一部分我们主要讲解如何做 HTML 解析 和 CSS 计算这两个部分。\n\n根据我们上部分列出的一个完整的浏览器架构的话，蓝色背景的部分就是我们目前已经完成的流程。\n\nHTML 解析HTML parse 模块的文件拆分思路：\n\n为了方便文件管理，我们把 parser 单独拆分到文件中\nparser 接收 HTML 文本作为参数，返回一棵 DOM 树\n\n加入 HTML Parser\n\n上一篇文章中我们最后获得了一个 Response 对象\n这里我们就考虑如何利用这个 Response 中的 body 内容\n所以我们应该从获得 Response 之后，把 body 内容传给 parser 中的 parseHTML 方法进行解析\n在真正的浏览器中，我们是应该逐段的传给 parser 处理，然后逐段的返回\n因为这里我们的目标只是简单实现浏览器工作的原理，所以我们只需要统一解析然后返回就好\n这样我们更容易理解，代码也更加清晰易懂\n\n\n\n\n\n\n\n\n\n\n文件：client.js\n// 这个是 client.js\n\n// 1. 引入 parser.js\nconst parser = require('./parser.js')\n\n// ...\n//... 之前的代码在此处忽略\n// ...\n\nlet response = await request.send()\n\n// 2. 在 `请求方法` 中，获得 response 后加入 HTML 的解析代码\nlet dom = parser.parseHTML(response.body)\n\n\n\n\n\n\n\n\n\n\n文件：parser.js\n/**\n * 解析器\n * @filename parser.js\n * @author 三钻\n * @version v1.0.0\n */\n\nmodule.exports.parseHTML = function (html) {\n  console.log(html) // 这里我们先 console.log 打印一下返回的 HTML 内容\n}\n\n用有效状态机 (FSM) 实现 HTML 的分析\n我们用 FSM 来实现 HTML 的分析\n在 HTML 标准中，已经规定了 HTML 的状态\n我们的浏览器只挑选其中一部分状态，完成一个最简版本\n\nHTML 标准里面已经把整个状态机中的状态都设计好了，我们直接就看 HTML 标准中给我们设计好的状态：https://html.spec.whatwg.org/multipage/，我们直接翻到 “Tokenization” 查看列出的状态，这里就是所有 HTML 的词法。\n有些同学在读这个标准的时候会说 “我看不懂”，“我太难了”，“我看懵了”。其实我们看不懂是因为这里面的标准是写给浏览器实现者去看的，但是用实现我们的浏览器的状态机之后，我们就可以看懂了，而且发现这里面写的非常像我们的代码。这个标准中写的就是伪代码。我们只需要把这里面的伪代码写成真实代码就可以了。\n在 HTML 中有 80 个状态，但是在我们这里，因为只需要走一遍浏览器工作的流程，我们就不一一实现了，我们在其中挑选一部分来实现即可。\n下面我们来初始化一下我们的 parseHTML 的状态机：（把上面的 parser.js 的基础上进行修改）\n\n\n\n\n\n\n\n\n\n文件：parser.js\n/**\n * 解析器\n * @filename parser.js\n * @author 三钻\n * @version v1.0.0\n */\n\nconst EOF = Symbol('EOF') // EOF: end of file\n\nfunction data(char) {}\n\n/**\n * HTTP 解析\n * @param {string} html 文本\n */\nmodule.exports.parseHTML = function (html) {\n  let state = data\n  for (let char of html) {\n    state = state(char)\n  }\n  state = state(EOF)\n}\n\n\n\n\n\n\n\n\n\n\n\n上面的代码中用了一个小技巧，因为 HTML 最后是有一个文件终结的\n所有最后需要给他一个结束字符（重点是这里用一个没有特别意义的字符）\n我们这里使用了 Symbol 创建了一个 EOF 字符，代表 End of file (文件结束)\n\n解析标签HTML 有三种标签\n\n开始标签\n结束标签\n自封闭标签\n\n思路：\n\n主要的标签有：开始标签，结束标签和自封闭标签\n在这一步我们暂时忽略属性\n\n\n\n\n\n\n\n\n\n\n文件：parser.js\n/**\n * 解析器\n * @filename parser.js\n * @author 三钻\n * @version v1.0.0\n */\n\nconst EOF = Symbol('EOF') // EOF: end of file\n\n/**\n * HTML 数据开始阅读状态\n * --------------------------------\n * 1. 如果找到 `&lt;` 就是标签开始状态\n * 2. 如果找到 `EOF` 就是HTML文本结束\n * 3. 其他字符就继续寻找\n * @param {*} char\n *\n * @return {function}\n */\nfunction data(char) {\n  if (char === '&lt;') {\n    // 标签开始\n    return tagOpen\n  } else if (char === EOF) {\n    // 文本结束\n    return\n  } else {\n    return data\n  }\n}\n\n/**\n * 标签开始状态\n * ----------------------------------\n * 1. 如果找到 `/` 证明是自关闭标签\n * 2. 如果是字母就是标签名\n * 3. 其他字符就直接继续寻找\n * @param {*} char\n */\nfunction tagOpen(char) {\n  if (char === '/') {\n    // 自关闭标签\n    return endTagOpen\n  } else if (char.match(/^[a-zA-Z]$/)) {\n    // 标签名\n    return tagName(char)\n  } else {\n    return\n  }\n}\n\n/**\n * 标签结束状态\n * --------------------------------\n * 1. 如果是字母就是标签名\n * 2. 如果直接是 `&gt;` 就报错\n * 3. 如果是结束符合，也是报错\n * @param {*} char\n */\nfunction endTagOpen(char) {\n  if (char.match(/^[a-zA-Z]$/)) {\n    return tagName(char)\n  } else if (char === '&gt;') {\n    // 报错 —— 没有结束标签\n  } else if (char === EOF) {\n    // 报错 —— 结束标签不合法\n  }\n}\n\n/**\n * 标签名状态\n * --------------------------------\n * 1. 如果 `\\t`(Tab符)、`\\n`(空格符)、`\\f`(禁止符)或者是空格，这里就是属性的开始\n * 2. 如果找到 `/` 就是自关闭标签\n * 3. 如果是字母字符那还是标签名\n * 4. 如果是 `&gt;` 就是开始标签结束\n * 5. 其他就是继续寻找标签名\n * @param {*} char\n */\nfunction tagName(char) {\n  if (c.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '/') {\n    return selfClosingStartTag\n  } else if (c.match(/^[a-zA-Z]$/)) {\n    return tagName\n  } else if (char === '&gt;') {\n    return data\n  } else {\n    return tagName\n  }\n}\n\n/**\n * 标签属性状态\n * --------------------------------\n * 1. 如果遇到 `/` 就是自封闭标签状态\n * 2. 如果遇到字母就是属性名\n * 3. 如果遇到 `&gt;` 就是标签结束\n * 4. 如果遇到 `=` 下来就是属性值\n * 5. 其他情况继续进入属性抓取\n * @param {*} char\n */\nfunction beforeAttributeName(char) {\n  if (char === '/') {\n    return selfClosingStartTag\n  } else if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '&gt;') {\n    return data\n  } else if (char === '=') {\n    return beforeAttributeName\n  } else {\n    return beforeAttributeName\n  }\n}\n\n/**\n * 自封闭标签状态\n * --------------------------------\n * 1. 如果遇到 `&gt;` 就是自封闭标签结束\n * 2. 如果遇到 `EOF` 即使报错\n * 3. 其他字符也是报错\n * @param {*} char\n */\nfunction selfClosingStartTag(char) {\n  if (char === '&gt;') {\n    return data\n  } else if (char === 'EOF') {\n  } else {\n  }\n}\n\n/**\n * HTTP 解析\n * @param {string} html 文本\n */\nmodule.exports.parseHTML = function (html) {\n  let state = data\n  for (let char of html) {\n    state = state(char)\n  }\n  state = state(EOF)\n}\n\n创建元素\n在状态机中，除了状态迁移，我们还会加入业务逻辑\n我们在标签结束状态提交标签 token\n\n业务逻辑：\n\n首先我们需要建立一个 currentToken 来暂存当前的 Token（这里我们是用于存放开始和结束标签 token 的）\n然后建立一个 emit() 方法来接收最后创建完毕的 Token（这里后面会用逐个 Token 来创建 DOM 树）\nHTML 数据开始状态 —— data\n如果找到的是 EOF，那就直接 emit 一个 type: ‘EOF’ 的 Token\n如果是文本内容的话，直接 emit {type: 'text', content: char} 的 token\n\n\n标签开始状态 —— tagOpen\n如果匹配中的是字母，那就是开始标签\n直接记录开始标签 Token 对象 {type: 'startTag, tagName: ''}\n在 tagName() 状态中我们会把整个完整的标签名拼接好\n\n\n标签结束状态 —— endTagOpen\n如果匹配到字符，那就是结束标签名\n直接记录结束标签 Token 对象 {type: 'endTag', tagName: ''}\n雷同，后面会在 tagName() 状态中我们会把整个完整的标签名拼接好\n\n\n标签名状态 —— tagName\n这里就是最核心的业务区了\n在第三种情况下，匹配到字母时，那就是需要拼接标签名的时候\n这里我们直接给 currentTag 追加字母即可\n当我们匹配到 &gt; 字符时，就是这个标签结束的时候，这个时候我们已经拥有一个完整的标签 Token 了\n所以这里我们直接把 currentToken emit 出去\n\n\n标签属性状态 —— beforeAttributeName\n在匹配到 &gt; 字符的时候，这里就是标签结束的时候，所以可以 emit currentToken 的时候\n\n\n自封闭标签状态 —— selfClosingStartTag\n这里追加了一个逻辑\n在匹配到 &gt; 字符时，就是自闭标签结束的时候\n这里我们直接给 currentToken 追加一个 isSelfClosing = true 的状态\n然后直接可以把 currentToken emit 出去了\n\n\n\n\n\n\n\n\n\n\n\n\n文件：parser.js\n/**\n * 解析器\n * @filename parser.js\n * @author 三钻\n * @version v1.0.0\n */\n\nlet currentToken = null\n\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  console.log(token)\n}\n\nconst EOF = Symbol('EOF') // EOF: end of file\n\n/**\n * HTML 数据开始阅读状态\n * --------------------------------\n * 1. 如果找到 `&lt;` 就是标签开始状态\n * 2. 如果找到 `EOF` 就是HTML文本结束\n * 3. 其他字符就继续寻找\n * @param {*} char\n *\n * @return {function}\n */\nfunction data(char) {\n  if (char === '&lt;') {\n    // 标签开始\n    return tagOpen\n  } else if (char === EOF) {\n    // 文本结束\n    emit({\n      type: 'EOF',\n    })\n    return\n  } else {\n    // 文本\n    emit({\n      type: 'text',\n      content: char,\n    })\n    return data\n  }\n}\n\n/**\n * 标签开始状态\n * ----------------------------------\n * 1. 如果找到 `/` 证明是自关闭标签\n * 2. 如果是字母就是标签名\n * 3. 其他字符就直接继续寻找\n * @param {*} char\n */\nfunction tagOpen(char) {\n  if (char === '/') {\n    // 自关闭标签\n    return endTagOpen\n  } else if (char.match(/^[a-zA-Z]$/)) {\n    // 标签名\n    currentToken = {\n      type: 'startTag',\n      tagName: '',\n    }\n    return tagName(char)\n  } else {\n    return\n  }\n}\n\n/**\n * 标签结束状态\n * --------------------------------\n * 1. 如果是字母就是标签名\n * 2. 如果直接是 `&gt;` 就报错\n * 3. 如果是结束符合，也是报错\n * @param {*} char\n */\nfunction endTagOpen(char) {\n  if (char.match(/^[a-zA-Z]$/)) {\n    currentToken = {\n      type: 'endTag',\n      tagName: '',\n    }\n    return tagName(char)\n  } else if (char === '&gt;') {\n    // 报错 —— 没有结束标签\n  } else if (char === EOF) {\n    // 报错 —— 结束标签不合法\n  }\n}\n\n/**\n * 标签名状态\n * --------------------------------\n * 1. 如果 `\\t`(Tab符)、`\\n`(空格符)、`\\f`(禁止符)或者是空格，这里就是属性的开始\n * 2. 如果找到 `/` 就是自关闭标签\n * 3. 如果是字母字符那还是标签名\n * 4. 如果是 `&gt;` 就是开始标签结束\n * 5. 其他就是继续寻找标签名\n * @param {*} char\n */\nfunction tagName(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '/') {\n    return selfClosingStartTag\n  } else if (char.match(/^[a-zA-Z]$/)) {\n    currentToken.tagName += char\n    return tagName\n  } else if (char === '&gt;') {\n    emit(currentToken)\n    return data\n  } else {\n    return tagName\n  }\n}\n\n/**\n * 标签属性状态\n * --------------------------------\n * 1. 如果遇到 `/` 就是自封闭标签状态\n * 2. 如果遇到字母就是属性名\n * 3. 如果遇到 `&gt;` 就是标签结束\n * 4. 如果遇到 `=` 下来就是属性值\n * 5. 其他情况继续进入属性抓取\n * @param {*} char\n */\nfunction beforeAttributeName(char) {\n  if (char === '/') {\n    return selfClosingStartTag\n  } else if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '&gt;') {\n    emit(currentToken)\n    return data\n  } else if (char === '=') {\n    return beforeAttributeName\n  } else {\n    return beforeAttributeName\n  }\n}\n\n/**\n * 自封闭标签状态\n * --------------------------------\n * 1. 如果遇到 `&gt;` 就是自封闭标签结束\n * 2. 如果遇到 `EOF` 即使报错\n * 3. 其他字符也是报错\n * @param {*} char\n */\nfunction selfClosingStartTag(char) {\n  if (char === '&gt;') {\n    currentToken.isSelfClosing = true\n    emit(currentToken)\n    return data\n  } else if (char === 'EOF') {\n  } else {\n  }\n}\n\n/**\n * HTTP 解析\n * @param {string} html 文本\n */\nmodule.exports.parseHTML = function (html) {\n  let state = data\n  for (let char of html) {\n    state = state(char)\n  }\n  state = state(EOF)\n}\n\n处理属性\n属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理\n处理属性的方式跟标签类似\n属性结束时，我们把属性加到标签 Token 上\n\n业务逻辑：\n\n首先我们需要定义一个 currentAttribute 来存放当前找到的属性\n然后在里面叠加属性的名字和属性值，都完成后再放入 currrentToken 之中\n标签属性名开始状态 —— beforeAttributeName\n这里如果遇到 空格，换行，回车等字符就可以再次进入标签属性名开始状态，继续等待属性的字符\n如果我们遇到 /或者&gt;就是标签直接结束了，我们就可以进入属性结束状态\n如果遇到 = 或者 EOF 这里就有 HTML 语法错误，正常来说就会返回 parse error\n其他情况的话，就是刚刚开始属性名，这里就可以创建新的 currentAttribute 对象 {name: '', value: ''}，然后返回属性名状态\n\n\n属性名状态 —— attributeName\n如果我们遇到空格、换行、回车、/、&gt; 或者是 EOF等字符时，就可以判定这个属性已经结束了，可以直接迁移到 afterAttributeName 状态\n如果我们遇到一个 = 字符，证明我们的属性名读取完毕，下来就是属性值了\n如果我们遇到 \\u0000 那就是解析错误，直接抛出 Parse error\n最后所有其他的都是当前属性名的字符，直接叠加到 currentAttribute 的 name 值中，然后继续进入属性名状态继续读取属性名字符\n\n\n属性值开始状态 —— beforeAttributeValue\n如果我们遇到空格、换行、回车、/、&gt; 或者是 EOF等字符时，我们继续往后寻找属性值，所以继续返回 beforeAttributeValue 状态\n如果遇到 \" 就是双引号属性值，进入 doubleQuotedAttributeValue\n如果遇到 ' 就是单引号属性值，进入 singleQuotedAttributeValue\n其他情况就是遇到没有引号的属性值，使用 reconsume 的技巧进入 unquotedAttributeValue(char)\n\n\n双引号属性值状态 – doubleQuotedAttributeValue\n这里我们死等 \" 字符，到达这个字符证明这个属性的名和值都读取完毕，可以直接把这两个值放入当前 Token 了\n如果遇到 \\u0000 或者 EOF 就是 HTML 语法错误，直接抛出 Parse error\n其他情况就是继续读取属性值，并且叠加到 currentAttribute 的 value 中，然后继续进入 doubleQuotedAttributeValue\n\n\n单引号属性值状态 —— singleQuotedAttributeValue\n与双引号雷同，这里我们死等 ' 字符，到达这个字符证明这个属性的名和值都读取完毕，可以直接把这两个值放入当前 Token 了\n如果遇到 \\u0000 或者 EOF 就是 HTML 语法错误，直接抛出 Parse error\n其他情况就是继续读取属性值，并且叠加到 currentAttribute 的 value 中，然后继续进入 singleQuotedAttributeValue\n\n\n引号结束状态 —— afterQuotedAttributeValue\n如果我们遇到空格、换行、回车等字符时，证明还有可能有属性值，所以我们迁移到 beforeAttributeName 状态\n这个时候遇到一个 / 字符，因为之前我们读的是属性，属性都是在开始标签中的，在开始标签遇到 / ，那肯定是自封闭标签了。所以这里直接迁移到 selfClosingStartTag 状态\n如果遇到 &gt; 字符，证明标签要结束了，直接把当前组装好的属性名和值加入 currentToken， 然后直接 emit 出去\n如果遇到 EOF 那就是 HTML 语法错误，抛出 Parse error\n其他情况按照浏览器规范，这里属于属性之间缺少空格的解析错误 (Parse error: missing-whitespace-between-attributes)\n\n\n无引号属性值状态 —— unquotedAttributeValue\n如果我们遇到空格、换行、回车等字符时，证明属性值结束，这个时候我们就可以直接把当前属性加入 currentToken，然后还有可能有其他属性，所以进入 beforeAttributeName 状态\n如果遇到 / 证明标签是一个自封闭标签，先把当前属性加入 currentToken 然后进入 selfClosingStartTag 状态\n如果遇到 &gt; 证明标签正常结束了，先把当前属性加入 currentToken 然后直接 emit token\n遇到其他不合法字符都直接抛出 Parse error\n其他情况就是还在读取属性值的字符，所以叠加当前字符到属性值中，然后继续回到 unquotedAttributeValue\n\n\n属性名结束状态 —— afterAttributeName\n如果我们遇到空格、换行、回车等字符时，证明还没有找到结束字符，继续寻找，所以重新进入 afterAttributeName\n如果遇到 / 证明这个标签是自封闭标签，直接迁移到 selfClosingStartTag 状态\n如果遇到 = 字符证明下一个字符开始就是属性值了，迁移到 beforeAttributeValue 状态\n如果遇到 &gt; 字符，证明标签正常结束了，先把当前属性加入 currentToken 然后直接 emit token\n如果遇到 EOF 证明 HTML 文本异常结束了，直接抛出 Parse error\n其他情况下，属于属性名又开始了，所以把上一个属性加入 currentToken 然后继续记录下一个属性\n\n\n\n\n\n\n\n\n\n\n\n\n文件名：parser.js\n/**\n * 解析器\n * @filename parser.js\n * @author 三钻\n * @version v1.0.0\n */\n\nlet currentToken = null\nlet currentAttribute = null\n\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  console.log(token)\n}\n\nconst EOF = Symbol('EOF') // EOF: end of file\n\n/**\n * HTML 数据开始阅读状态\n * --------------------------------\n * 1. 如果找到 `&lt;` 就是标签开始状态\n * 2. 如果找到 `EOF` 就是HTML文本结束\n * 3. 其他字符就继续寻找\n * @param {*} char\n *\n * @return {function}\n */\nfunction data(char) {\n  if (char === '&lt;') {\n    // 标签开始\n    return tagOpen\n  } else if (char === EOF) {\n    // 文本结束\n    emit({\n      type: 'EOF',\n    })\n    return\n  } else {\n    // 文本\n    emit({\n      type: 'text',\n      content: char,\n    })\n    return data\n  }\n}\n\n/**\n * 标签开始状态\n * ----------------------------------\n * 1. 如果找到 `/` 证明是自关闭标签\n * 2. 如果是字母就是标签名\n * 3. 其他字符就直接继续寻找\n * @param {*} char\n */\nfunction tagOpen(char) {\n  if (char === '/') {\n    // 自关闭标签\n    return endTagOpen\n  } else if (char.match(/^[a-zA-Z]$/)) {\n    // 标签名\n    currentToken = {\n      type: 'startTag',\n      tagName: '',\n    }\n    return tagName(char)\n  } else {\n    return\n  }\n}\n\n/**\n * 标签结束状态\n * --------------------------------\n * 1. 如果是字母就是标签名\n * 2. 如果直接是 `&gt;` 就报错\n * 3. 如果是结束符合，也是报错\n * @param {*} char\n */\nfunction endTagOpen(char) {\n  if (char.match(/^[a-zA-Z]$/)) {\n    currentToken = {\n      type: 'endTag',\n      tagName: '',\n    }\n    return tagName(char)\n  } else if (char === '&gt;') {\n    // 报错 —— 没有结束标签\n  } else if (char === EOF) {\n    // 报错 —— 结束标签不合法\n  }\n}\n\n/**\n * 标签名状态\n * --------------------------------\n * 1. 如果 `\\t`(Tab符)、`\\n`(空格符)、`\\f`(禁止符)或者是空格，这里就是属性的开始\n * 2. 如果找到 `/` 就是自关闭标签\n * 3. 如果是字母字符那还是标签名\n * 4. 如果是 `&gt;` 就是开始标签结束\n * 5. 其他就是继续寻找标签名\n * @param {*} char\n */\nfunction tagName(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '/') {\n    return selfClosingStartTag\n  } else if (char.match(/^[a-zA-Z]$/)) {\n    currentToken.tagName += char\n    return tagName\n  } else if (char === '&gt;') {\n    emit(currentToken)\n    return data\n  } else {\n    return tagName\n  }\n}\n\n/**\n * 标签属性名开始状态\n * --------------------------------\n * 1. 如果遇到 `/` 就是自封闭标签状态\n * 2. 如果遇到字母就是属性名\n * 3. 如果遇到 `&gt;` 就是标签结束\n * 4. 如果遇到 `=` 下来就是属性值\n * 5. 其他情况继续进入属性抓取\n * @param {*} char\n */\nfunction beforeAttributeName(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '/' || char === '&gt;') {\n    return afterAttributeName(char)\n  } else if (char === '=' || char === EOF) {\n    throw new Error('Parse error')\n  } else {\n    currentAttribute = {\n      name: '',\n      value: '',\n    }\n    return attributeName(char)\n  }\n}\n\n/**\n * 属性名状态\n * @param {*} char\n */\nfunction attributeName(char) {\n  if (\n    char.match(/^[\\t\\n\\f ]$/) ||\n    char === '/' ||\n    char === '&gt;' ||\n    char === EOF\n  ) {\n    return afterAttributeName(char)\n  } else if (char === '=') {\n    return beforeAttributeValue\n  } else if (char === '\\u0000') {\n    throw new Error('Parse error')\n  } else {\n    currentAttribute.name += char\n    return attributeName\n  }\n}\n\n/**\n * 属性值开始状态\n * @param {*} char\n */\nfunction beforeAttributeValue(char) {\n  if (\n    char.match(/^[\\t\\n\\f ]$/) ||\n    char === '/' ||\n    char === '&gt;' ||\n    char === EOF\n  ) {\n    return beforeAttributeValue\n  } else if (char === '\"') {\n    return doubleQuotedAttributeValue\n  } else if (char === \"'\") {\n    return singleQuotedAttributeValue\n  } else if (char === '&gt;') {\n    // return data;\n  } else {\n    return unquotedAttributeValue(char)\n  }\n}\n\n/**\n * 双引号属性值状态\n * @param {*} char\n */\nfunction doubleQuotedAttributeValue(char) {\n  if (char === '\"') {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    return afterQuotedAttributeValue\n  } else if (char === '\\u0000') {\n    throw new Error('Parse error')\n  } else if (char === EOF) {\n    throw new Error('Parse error')\n  } else {\n    currentAttribute.value += char\n    return doubleQuotedAttributeValue\n  }\n}\n\n/**\n * 单引号属性值状态\n * @param {*} char\n */\nfunction singleQuotedAttributeValue(char) {\n  if (char === \"'\") {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    return afterQuotedAttributeValue\n  } else if (char === '\\u0000') {\n    throw new Error('Parse error')\n  } else if (char === EOF) {\n    throw new Error('Parse error')\n  } else {\n    currentAttribute.value += char\n    return singleQuotedAttributeValue\n  }\n}\n\n/**\n * 引号结束状态\n * @param {*} char\n */\nfunction afterQuotedAttributeValue(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    return beforeAttributeName\n  } else if (char === '/') {\n    return selfClosingStartTag\n  } else if (char === '&gt;') {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    emit(currentToken)\n    return data\n  } else if (char === EOF) {\n    throw new Error('Parse error: eof-in-tag')\n  } else {\n    throw new Error('Parse error: missing-whitespace-between-attributes')\n  }\n}\n\n/**\n * 无引号属性值状态\n * @param {*} char\n */\nfunction unquotedAttributeValue(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    return beforeAttributeName\n  } else if (char === '/') {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    return selfClosingStartTag\n  } else if (char === '&gt;') {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    emit(currentToken)\n    return data\n  } else if (char === '\\u0000') {\n    throw new Error('Parse error')\n  } else if (\n    char === '\"' ||\n    char === \"'\" ||\n    char === '&lt;' ||\n    char === '=' ||\n    char === '`'\n  ) {\n    throw new Error('Parse error')\n  } else if (char === EOF) {\n    throw new Error('Parse error')\n  } else {\n    currentAttribute.value += char\n    return unquotedAttributeValue\n  }\n}\n\n/**\n * 属性名结束状态\n * @param {*} char\n */\nfunction afterAttributeName(char) {\n  if (char.match(/^[\\t\\n\\f ]$/)) {\n    return afterAttributeName\n  } else if (char === '/') {\n    return selfClosingStartTag\n  } else if (char === '=') {\n    return beforeAttributeValue\n  } else if (char === '&gt;') {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    emit(currentToken)\n    return data\n  } else if (char === EOF) {\n    throw new Error('Parse error')\n  } else {\n    currentToken[currentAttribute.name] = currentAttribute.value\n    currentAttribute = {\n      name: '',\n      value: '',\n    }\n    return attributeName(char)\n  }\n}\n\n/**\n * 自封闭标签状态\n * --------------------------------\n * 1. 如果遇到 `&gt;` 就是自封闭标签结束\n * 2. 如果遇到 `EOF` 即使报错\n * 3. 其他字符也是报错\n * @param {*} char\n */\nfunction selfClosingStartTag(char) {\n  if (char === '&gt;') {\n    currentToken.isSelfClosing = true\n    emit(currentToken)\n    return data\n  } else if (char === 'EOF') {\n  } else {\n  }\n}\n\n/**\n * HTTP 解析\n * @param {string} html 文本\n */\nmodule.exports.parseHTML = function (html) {\n  let state = data\n  for (let char of html) {\n    state = state(char)\n  }\n  state = state(EOF)\n}\n\n用 token 构建 DOM 树这里我们开始语法分析，这个与复杂的 JavaScript 的语法相比就非常简单，所以我们只需要用栈基于可以完成分析。但是如果我们要做一个完整的浏览器，只用栈肯定是不行的，因为浏览器是有容错性的，如果我们没有编写结束标签的话，浏览器是会去为我们补错机制的。\n那么我做的这个简单的浏览器就不需要对使用者做的那么友好，而只对实现者做的更友好即可。所以我们在实现的过程中就不做那么多特殊情况的处理了。简单用一个栈实现浏览器的 HTML 语法解析，并且构建 一个 DOM 树。\n\n从标签构建 DOM 树的基本技巧是使用栈\n遇到开始标签时创建元素并入栈，遇到结束标签时出栈\n自封闭节点可视为入栈后立刻出栈\n任何元素的父元素是它入栈前的栈顶\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中的 emit() 函数部分\n// 默认给予根节点 document\nlet stack = [{ type: 'document', children: [] }]\n\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  if (token.type === 'text') return\n\n  // 记录上一个元素 - 栈顶\n  let top = stack[stack.length - 1]\n\n  // 如果是开始标签\n  if (token.type == 'startTag') {\n    let element = {\n      type: 'element',\n      children: [],\n      attributes: [],\n    }\n\n    element.tagName = token.tagName\n\n    for (let prop in token) {\n      if (prop !== 'type' &amp;&amp; prop != 'tagName') {\n        element.attributes.push({\n          name: prop,\n          value: token[prop],\n        })\n      }\n    }\n\n    // 对偶操作\n    top.children.push(element)\n    element.parent = top\n\n    if (!token.isSelfClosing) stack.push(element)\n\n    currentTextNode = null\n  } else if (token.type == 'endTag') {\n    if (top.tagName !== token.tagName) {\n      throw new Error('Parse error: Tag start end not matched')\n    } else {\n      stack.pop()\n    }\n\n    currentTextNode = null\n  }\n}\n\n将文本节点加到 DOM 树这里是 HTML 解析的最后一步，把文本节点合并后加入 DOM 树里面。\n\n文本节点与自封闭标签处理类似\n多个文本节点需要合并\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中的 emit() 函数部分\nlet currentToken = null\nlet currentAttribute = null\nlet currentTextNode = null\n\n// 默认给予根节点 document\nlet stack = [{ type: 'document', children: [] }]\n\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  // 记录上一个元素 - 栈顶\n  let top = stack[stack.length - 1]\n\n  // 如果是开始标签\n  if (token.type == 'startTag') {\n    let element = {\n      type: 'element',\n      children: [],\n      attributes: [],\n    }\n\n    element.tagName = token.tagName\n\n    for (let prop in token) {\n      if (prop !== 'type' &amp;&amp; prop != 'tagName') {\n        element.attributes.push({\n          name: prop,\n          value: token[prop],\n        })\n      }\n    }\n\n    // 对偶操作\n    top.children.push(element)\n    element.parent = top\n\n    if (!token.isSelfClosing) stack.push(element)\n\n    currentTextNode = null\n  } else if (token.type == 'endTag') {\n    if (top.tagName !== token.tagName) {\n      throw new Error('Parse error: Tag start end not matched')\n    } else {\n      stack.pop()\n    }\n\n    currentTextNode = null\n  } else if (token.type === 'text') {\n    if (currentTextNode === null) {\n      currentTextNode = {\n        type: 'text',\n        content: '',\n      }\n      top.children.push(currentTextNode)\n    }\n\n    currentTextNode.content += token.content\n  }\n}\n\n\nCSS 计算完成 HTML 解析并且获得了我们的 DOM 树之后，我们可以通过 CSS 计算来生成带 CSS 的 DOM 树。CSS Computing 表示的就是我们 CSS 规则里面所包含的那些 CSS 属性，应用到匹配这些选择器的元素上。\n开始这个代码编写之前，我们先来看看 z 在整个浏览器工作流程中，我们完成了哪些流程，到达了哪里。\n\n上面的图，我们看到 蓝色 部分就是已经完成的：\n\n上一篇文章我们完成了 HTTP 请求\n然后通过获得的报文，解析出所有 HTTP 信息，里面就包括了 HTML 内容\n然后通过 HTTP 内容解析，我们构建了我们的 DOM 树\n接下来就是 CSS 计算 (CSS Computing)\n\n目前的 DOM 树只有我们的 HTML 语言里面描述的那些语义信息，我们像完成渲染，我们需要 CSS 信息。 那有的同学就会说我们把所有的样式写到 style 里面可不可以呢？如果我们这样写呢，我们就不需要经历这个 CSS 计算的过程了。但是虽然我们只是做一个虚拟的浏览器，但是还是希望呈现一个比较完成的浏览器流程，所以我们还是会让 DOM 树参与 CSS 计算的过程。\n所以这里我们就让 DOM 树挂上 CSS 信息，然后在渲染的过程中能使用。\n在编写这个代码之前，我们需要准备一个环境。如果我们需要做 CSS 计算，我们就需要对 CSS 的语法与词法进行分析。然后这个过程如果是手动来实现的话，是需要较多的编译原理基础知识的，但是这些编译基础知识的深度对我们知识想了解浏览器工作原理并不是重点。所以这里我们就偷个懒，直接用 npm 上的一个css现成包即可。\n其实这个 css 包，就是一个 CSS parser，可以帮助我们完成 CSS 代码转译成 AST 抽象语法树。 我们所要做的就是根据这棵抽象语法树抽出各种 CSS 规则，并且把他们运用到我们的 HTML 元素上。\n那么我们第一步就是先拿到 CSS 的规则，所以叫做 “收集 CSS 规则”\n收集 CSS 规则\n遇到 style 标签时，我们把 CSS 规则保存起来\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中的 emit() 函数\n\n我们在 tagName === ‘endTag’ 的判断中加入了判断当前标签是否 style 标签\n如果是，我们就可以获取 style 标签里面所有的内容进行 CSS 分析\n这里非常简单我们加入一个 addCSSRule(top.children[0].content)的函数即可\n而，top 就是当前元素，children[0] 就是 text 元素，而 .content 就是所有的 CSS 规则文本\n这里我们需要注意一个点，我们忽略了在实际情况中还有 link 标签引入 CSS 文件的情况。但是这个过程涉及到多层异步请求和 HTML 解析的过程，为了简化我们的代码的复杂度，这里就不做这个实现了。当然实际的浏览器是会比我们做的虚拟浏览器复杂的多。\n\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  // 记录上一个元素 - 栈顶\n  let top = stack[stack.length - 1]\n\n  // 如果是开始标签\n  if (token.type == 'startTag') {\n    // ............. 省略了这部分代码 .....................\n  } else if (token.type == 'endTag') {\n    // 校验开始标签是否被结束\n    // 不是：直接抛出错误，是：直接出栈\n    if (top.tagName !== token.tagName) {\n      throw new Error('Parse error: Tag start end not matched')\n    } else {\n      // 遇到 style 标签时，执行添加 CSS 规则的操作\n      if (top.tagName === 'style') {\n        addCSSRule(top.children[0].content)\n      }\n      stack.pop()\n    }\n\n    currentTextNode = null\n  } else if (token.type === 'text') {\n    // ............. 省略了这部分代码 .....................\n  }\n}\n\n\n这里我们调用 CSS Parser 来分析 CSS 规则\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中加入 addCSSRule() 函数\n\n首先我们需要通过 node 引入 css 包\n然后调用 css.parse(text) 获得 AST 抽象语法树\n最后通过使用 ... 的特性展开了 ast.stylesheet.rules 中的所有对象，并且加入到 rules 里面\n\nconst css = require('css')\n\nlet rules = []\n/**\n * 把 CSS 规则暂存到一个数字里\n * @param {*} text\n */\nfunction addCSSRule(text) {\n  var ast = css.parse(text)\n  console.log(JSON.stringify(ast, null, '    '))\n  rules.push(...ast.stylesheet.rules)\n}\n\n\n这里我们必须要仔细研究此库分析 CSS 规则的格式\n\n最终 AST 输出的结果：\n\ntype 类型是 stylesheet 样式表\n然后在 stylesheet 中有 rules 的 CSS 规则数组\nrules 数组中就有一个 declarations 数组，这里面就是我们 CSS 样式的信息了\n拿第一个 delarations 来说明，他的属性为 width， 属性值为 100px，这些就是我们需要的 CSS 规则了\n\n{\n  \"type\": \"stylesheet\",\n  \"stylesheet\": {\n    \"source\": undefined,\n    \"rules\": [\n      {\n        \"type\": \"rule\",\n        \"selectors\": [\"body div #myId\"],\n        \"declarations\": [\n          {\n            \"type\": \"declaration\",\n            \"property\": \"width\",\n            \"value\": \"100px\",\n            \"position\": {\n              \"start\": {\n                \"line\": 3,\n                \"column\": 9\n              },\n              \"end\": {\n                \"line\": 3,\n                \"column\": 21\n              },\n              \"source\": undefined\n            }\n          },\n          {\n            \"type\": \"declaration\",\n            \"property\": \"background-color\",\n            \"value\": \"#ff5000\",\n            \"position\": {\n              \"start\": {\n                \"line\": 4,\n                \"column\": 9\n              },\n              \"end\": {\n                \"line\": 4,\n                \"column\": 34\n              },\n              \"source\": undefined\n            }\n          }\n        ],\n        \"position\": {\n          \"start\": {\n            \"line\": 2,\n            \"column\": 7\n          },\n          \"end\": {\n            \"line\": 5,\n            \"column\": 8\n          },\n          \"source\": undefined\n        }\n      }\n    ],\n    \"parsingErrors\": []\n  }\n}\n\n\n\n\n\n\n\n\n\n\n这里还有一个问题需要我们注意的，像 body div #myId 这种带有空格的标签选择器，是不会逐个给我们单独分析出来的，所以这种我们是需要在后面自己逐个分解分析。除非是 , 逗号分隔的选择器才会被拆解成多个 delarations。\n添加调用上一步我们收集好了 CSS 规则，这一步我们就是要找一个合适的时机把这些规则应用上。应用的时机肯定是越早越好，CSS 设计里面有一个潜规则，就是 CSS 设计会尽量保证所有的选择器都能够在 startTag 进入的时候就能被判断。\n当然，我们后面又加了一些高级的选择器之后，这个规则有了一定的松动，但是大部分的规则仍然是去遵循这个规则的，当我们 DOM 树构建到元素的 startTag 的步骤，就已经可以判断出来它能匹配那些 CSS 规则了\n\n当我们创建一个元素后，立即计算 CSS\n我们假设：理论上，当我们分析一个元素时，所有的 CSS 规则已经被收集完毕\n在真实浏览器中，可能遇到写在 body 的 style 标签，需要重新 CSS 计算的情况，这里我们忽略\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 的 emit() 函数加入 computeCSS() 函数调用\n/**\n * 输出 HTML token\n * @param {*} token\n */\nfunction emit(token) {\n  // 记录上一个元素 - 栈顶\n  let top = stack[stack.length - 1]\n\n  // 如果是开始标签\n  if (token.type == 'startTag') {\n    let element = {\n      type: 'element',\n      children: [],\n      attributes: [],\n    }\n\n    element.tagName = token.tagName\n\n    // 叠加标签属性\n    for (let prop in token) {\n      if (prop !== 'type' &amp;&amp; prop != 'tagName') {\n        element.attributes.push({\n          name: prop,\n          value: token[prop],\n        })\n      }\n    }\n\n    // 元素构建好之后直接开始 CSS 计算\n    computeCSS(element)\n\n    // 对偶操作\n    top.children.push(element)\n    element.parent = top\n    // 自封闭标签之外，其他都入栈\n    if (!token.isSelfClosing) stack.push(element)\n\n    currentTextNode = null\n  } else if (token.type == 'endTag') {\n    // ............. 省略了这部分代码 .....................\n  } else if (token.type === 'text') {\n    // ............. 省略了这部分代码 .....................\n  }\n}\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中加入 computeCSS() 函数\n/**\n * 对元素进行 CSS 计算\n * @param {*} element\n */\nfunction computeCSS(element) {\n  console.log(rules)\n  console.log('compute CSS for Element', element)\n}\n\n获取父元素序列为什么需要获取父元素序列呢？因为我们今天的选择器大多数都是跟元素的父元素相关的。\n\n在 computeCSS 函数中，我们必须知道元素的所有父级元素才能判断元素与规则是否匹配\n我们从上一步骤的 stack，可以获取本元素的父元素\n因为我们首先获取的是 “当前元素”，所以我们获得和计算父元素匹配的顺序是从内向外\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中的 computeCSS() 函数\n\n因为栈里面的元素是会不断的变化的，所以后期元素会在栈中发生变化，就会可能被污染。所以这里我们用了一个slice来复制这个元素。\n然后我们用了 reverse() 把元素的顺序倒过来，为什么我们需要颠倒元素的顺序呢？是因为我们的标签匹配是会从当前元素开始逐级的往外匹配（也就是一级一级往父级元素去匹配的）\n\n/**\n * 对元素进行 CSS 计算\n * @param {*} element\n */\nfunction computeCSS(element) {\n  var elements = stack.slice().reverse()\n}\n\n选择器与元素的匹配首先我们来了解一下选择器的机构，其实选择器其实是有一个层级结构的：\n\n最外层叫选择器列表，这个我们的 CSS parser 已经帮我们做了拆分\n选择器列表里面的，叫做复杂选择器，这个是由空格分隔了我们的复合选择器\n复杂选择器是根据亲代关系，去选择元素的\n复合选择器，是针对一个元素的本身的属性和特征的判断\n而复合原则性选择器，它又是由紧连着的一对选择器而构成的\n在我们的模拟浏览器中，我们可以假设一个复杂选择器中只包含简单选择器\n我们就把这种情况当成而外有精力的同学自行去实现了哈\n\n思路：\n\n选择器也要从当前元素向外排列\n复杂选择器拆成对单个元素的选择器，用循环匹配父级元素队列\n\n/**\n * 匹配函数下一节会重点实现\n * @param {*} element\n * @param {*} selector\n */\nfunction match(element, selector) {}\n\n/**\n * 对元素进行 CSS 计算\n * @param {*} element\n */\nfunction computeCSS(element) {\n  var elements = stack.slice().reverse()\n\n  if (!elements.computedStyle) element.computedStyle = {}\n  // 这里循环 CSS 规则，让规则与元素匹配\n  // 1.  如果当前选择器匹配不中当前元素直接 continue\n  // 2. 当前元素匹配中了，就一直往外寻找父级元素找到能匹配上选择器的元素\n  // 3. 最后检验匹配中的元素是否等于选择器的总数，是就是全部匹配了，不是就是不匹配\n  for (let rule of rules) {\n    let selectorParts = rule.selectors[0].split(' ').reverse()\n\n    if (!match(element, selectorParts[0])) continue\n\n    let matched = false\n\n    let j = 1\n    for (let i = 0; i &lt; elements.length; i++) {\n      if (match(elements[i], selectorParts[j])) j++\n    }\n\n    if (j &gt;= selectorParts.length) matched = true\n\n    if (matched) console.log('Element', element, 'matched rule', rule)\n  }\n}\n\n计算选择器与元素上一节我们没有完成 match 匹配函数的实现，那这一部分我们来一起实现元素与选择器的匹配逻辑。\n\n根据选择器的类型和元素属性，计算是否与当前元素匹配\n这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器\n同学们可以自己尝试一下实现复合选择器，实现支持空格的 Class 选择器\n\n/**\n * 匹配元素和选择器\n * @param {Object} element 当前元素\n * @param {String} selector CSS 选择器\n */\nfunction match(element, selector) {\n  if (!selector || !element.attributes) return false\n\n  if (selector.charAt(0) === '#') {\n    let attr = element.attributes.filter((attr) =&gt; attr.name === 'id')[0]\n    if (attr &amp;&amp; attr.value === selector.replace('#', '')) return true\n  } else if (selector.charAt(0) === '.') {\n    let attr = element.attributes.filter((attr) =&gt; attr.name === 'class')[0]\n    if (attr &amp;&amp; attr.value === selector.replace('.', '')) return true\n  } else {\n    if (element.tagName === selector) return true\n  }\n\n  return false\n}\n\n生成 computed 属性这一部分我们生成 computed 属性，这里我们只需要把 delarations 里面声明的属性给他加到我们的元素的 computed 上就可以了。\n\n一旦选择器匹配中了，就把选择器中的属性应用到元素上\n然后形成 computedStyle\n\n/**\n * 对元素进行 CSS 计算\n * @param {*} element\n */\nfunction computeCSS(element) {\n  var elements = stack.slice().reverse()\n\n  if (!elements.computedStyle) element.computedStyle = {}\n  // 这里循环 CSS 规则，让规则与元素匹配\n  // 1. 如果当前选择器匹配不中当前元素直接 continue\n  // 2. 当前元素匹配中了，就一直往外寻找父级元素找到能匹配上选择器的元素\n  // 3. 最后检验匹配中的元素是否等于选择器的总数，是就是全部匹配了，不是就是不匹配\n  for (let rule of rules) {\n    let selectorParts = rule.selectors[0].split(' ').reverse()\n\n    if (!match(element, selectorParts[0])) continue\n\n    let matched = false\n\n    let j = 1\n    for (let i = 0; i &lt; elements.length; i++) {\n      if (match(elements[i], selectorParts[j])) j++\n    }\n\n    if (j &gt;= selectorParts.length) matched = true\n\n    if (matched) {\n      let computedStyle = element.computedStyle\n      for (let declaration of rule.declarations) {\n        if (!computedStyle[declaration.property])\n          computedStyle[declaration.property] = {}\n        computedStyle[declaration.property].value = declaration.value\n      }\n      console.log(computedStyle)\n    }\n  }\n}\n\n\n\n\n\n\n\n\n\n\n看完代码的同学，或者自己去实现这个代码时候的同学，应该会发现这个代码中有一个问题。如果我们回去看看我们的 HTML 代码中的 style 样式表，我们发现 HTML 中的 img 标签会被两个 CSS 选择器匹配中，分别是 body div #myId 和 body div img。这样就会导致前面匹配中后加入 computedStyle 的属性值会被后面匹配中的属性值所覆盖。但是根据 CSS 中的权重规则，ID 选择器是高于标签选择器的。这个问题我们下一部分会和同学们一起解决掉哦。\nSpecificity 的计算逻辑上一节的代码中，我们只是把匹配中的选择器中的属性直接覆盖上一个，但是其实在 CSS 里面是有一个 specification 的规定。specification 翻译成中文，很多时候都会被翻译成 优先级，当然在理论上是对的，但是在英文中呢，优先级是 priority，所以 specificity 是 专指程度。\n放在 CSS 中理解就是，ID 选择器中的专指度是会比 CLASS 选择器的高，所以 CSS 中的 ID 的属性会覆盖 CLASS 的属性。\n好我们先来理解一下 specification 是什么？\n\n首先 specifity 会有四个元素\n按照 CSS 中优先级的顺序来说就是 inline style &gt; id &gt; class &gt; tag\n所以把这个生成为 specificity 就是 [0, 0, 0, 0]\n数组里面每一个数字都是代表在样式表中出现的次数\n\n下面我们用一些例子来分析一下，我们应该如何用 specificity 来分辨优先级的：\n\n\n\n\n\n\n\n\n\nA 组选择器\nA 选择器：div div #idA 的 specification ：[0, 1, 0, 2]\n\nid 出现了一次，所以第二位数字是 1\ndiv tag 出现了两次，所以第四位数是 2\n\nB 组选择器\nB 选择器：div #my #id\nB 的 specification：[0, 2, 0, 1]\n\nid 出现了两次，所以第二位数字是 2\ndiv tag 出现了一次，所以第四位数是 1\n\n好，那么我们怎么去比较上面的两种选择器，那个更大呢？\n\n我们需要从左到右开始比对；\n遇到同位置的数值一样的，就可以直接跳过；\n直到我们找到一对数值是有不一样的，这个时候就看是哪个选择器中的数值更大，那个选择器的优先级就更高；\n只要有一对比对出大小后，后面的就不需要再比对了。\n\n用上面 A 和 B 两种选择器来做对比的话，第一对两个都是 0，所以可以直接跳过。\n然后第二位数值对，A 选择器是 1，B 选择器是 2，很明显 B 要比 A 大，所以 B 选择器中的属性就要覆盖 A 的。\n说到这里同学们应该都明白 CSS 中 specificity 的规则和对比原理了，下来我们一起来看看如何实现这个代码逻辑。\n\nCSS 规则根据 specificity 和后来优先规则覆盖\nspecificity 是个四元组，越左边权重越高\n一个 CSS 规则的 specificity 根据包含的简单选择器相加而成\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 中添加一个 specificity 函数，来计算一个选择器的 specificity\n/**\n * 计算选择器的 specificity\n * @param {*} selector\n */\nfunction specificity(selector) {\n  let p = [0, 0, 0, 0]\n  let selectorParts = selector.split(' ')\n  for (let part of selectorParts) {\n    if (part.charAt(0) === '#') {\n      p[1] += 1\n    } else if (part.charAt(0) === '.') {\n      p[2] += 1\n    } else {\n      p[3] += 1\n    }\n  }\n  return p\n}\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 添加一个 compare 函数，来对比两个选择器的 specificity\n/**\n * 对比两个选择器的 specificity\n * @param {*} sp1\n * @param {*} sp2\n */\nfunction compare(sp1, sp2) {\n  for (let i = 0; i &lt;= 3; i++) {\n    if (i === 3) return sp1[3] - sp2[3]\n    if (sp1[i] - sp2[i]) return sp1[i] - sp2[i]\n  }\n}\n\n\n\n\n\n\n\n\n\n\n文件：parser.js 的 computeCSS 中修改匹配中元素后的属性赋值逻辑\n/**\n * 对元素进行 CSS 计算\n * @param {*} element\n */\nfunction computeCSS(element) {\n  var elements = stack.slice().reverse()\n\n  if (!elements.computedStyle) element.computedStyle = {}\n  // 这里循环 CSS 规则，让规则与元素匹配\n  // 1. 如果当前选择器匹配不中当前元素直接 continue\n  // 2. 当前元素匹配中了，就一直往外寻找父级元素找到能匹配上选择器的元素\n  // 3. 最后检验匹配中的元素是否等于选择器的总数，是就是全部匹配了，不是就是不匹配\n  for (let rule of rules) {\n    let selectorParts = rule.selectors[0].split(' ').reverse()\n\n    if (!match(element, selectorParts[0])) continue\n\n    let matched = false\n\n    let j = 1\n    for (let i = 0; i &lt; elements.length; i++) {\n      if (match(elements[i], selectorParts[j])) j++\n    }\n\n    if (j &gt;= selectorParts.length) matched = true\n\n    if (matched) {\n      let sp = specificity(rule.selectors[0])\n      let computedStyle = element.computedStyle\n      for (let declaration of rule.declarations) {\n        if (!computedStyle[declaration.property])\n          computedStyle[declaration.property] = {}\n\n        if (!computedStyle[declaration.property].specificity) {\n          computedStyle[declaration.property].value = declaration.value\n          computedStyle[declaration.property].specificity = sp\n        } else if (\n          compare(computedStyle[declaration.property].specificity, sp) &lt; 0\n        ) {\n          computedStyle[declaration.property].value = declaration.value\n          computedStyle[declaration.property].specificity = sp\n        }\n      }\n    }\n  }\n}\n\n\n最后我们这里就完成了浏览器工作原理中的 HTML 解析和 CSS 计算。\n下一篇文章我们来一起完成排版和渲染两个浏览器过程。敬请期待！\n\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n\n\n\n","slug":"frontend/browser-working-logic-css-computation","date":"2020-08-23T08:48:06.000Z","categories_index":"FrontEnd","tags_index":"JavaScript,Browser","author_index":"三钻"},{"id":"020b052a924b8fcc2ed6531b89a7e5d7","title":"前端必看的8个HTML+CSS技巧","content":"CSS 是一个很独特的语言。看起来非常简单，但是某种特殊效果看似简单，实现起来就颇有难度。这篇文章主要是给在学习前端的童鞋分享一些新的 CSS 技巧，一些在前端教程和培训课堂中不会讲到的知识。第二就是让还在前端开发这条道路上的童鞋们，重新燃起对前端排版和特效的热爱和热情！🔥\n\n一、固定底部内容\n这种是一个非常常见的布局方式，但是对于新手来说是比较常见的难题。\n这种布局方式在后台管理系统中比较常见，当我们内容不足浏览器窗口高度时，底部内容需要固定在底部。当内容超出了浏览器窗口高度，就会随着内容往后推。\n在有 CSS3 之前，实现这个效果是颇有难度的。浏览器窗口高度是会根据不同用户打开浏览器的情况，屏幕大小的差异和浏览器的缩放比例而变。我们需要借助 JavaScript 来实时获取浏览器高度进行运算才能实现。虽然说标题是说“固定”底部，但是我们想要的效果不是position: fixed。使用固定定位，在内容高于窗口高度时，就会挡住我们的内容。\n随着 CSS3 的来临，最完美的实现方式是使用Flexbox。实现的关键就是使用不太被关注的flex-grow属性，可以在我们的内容标签元素（比如div）中使用。在我们下面的例子里使用了main标签。\n\n我来讲解一下实现原理吧。\n\nflew-grow是用来控制一个 flex 元素相对它同等级 flex 元素的自身可扩充的空间。如果我们使用flex-grow: 0，那这个 flex 元素就完全不会扩展了。所以我们需要把头部和底部之间的内容标签元素设置为flex-grow: 1或者flex-grow: auto，这样内容部分就会自动填充满头部和底部之外的所有空间。\n为了避免底部内容受内容部分扩充空间的影响，我们给footer底部元素flex-shrink: 0属性。flex-shrink的作用与flex-grow是恰恰相反，用来控制 flex 元素收缩的空间，这里我们给了flex-shrink: 0就是为了底部footer的大小不受影响。\n我们直接上 HTML 和 CSS 代码看看是怎么实现的。\nHTML\n&lt;div id&#x3D;&quot;document&quot;&gt;\n  &lt;nav&gt;\n    &lt;h1&gt;头部内容&lt;&#x2F;h1&gt;\n  &lt;&#x2F;nav&gt;\n  &lt;main&gt;\n    &lt;p&gt;可以添加更多内容看看底部的变化哦！&lt;&#x2F;p&gt;\n  &lt;&#x2F;main&gt;\n  &lt;footer&gt;\n    &lt;h1&gt;底部内容&lt;&#x2F;h1&gt;\n  &lt;&#x2F;footer&gt;\n&lt;&#x2F;div&gt;\n\nCSS\n#document &#123;\n  height: 100vh;\n  display: flex;\n  flex-direction: column;\n  background: #202020;\n  font-family: microsoft yahei, wenquanyi micro hei, sans-serif !important;\n&#125;\n\nnav,\nfooter &#123;\n  background: #494949;\n  display: flex;\n  justify-content: center;\n&#125;\n\nmain &#123;\n  color: #bdbdbd;\n  flex: auto;\n&#125;\n\nfooter &#123;\n  flex-shrink: 0;\n&#125;\n\n* &#123;\n  margin: 0;\n&#125;\n\nh1,\np &#123;\n  padding: 15px;\n&#125;\n\nnav &gt; h1 &#123;\n  color: #82fcfd;\n  text-shadow: 1px 1px 4px #00000080;\n&#125;\n\nfooter &gt; h1 &#123;\n  color: #82fcfd;\n  text-shadow: 1px 1px 4px #00000080;\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟知识点总结：\n\nflex-grow — 是用来控制一个 flex 元素相对它同等级 flex 元素的自身可扩充的空间\nflex-shrink — 作用与flex-grow是恰恰相反，用来控制 flex 元素收缩的空间\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n二、悬停放大图片特效悬停放大图片是一个特别吸引眼球的特效，比较常用于可点击的图片。当用户悬停鼠标在图片上，图片会稍微的放大。\n其实实现这个特效是非常简单的。首先我们需要一个div包裹这img标签，这个包裹层是用来遮挡住图片，当图片放大时不会出现图片超出我们规定的宽高以外。\n首先我们来讲讲div包裹的属性，我们需要给它一个固定的width宽和height高。然后我们必须给予这个元素overflow: hidden属性。让图片放大的时候不会超出这个div元素的宽高。有了这个包裹层，我们就可以编写img的各种效果了。\n我的例子里面用了transform: scale(1,1)作为悬停时的图片特效，这个transform是用于改变任何元素的属性的，然后scale是用于放大（整数就会放大）或者缩小（负数就会缩小）元素的。\n上代码让大家看看：\n\nhtml body 中放入\n\n&lt;div class&#x3D;&quot;img-wrapper&quot;&gt;\n  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2020032122230564.png&quot; &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n\nCSS\n\n.img-wrapper &#123;\n  width: 400px;\n  height: 400px;\n  overflow: hidden;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);\n&#125;\n\n.img-wrapper img &#123;\n  height: 400px;\n  -webkit-transition: 0.3s linear;\n  transition: 0.3s linear;\n&#125;\n\n.img-wrapper img:hover &#123;\n  transform: scale(1.1);\n&#125;\n\n.img-wrapper &#123;\n  display: inline-block;\n  box-sizing: border-box;\n  border: 3px solid #000;\n&#125;\n\n如果你们想让图片更加炫酷可以加上图片过滤属性filter，让图片变灰或者变深褐色，然后悬停时候出现更加炫酷的颜色变幻。灰化的属性是filter: grayscale(100%);，然后深褐色化的属性是filter: sepia(100%)。其实图片还有很多过滤属性的，大家有兴趣也可以去尝试一下哦！\n加入特殊效果的代码如下：\nHTML\n&lt;!-- 灰度过滤 --&gt;\n&lt;div class&#x3D;&quot;img-wrapper&quot;&gt;\n  &lt;img class&#x3D;&quot;grayscale-img&quot; src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2020032211021728.png&quot; &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\n&lt;!-- 深褐色过滤 --&gt;\n&lt;div class&#x3D;&quot;img-wrapper&quot;&gt;\n  &lt;img class&#x3D;&quot;sepia-img&quot; src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2020032122230564.png&quot; &#x2F;&gt;\n&lt;&#x2F;div&gt;\n\nCSS\n&#x2F;* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n* 灰度过滤\n* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\n.grayscale-img &#123;\n  -webkit-filter: grayscale(100%);\n  filter: grayscale(100%);\n&#125;\n\n.grayscale-img:hover &#123;\n  -webkit-filter: grayscale(0);\n  filter: grayscale(0);\n&#125;\n\n&#x2F;* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n* 深褐色过滤\n* &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;*&#x2F;\n.sepia-img &#123;\n  -webkit-filter: sepia(100%);\n  filter: sepia(100%);\n&#125;\n\n.sepia-img:hover &#123;\n  -webkit-filter: sepia(0);\n  filter: sepia(0);\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\ntransform — 用于改变元素\nscale — 对元素进行放大和缩小\nfilter — 图片过滤器\ngrayscale — 灰度过滤\nsepia — 深褐色过滤\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n三、瞬间黑暗模式\n最近微信也逃脱不了黑暗时代的到来，网页也很多都做了黑暗模式的兼容和主题。如果我们在做的一个网站想瞬间实现黑暗模式可以怎么实现呢？\n其实有一个很快的方式，我们可以使用invert和hue-rotate两个 CSS3 过滤器来实现。\nfilter: invert() — 是从0到1的刻度，1是从白变黑。filter: hue-rotate() — 用于改变你元素的颜色，同时或多或少保持原本相同的色系。这个属性的值可以从0deg到360deg。\n在我们页面的body标签上添加这两个属性，我们就可以快速尝试把我们的网站变成”黑暗模式”。这里需要注意的是，如果body和html上没有设置background背景颜色，这个过滤就会不起效了哦。\nCSS 的代码如下：\nhtml &#123;\n  background: #fff;\n&#125;\n\nbody &#123;\n  background: #fff;\n  filter: invert(1) hue-rotate(270deg);\n&#125;\n\n实现效果\n这里我们会发现图片的颜色会受影响，并不是很美观，使用 css 过滤器是无法完美切换黑暗模式的。不过使用 JavaScript 辅助就可以完美的切换黑暗模式。\n最近出了一个 JavaScript 辅助插件叫Darkmode.js。\n🌓 Darkmode.js其实Darkmode.js运用的也是 css 里面的一个特性叫mix-blend-mode — “CSS 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合“。加上 Javascript 的辅助判断哪些页面上的元素需要黑化的，哪些是不需要黑化的。就会想我们之前那种做法，导致其他不需要黑化的元素，比如图片，受到影响导致颜色出现问题。\n使用Darkmode.js非常简单，只要在脚本里面添加以下代码就可以马上加入一个插件，\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;darkmode-js@1.5.5&#x2F;lib&#x2F;darkmode-js.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  &#x2F;&#x2F; 这些是这个插件的可配置项：\n  var options &#x3D; &#123;\n    bottom: &#39;32px&#39;, &#x2F;&#x2F; 定位底部距离 - 默认: &#39;32px&#39;\n    right: &#39;32px&#39;, &#x2F;&#x2F; 定位右边距离 - 默认: &#39;32px&#39;\n    left: &#39;unset&#39;, &#x2F;&#x2F; 定位左边距离 - 默认: &#39;unset&#39;\n    time: &#39;0.5s&#39;, &#x2F;&#x2F; 默认动画时间: &#39;0.3s&#39;\n    mixColor: &#39;#fff&#39;, &#x2F;&#x2F; 需要改变的颜色 - 默认: &#39;#fff&#39;\n    backgroundColor: &#39;#fff&#39;, &#x2F;&#x2F; 背景颜色 - 默认: &#39;#fff&#39;\n    buttonColorDark: &#39;#262728&#39;, &#x2F;&#x2F; 黑暗模式下按钮颜色 - 默认: &#39;#100f2c&#39;\n    buttonColorLight: &#39;#fff&#39;, &#x2F;&#x2F; 日间模式下按钮颜色 - 默认: &#39;#fff&#39;\n    saveInCookies: true, &#x2F;&#x2F; 是否在cookie保存当前模式 - 默认: true,\n    label: &#39;🌓&#39;, &#x2F;&#x2F; 切换模式按钮图标 - 默认: &#39;&#39;\n    autoMatchOsTheme: true &#x2F;&#x2F; 是否自动根据系统适应模式 - 默认: true\n  &#125;;\n\n  let darkmode &#x3D; new Darkmode(options);\n  darkmode.showWidget();\n&lt;&#x2F;script&gt;\n\n如果你不希望用这个插件的默认按钮，你可以在你的 JavaScript 代码中自主控制。我们可以通过.toggle()方法来切换模式，同时可以使用.isActivated()来检测是否已经进入黑暗模式。\nconst darkmode &#x3D; new Darkmode();\ndarkmode.toggle();\nconsole.log(darkmode.isActivated()); &#x2F;&#x2F; 如果已经进入黑暗模式会返回 true\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\nfilter: invert() — 可以把页面从白变黑，也可以从黑变白。\nfilter: hue-rotate() — 用于改变你元素的颜色，同时或多或少保持原本相同的色系。\nDarkmode.js — 瞬间实现黑暗模式。\n\nInvert 方式黑暗模式：预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢Darkmode.js 黑暗模式：预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n四、自定义列表符号ul，li的无序列表有默认的符号·，但是在很多情况下我们希望可以给这个符号加入自己的样式和颜色，甚至是换成自定义的符号。默认的符号我们是无法做任何的样式处理，而且默认的符号在 CSS 属性里面只有几个选择可以使用，很多情况下都是无法满足我们的设计。\n其实自定义无序列表符号不难，我们只需要使用伪元素::before加content属性就可以实现。\n在我这个例子里面我做了两个任务列表，一个是待处理任务，一个是已完成任务，各自给了不一样的列表符号和颜色。\n实现原理\n一、首先我们禁用了ul的默认符号样式list-style: none\n二、在li的:before伪元素上给予content内容值，待处理任务使用🗹，已完成任务li.completed:before使用✔\n三、为了展示效果更加好看我分别给了li和li .completed两个不同的颜色\n上代码看看是怎么实现的吧：\nHTML\n&lt;div&gt;\n  &lt;h2&gt;待处理&lt;&#x2F;h2&gt;\n  &lt;ul&gt;\n    &lt;li&gt;待办任务1&lt;&#x2F;li&gt;\n    &lt;li&gt;待办任务2&lt;&#x2F;li&gt;\n    &lt;li&gt;待办任务3&lt;&#x2F;li&gt;\n    &lt;li&gt;待办任务4&lt;&#x2F;li&gt;\n    &lt;li&gt;待办任务5&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n&lt;div&gt;\n  &lt;h2&gt;已完成&lt;&#x2F;h2&gt;\n  &lt;ul&gt;\n    &lt;li class&#x3D;&quot;completed&quot;&gt;完成任务1&lt;&#x2F;li&gt;\n    &lt;li class&#x3D;&quot;completed&quot;&gt;完成任务2&lt;&#x2F;li&gt;\n    &lt;li class&#x3D;&quot;completed&quot;&gt;完成任务3&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n&lt;&#x2F;div&gt;\n\nCSS\nul &#123;\n  list-style: none;\n  color: #fff;\n  font-size: 20px;\n  border: 3px solid #000;\n  padding: 1rem 2rem;\n  min-height: 200px;\n  margin: 15px 2rem 0 0;\n  background: #323232;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);\n  border-radius: 8px;\n&#125;\n\nli &#123;\n  padding: 0.3rem 0;\n&#125;\n\nli::before &#123;\n  content: &#39;🗹 &#39;;\n  color: aqua;\n&#125;\n\nli.completed::before &#123;\n  content: &#39;✔ &#39;;\n  text-decoration: none;\n  color: greenyellow;\n&#125;\n\nli.completed &#123;\n  text-decoration: line-through;\n  color: #bdbdbd;\n&#125;\n\n::before和::after伪元素加content属性可以用来做很多特殊的效果，也是当代前端排版比较常用的“魔法”。说到伪元素的使用，我再给大家说一个比较常用的使用场景。\n在管理后台或者是文章展示中，我们经常可以见到的“面包屑导航”也是用伪元素来插入每个目录中间的符号的。实现逻辑\n一、这个导航含有 3 个a标签，首先给每个a标签加入一个伪元素::after，然后在content属性插入/符号。\n二、然后使用a:first-child，这个伪类会选择到第一个a标签，然后使用content属性加入»符号。\n三、因为我们第一步在每个a标签的后面插入了/符号, 所以我们需要在最后一个a标签清除掉。这里我们使用:last-child选择到最后一个a标签，然后用content: &quot; &quot;属性把伪元素的内容清楚掉。\nHTML\n&lt;div class&#x3D;&quot;breadcrumb&quot;&gt;\n  &lt;a&gt;三钻&lt;&#x2F;a&gt;\n  &lt;a&gt;前端&lt;&#x2F;a&gt;\n  &lt;a&gt;教程&lt;&#x2F;a&gt;\n&lt;&#x2F;div&gt;\n\nCSS\n.breadcrumb &#123;\n  font-size: 1.6rem;\n  color: #fff;\n&#125;\n.breadcrumb a:first-child &#123;\n  color: #82fcfd;\n&#125;\n.breadcrumb a:first-child::before &#123;\n  content: &#39; » &#39;;\n&#125;\n.breadcrumb a::after &#123;\n  content: &#39; &#x2F;&#39;;\n  color: #ef6eae;\n&#125;\n.breadcrumb a:last-child::after &#123;\n  content: &#39;&#39;;\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\n::before | ::after — 伪元素用于向某些选择器添加特殊的效果。\ncontent — CSS 属性用于在元素的 ::before 和 ::after 伪元素中插入内容。使用 content 属性插入的内容都是匿名的可替换元素。\n:first-child — CSS 伪类表示在一组兄弟元素中的第一个元素。\n:last-child — CSS 伪类代表父元素的最后一个子元素。\n\n自定义无序列表：预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢面包屑导航：预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n五、图片视差效果这个超级炫酷的效果在官网中非常的受欢迎，这种效果可以给用户带来视觉冲击，也给我们的网站带来了活力。普通的网页图片会跟随着网页一起滑动，但是视觉差效果图就会固定在底部，只有图片所在的窗口上的元素会移动。\n仅使用 CSS对你没有看错，这个效果只需要用到 CSS 就能轻易的实现！我们只要使用一个 CSS 背景图的属性background-attachment: fixed，这个特性会把背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\n实现理论：\n一、在含有图片的元素中加入background: url()和background-size: cover（第二个属性适用于定义图片为封面，可以让图片大小自动适应，在很大的屏幕也会显示完整的图片）\n二、然后附加固定背景图的属性background-attachment: fixed\n三、最后给这个元素加入一个高度height: 100%或者任意的高度height: 400px\n就那么简单哦！不用怀疑，马上上代码，大家都可以自己去试试哦！\nHTML\n&lt;div class&#x3D;&quot;wrapper&quot;&gt;\n   &lt;div class&#x3D;&quot;parallax-img&quot;&gt;&lt;&#x2F;img&gt;\n   &lt;p&gt;这里填写一堆文字就可以了，尽量多一点哦&lt;&#x2F;p&gt;\n&lt;&#x2F;div&gt;\n\nCSS\n.wrapper &#123;\n  height: 100wh;\n&#125;\n.parallax-img &#123;\n  background-attachment: fixed;\n  background-position: center;\n  background-repeat: no-repeat;\n  background-size: cover;\n  height: 100%;\n  background-image: url(&#39;http:&#x2F;&#x2F;ppe.oss-cn-shenzhen.aliyuncs.com&#x2F;collections&#x2F;182&#x2F;7&#x2F;thumb.jpg&#39;);\n&#125;\np &#123;\n  font-size: 20px;\n  padding: 1.5rem 3rem;\n  min-height: 1000px; &#x2F;&#x2F; 当你的文字内容不够，也能撑出足够的高度来看到效果，当然如果你文字足够多，就不需要了\n&#125;\n\n如果想做到我动图里面一样的效果，或者想看是怎么实现的，可以查看下面总结里面的“预览实际效果”或者看“GitHub 源码”。\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\nbackground-attachment: fixed — 把背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\nbackground-size: cover — 可以让图片大小自动适应，在很大的屏幕也会显示完整的图片。\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n使用 CSS + JavaScript有些童鞋可能没有被这个震撼到或者还是觉得不够刺激。那我们再来一个高级例子，上面的例子在滑动的时候图片是固定死的。如果我们加上 JavaScript 的助力，我们可以让窗口的图片缓慢的跟随这个页面滑动，使得效果更有动力和更有冲击感。\n实现理论首先讲一下排版，因为我们需要在我们滑动页面的时候使用 JavaScript 偏移图片，所以我们需要给图片一个 CSS 属性让我们可以让图片可以根据一个速度来往上或者往下移动。这个例子里面我们让所有图片包裹在一个div里面，class名为block。这个div给予相对定位属性position: relative，这个时候我们就可以在里面加入图片，然后让图片绝对定位position: absolute在这个div盒子里面。\n但是图片是可能很大的，我们需要把图片不超出我们定义个盒子，所以我们的div同时也给予了overflow: hidden和一个高度height: 100%。这样图片超出div盒子就会被隐藏。\n布局代码如下：\n&lt;div class&#x3D;&quot;block&quot;&gt;\n  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;unsplash.it&#x2F;1920&#x2F;1920&#x2F;?image&#x3D;1005&quot; data-speed&#x3D;&quot;-1&quot; class&#x3D;&quot;img-parallax&quot; &#x2F;&gt;\n  &lt;h2&gt;视差速度 -1&lt;&#x2F;h2&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;block&quot;&gt;\n  &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;unsplash.it&#x2F;1920&#x2F;1920&#x2F;?image&#x3D;1067&quot; data-speed&#x3D;&quot;1&quot; class&#x3D;&quot;img-parallax&quot; &#x2F;&gt;\n  &lt;h2&gt;视差速度 1&lt;&#x2F;h2&gt;\n&lt;&#x2F;div&gt;\n\nhtml,\nbody &#123;\n  margin: 0;\n  padding: 0;\n  height: 100%;\n  width: 100%;\n  font-family: &#39;Amatic SC&#39;, cursive;\n&#125;\n.block &#123;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n  font-size: 16px;\n&#125;\n.block h2 &#123;\n  position: relative;\n  display: block;\n  text-align: center;\n  margin: 0;\n  top: 50%;\n  transform: translateY(-50%);\n  font-size: 10vw;\n  color: white;\n  font-weight: 400;\n&#125;\n.img-parallax &#123;\n  width: 100vmax;\n  z-index: -1;\n  position: absolute;\n  top: 0;\n  left: 50%;\n  transform: translate(-50%, 0);\n  pointer-events: none;\n&#125;\n\n实现这个布局，在你滑动的时候，图片是不会移动的。因为最后一步就是加入 JavaScript 的辅助，让图片活起来。\n&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;3.4.1&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n  &#x2F;&#x2F; 循环获取每一个图片元素\n  $(&#39;.img-parallax&#39;).each(function () &#123;\n    var img &#x3D; $(this);\n    var imgParent &#x3D; $(this).parent();\n    function parallaxImg() &#123;\n      var speed &#x3D; img.data(&#39;speed&#39;); &#x2F;&#x2F; 获取每张图片设置了的偏移速度\n      var imgY &#x3D; imgParent.offset().top; &#x2F;&#x2F; 获取图片盒子所在的Y位置\n      var winY &#x3D; $(this).scrollTop(); &#x2F;&#x2F; 获取当前滑动到的位置\n      var winH &#x3D; $(this).height(); &#x2F;&#x2F; 获取浏览器窗口高度\n      var parentH &#x3D; imgParent.innerHeight(); &#x2F;&#x2F; 获取图片盒子的内高度\n\n      &#x2F;&#x2F; 浏览器窗口底部的所在位置\n      var winBottom &#x3D; winY + winH;\n\n      &#x2F;&#x2F; 当前图片是否进入浏览器窗口\n      if (winBottom &gt; imgY &amp;&amp; winY &lt; imgY + parentH) &#123;\n        &#x2F;&#x2F; 运算图片需要开始移动的位置\n        var imgBottom &#x3D; (winBottom - imgY) * speed;\n        &#x2F;&#x2F; 运算出图片需要停止移动的位置\n        var imgTop &#x3D; winH + parentH;\n        &#x2F;&#x2F; 获取从开始移动到结束移动的%（根据开始与结束像素 + 移动速度）\n        var imgPercent &#x3D; (imgBottom &#x2F; imgTop) * 100 + (50 - speed * 50);\n      &#125;\n      img.css(&#123;\n        top: imgPercent + &#39;%&#39;,\n        transform: &#39;translate(-50%, -&#39; + imgPercent + &#39;%)&#39;\n      &#125;);\n    &#125;\n    $(document).on(&#123;\n      scroll: function () &#123;\n        parallaxImg();\n      &#125;,\n      ready: function () &#123;\n        parallaxImg();\n      &#125;\n    &#125;);\n  &#125;);\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\nposition: relative — 相对定位。\nposition: absolute — 绝对定位。\noverflow: hidden — 如果需要，内容将被剪裁以适合填充框。 不提供滚动条。\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n六、裁剪图像的动画在有 CSS3 之前裁剪图片实现也是颇有难度的。现在我们有了两个非常方便简单的 CSS3 属性可以实现裁剪，那就是object-fit和object-position, 这两个属性可以让我们改变图片的大小，但是不影响图片的长宽比。\n当然我们可以使用图片处理工具或者使用 JavaScript 等插件来实现图片裁剪功能。但是因为有了 CSS3 的属性，我们不只可以裁剪，我们还可以用裁剪的属性来做图片的动态效果。\n为了让我们的例子更加简单，我们这里使用了&lt;input type=&quot;checkbox&quot;&gt;复选框元素，这样我们就可以使用:checked的伪类来触发启动效果。所以在例子里面我们完全不需要 JavaScript 的协助。\n实现原理：\n一、首先给予图片一个宽高height: 1080px，width: 1920px。\n二、然后用 CSS 选择器，锁定当input被选中后img标签的样式变化。当被选中时，给图片设定一个新的宽高，这里我们给宽高各自 500 像素：width: 500px，height: 500px。\n三、然后我们加上了过渡效果和时间让图片改变宽高时有动画过渡效果：transition: width 2s, height 4s;。\n四、最后加上object-fit: cover和object-position: left-top这两个属性来保持图片的宽高比例，这样就大功告成了！\n我们来看看完成的代码：\n勾选裁剪图片\n&lt;input type&#x3D;&quot;checkbox&quot; &#x2F;&gt;\n&lt;br &#x2F;&gt;\n&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;2020032122230564.png&quot; alt&#x3D;&quot;Random&quot; &#x2F;&gt;\n\ninput &#123;\n  transform: scale(1.5); &#x2F;* 只是用来放大复选框大小 *&#x2F;\n  margin: 10px 5px;\n  color: #fff;\n&#125;\n\nimg &#123;\n  width: 1920px;\n  height: 1080px;\n  transition: 0s;\n&#125;\n\n&#x2F;* css选择器锁定复选框被选中时的状态 *&#x2F;\ninput:checked + br + img &#123;\n  width: 500px;\n  height: 500px;\n  object-fit: cover;\n  object-position: left-top;\n  transition: width 2s, height 4s;\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\nobject-fit — CSS 属性指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框。\nobject-position — 用来切换被替换元素的内容对象在元素框内的对齐方式。\ntransition — 过渡可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n七、混合模式（Blend）如果有使用过 Photoshop 的同学对blend混合模式应该是非常熟悉了，我们都知道混合模式是非常强大，也是 p 图时非常常用的一个功能。但是你们有没有想象过可以在浏览器的 CSS 中直接使用呢？对我们不需要设计师给我们做图，我们前端也可以实现混合模式了。\n在 CSS 中我们不只可以对background背景加入混合模式，我们可以对任何一个元素的自带背景加入混合模式，让你可以做出很多之前没有想过的效果和排版。\n往一个元素加入混合模式，我们只需要使用到一个 CSS 属性mix-blend-mode即可。\n简单实现原理：\n首先我们只需要加一个 h1 标题标签\n&lt;h1&gt;混合模式：颜色减淡&lt;&#x2F;h1&gt;\n\n然后我们给h1标签加入mix-blend-mode中的颜色减弱模式color-dodge，但是要注意的是我们需要给body和html加入背景颜色background: white，要不你会发现这个效果会无效。因为h1我们没有给颜色，会自动往上级继承，并且混合模式是针对背景颜色的过滤，所以 body 和 html 需要有背景颜色才行。\nh1 &#123;\n  mix-blend-mode: color-dodge;\n  font-family: yahei;\n  font-size: 5rem;\n  text-align: center;\n  margin: 0;\n  padding: 20vh 200px;\n  color: #d1956c;\n&#125;\n\nhtml,\nbody &#123;\n  margin: 0;\n  background-color: white;\n&#125;\n\nbody &#123;\n  background-image: url(https:&#x2F;&#x2F;images.unsplash.com&#x2F;photo-1505567745926-ba89000d255a?ixlib&#x3D;rb-1.2.1&amp;ixid&#x3D;eyJhcHBfaWQiOjEyMDd9&amp;auto&#x3D;format&amp;fit&#x3D;crop&amp;w&#x3D;3302&amp;q&#x3D;80);\n  background-repeat: no-repeat;\n  background-size: cover;\n  min-height: 100vh;\n  overflow: hidden;\n&#125;\n\n换换背景图和h1标签的字体颜色就可以弄出各种不同的特效了。\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\nmix-blend-mode — CSS 属性描述了元素的内容应该与元素的直系父元素的内容和元素的背景如何混合。\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n八、瀑布流布局\nCSS Grid和Flexbox让我们可以更简便，更容易和更快的实现各式各样的响应布局，并且让我们快捷方便的在布局中实现横向剧中和竖向剧中。但是回想一下以前是颇为困难的。\n虽然这些新出的布局方式可以让我们解决很多以前的布局难题，但是像瀑布流布局这种，就无法用它们简单来实现了。因为瀑布流一般来说都是宽度一致，但是高度是根据图片自适应的。并且图片的位置也是根据在上方图片的位置而定的。\n其实最好实现瀑布流布局的办法就是用 CSS 的列属性套件，这套属性大多数都是用于排版杂志中的文本列。但是用于布局瀑布流也是特别实用哦。因为以前需要实现瀑布流，就必须有 JavaScript 的辅助来计算图片高度然后决定每张图片的定位和位置，所以现在有了列属性就可以使用纯 CSS 实现了。\n实现原理：\n实现这个布局，首选我们需要把所有的内容先包裹在一个div元素里面，然后给这个元素column-width和column-gap属性。\n然后，为了防止任何元素被分割到两个列之间，将column-break-inside: avoid添加到各个元素中。\n神奇的效果就完美实现了，零 JavaScript。\n我们来看看代码：\n&lt;div class&#x3D;&quot;columns&quot;&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?city&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?night&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?developer&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?building&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?water&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?coding&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?stars&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?forest&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?girls&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n  &lt;figure&gt;\n    &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;source.unsplash.com&#x2F;random?working&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n  &lt;&#x2F;figure&gt;\n&lt;&#x2F;div&gt;\n\n.columns &#123;\n  column-width: 320px;\n  column-gap: 15px;\n  width: 90%;\n  max-width: 1100px;\n  margin: 50px auto;\n&#125;\n.columns figure &#123;\n  display: inline-block;\n  box-shadow: 0 1px 2px rgba(34, 25, 25, 0.4);\n  column-break-inside: avoid;\n  border-radius: 8px;\n&#125;\n.columns figure img &#123;\n  width: 100%;\n  height: auto;\n  margin-bottom: 15px;\n  border-radius: 8px;\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟知识总结\n\ncolumn-width — CSS 属性建议一个最佳列宽。 列宽是在添加另一列之前列将成为最大宽度。\ncolumn-width — 该 CSS 属性用来设置元素列之间的间隔 (gutter) 大小。\ncolumn-break-inside — 设置或检索对象内部是否断。\n\n预览实际效果 ｜ GitHub 源码 ｜ 喜欢的童鞋 🌟star 一下谢谢\n\n总结我希望这 8 个前端小技巧和特效对大家有帮助，或多或少有吸收一点新的前端知识。这篇文章提到的内容，其实很多都是值得深挖和学习的。有一些例子我做的比较简单，但是其实是有无限的可能性。喜欢前端的童鞋们，让我们继续在前端领域中一起深挖，让我们的热爱无限的燃烧起来吧！\n\n在最后我想给大家讲一下我对前端的热爱和态度。\n回想前端这几年，发展真的是突飞猛进，从前端排版，HTML5+CSS3 做 H5 页面，到前端组件化，各种 UI 框架满天飞。\n一开始我随着热潮用起了 UI 框架，起初觉得特别方便，来一个新的项目就直接上一个 UI 框架，研发速度也非常快。但是久而久之就觉得前端开发变成了处理数据，对接接口，实现交互。\n某天在阅览国外的一些前端设计和框架的时候，我突然发现国内多数的前端开发者都不再怎么使用 CSS3 做出一些很好玩的布局和特效了。现在市面上的系统和页面都是千篇一律，普遍都是用一些知名的 UI 框架搭建系统和 APP，基本自己动手去排版已经少之又少。前端已不再是以前的前端，缺少了灵魂。\n但是我们回想一下，我们刚刚开始学习前端的时候，让我们最有成就感，觉得前端特别有意思的那种感觉。就是那种让我们觉得神乎奇迹，不可思议的布局，特效和交互。那种感觉自己成功实现了很优美，很炫酷的页面和特效的感觉，让我们越做越来劲，越做越是兴奋。\n但是在某些公司，研发部都是要求快速开发，UI 设计部门也是受到时间的控制和限制，所以逐步走进了 UI 框架的限制之中。都是围绕这一些 UI 框架来设计和开发系统和应用。\n作为一名热爱前端的开发者，我还是坚持在绝大多数的项目中，自己排版和实现页面交互特效。然后使用 UI 框架作为辅助，主要是用来减轻一些小组件和常用组建的快速实现。（可以说我是比较追求完美和外貌协会的程序员 😂）\n","slug":"frontend/8-html-css-tips","date":"2020-04-06T21:14:05.000Z","categories_index":"FrontEnd","tags_index":"HTML&CSS,CSS Animation","author_index":"三钻"},{"id":"56de591f4fe649ed3240d0bc6749a7d2","title":"浏览器工作原理 — 之 HTTP 请求与解析","content":"浏览器工作原理是一块非常重要的内容，我们经常看到的 重绘 、重排 或者一些讲解 CSS 属性的时候，都会用到一些浏览器工作原理的知识来讲解。理论化学习浏览器工作原理，效果不是很大，而且很枯燥，所以这里我们从零开始用 JavaScript 来实现一个浏览器。\n通过自己实现一遍简单的浏览器，我们会对浏览器的基本原理有更为深刻的理解。\n\n浏览器基础渲染流程\n\n首先浏览器是由 5 个步骤完成的整体渲染\n我们从 URL 访问一个网页，经过浏览器的解析和渲染后成为了 Bitmap\n最后通过我们的显卡驱动设配出去画面，让我们看到完成的页面\n这是一个浏览器的渲染流程\n这里我们只实现一个简单的基础流程，但是真正的浏览器还包含了很多功能，比如历史等等\n\n\n\n\n\n\n\n\n\n\n我们主要需要完成的是从 URL 请求到 Bitmap 页面展示的整个流程就可以了。\n浏览器流程：\n\nURL 部分，经过 HTTP 请求，然后解析返回内容，然后提取 HTML 内容\n得到 HTML 后，我们可以通过文本分析（parse），然后把 HTML 的文本编程一个 DOM 树\n这个时候的 DOM 树是光秃秃的，下一步我们进行 CSS 计算（CSS computing），最终把 CSS 挂载在这个 DOM 树上\n经过计算后，我们就拥有一个有样式的 DOM 树，这个时候我们就可以布局（或者排版）了\n通过布局计算，每一个 DOM 都会得到一个计算后的盒（当然实际浏览器中是每个 CSS 都会生成一个盒，但是为了简化这个，我们这里只做到每个 DOM 只生成一个盒即可）\n最后我们就可以开始渲染（Render），把这个 DOM 树该有背景图的有背景图，该有背景色的有背景色，最后把这些样式画到一张图片上。然后我们可以通过操作系统和硬件驱动提供的 API 接口，展示出来给用户看了。\n\n\n有限状态机去处理字符串因为这个处理字符串是整个的浏览器里面贯穿使用的技巧，如果不会用这个状态机，后面实现和读浏览器实现的代码会非常吃力。所以这里我们先讲讲什么是有限状态机。\n\n每一个状态都是一个机器\n每个机器都是互相解耦，强有力的抽象机制\n在每一个机器里，我们可以做计算、存储、输出等\n所有的这些机器接受的输入是一致的\n状态机的每一个机器本身没有状态，如果我们用函数来表达的话，它应该是纯函数（无副作用）\n无副作用指的是：不应该再受外部的输入控制，输入是可以的\n\n\n每一个机器知道下一个状态\n每一个机器都有确定的下一个状态（Moore）\n每一个机器根据输入决定下一个状态（Mealy）\n\n\n\nJavaScript 中如何实现Mealy 状态机：\n// 每个函数是一个状态\nfunction state(input) {\n  // 函数参数就是输入\n  // 在函数中，可以自由地编写代码，处理每个状态的逻辑\n  return next; // 返回值作为下一个状态\n}\n\n/** ========= 以下是调试 ========= */\nwhile (input) {\n  // 获取输入\n  state = state(input); // 把状态机的返回值作为下一个状态\n}\n\n\n以上代码我们看到，每一个函数是一个状态\n然后函数的参数是输入 input\n这个函数的返回值就是下一个状态，也就意味着下一个返回值一定得是一个状态函数\n状态机理想的实现方式：一系列返回状态函数的一批状态函数\n调用状态函数的时候，往往会用一个循环来获取输入，然后通过 state = state(input)，来让状态机接收输入来完成状态切换\nMealy 型状态机，返回值一定是根据 input 返回下一个状态\nMoore 型状态机，返回值是与 input 没有任何关系，都是固定的状态返回\n\n不使用状态机处理字符串我们首先了解一下，在不使用状态机的情况下来实现一些字符串的处理方式：\n第一问题：在一个字符串中，找到字符“a”\nfunction match(string) {\n  for (let letter of string) {\n    if (letter == 'a') return true;\n  }\n  return false;\n}\n\nconsole.log(match('I am TriDiamond'));\n\n第二个问题：不准使用正则表达式，纯粹用 JavaScript 的逻辑实现：在一个字符串中，找到字符“ab”\n「直接寻找 a 和 b，都找到时返回」\n/**\n * 直接寻找 `a` 和 `b`，都找到时返回\n * @param {*} string 被匹配的字符\n */\nfunction matchAB(string) {\n  let hasA = false;\n  for (let letter of string) {\n    if (letter == 'a') {\n      hasA = true;\n    } else if (hasA &amp;&amp; letter == 'b') {\n      return true;\n    } else {\n      hasA = false;\n    }\n  }\n  return false;\n}\n\nconsole.log(matchAB('hello abert'));\n\n第三个问题：不准使用正则表达式，纯粹用 JavaScript 的逻辑实现：在一个字符串中，找到字符“abcdef”\n方法一：「使用暂存空间，移动指针来检测」\n/**\n * 使用暂存空间，移动指针来检测\n * @param {*} match 需要匹配的字符\n * @param {*} string 被匹配的字符\n */\nfunction matchString(match, string) {\n  const resultLetters = match.split(''); // 需要匹配的字符拆解成数组来记录\n  const stringArray = string.split(''); // 把被匹配的字符串内容也拆解成数组\n  let index = 0; // 匹配字符串的指针\n\n  for (let i = 0; i &lt;= stringArray.length; i++) {\n    // 因为要保证字符的绝对匹配，如 “ab” 不能是 \"abc\",不能是 \"a b\"\n    // 所以这里需要两个字符必须是有顺序的关系的\n    if (stringArray[i] == resultLetters[index]) {\n      // 如果找到一个字符是吻合的，就 index + 1 找下一个字符\n      index++;\n    } else {\n      // 如果下一个字符不吻合，就重置重新匹配\n      index = 0;\n    }\n    // 如果已经匹配完所有的字符了，直接可以返回 true\n    // 证明字符中含有需要寻找的字符\n    if (index &gt; resultLetters.length - 1) return true;\n  }\n  return false;\n}\n\nconsole.log('方法1', matchString('abcdef', 'hello abert abcdef'));\n\n方法二：「使用 substring和匹配字符的长度来截取字符，看是否等于答案」\n/**\n * 通用字符串匹配 - 参考方法2（使用substring）\n * @param {*} match 需要匹配的字符\n * @param {*} string 被匹配的字符\n */\nfunction matchWithSubstring(match, string) {\n  for (let i = 0; i &lt; string.length - 1; i++) {\n    if (string.substring(i, i + match.length) === match) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconsole.log('方法2', matchWithSubstring('abcdef', 'hello abert abcdef'));\n\n方法三：「逐个查找，直到找到最终结果」\n/**\n * 逐个查找，直到找到最终结果\n * @param {*} string 被匹配的字符\n */\nfunction match(string) {\n  let matchStatus = [false, false, false, false, false, false];\n  let matchLetters = ['a', 'b', 'c', 'd', 'e', 'f'];\n  let statusIndex = 0;\n\n  for (let letter of string) {\n    if (letter == matchLetters[0]) {\n      matchStatus[0] = true;\n      statusIndex++;\n    } else if (matchStatus[statusIndex - 1] &amp;&amp; letter == matchLetters[statusIndex]) {\n      matchStatus[statusIndex] = true;\n      statusIndex++;\n    } else {\n      matchStatus = [false, false, false, false, false, false];\n      statusIndex = 0;\n    }\n\n    if (statusIndex &gt; matchLetters.length - 1) return true;\n  }\n  return false;\n}\n\nconsole.log('方法3', match('hello abert abcdef'));\n\n使用状态机处理字符这里我们使用状态机的方式来实现：在一个字符串中，找到字符“abcdef”\n\n首先每一个状态都是状态函数\n我们应该有一个开始状态和结束状态函数，分别问题 start 和 end\n状态函数名字都代表当前状态的情况 matchedA 就是已经匹配中 a 字符了，以此类推\n每一个状态中的逻辑就是匹配下一个字符\n如果匹配成功返回下一个状态函数\n如果匹配失败返回开始状态 start\n因为字符中最后一个是 f 字符，所以 matchedE 成功后，可以直接返回 结束状态end\nend 这个结束状态，也被称为陷阱方法 (Trap)，因为状态转变结束了，所以让状态一直停留在这里，知道循环结束\n\n/**\n * 状态机字符串匹配\n * @param {*} string\n */\nfunction match(string) {\n  let state = start;\n\n  for (let letter of string) {\n    state = state(letter); // 状态切换\n  }\n\n  return state === end; // 如果最后的状态函数是 `end` 即返回 true\n}\n\nfunction start(letter) {\n  if (letter === 'a') return matchedA;\n  return start;\n}\n\nfunction end(letter) {\n  return end;\n}\n\nfunction matchedA(letter) {\n  if (letter === 'b') return matchedB;\n  return start(letter);\n}\n\nfunction matchedB(letter) {\n  if (letter === 'c') return matchedC;\n  return start(letter);\n}\n\nfunction matchedC(letter) {\n  if (letter === 'd') return matchedD;\n  return start(letter);\n}\n\nfunction matchedD(letter) {\n  if (letter === 'e') return matchedE;\n  return start(letter);\n}\n\nfunction matchedE(letter) {\n  if (letter === 'f') return end(letter);\n  return start(letter);\n}\n\nconsole.log(match('I am abcdef'));\n\n问题升级：用状态机实现字符串“abcabx”的解析\n\n这个问题与上面的区别在于”ab”有重复\n所以我们分析的逻辑应该是：\n第一次 “b” 后面是 “c”，而第二次 “b” 后面就应该是 “x”\n如果第二次的后面不是 “x” 的话就回到上一个判断状态函数\n\n\n\n/**\n * 状态机匹配字符串\n * @param {*} string 被匹配的字符\n */\nfunction match(string) {\n  let state = start;\n\n  for (let letter of string) {\n    state = state(letter);\n  }\n\n  return state === end;\n}\n\nfunction start(letter) {\n  if (letter === 'a') return matchedA;\n  return start;\n}\n\nfunction end(letter) {\n  return end;\n}\n\nfunction matchedA(letter) {\n  if (letter === 'b') return matchedB;\n  return start(letter);\n}\n\nfunction matchedB(letter) {\n  if (letter === 'c') return matchedC;\n  return start(letter);\n}\n\nfunction matchedC(letter) {\n  if (letter === 'a') return matchedA2;\n  return start(letter);\n}\n\nfunction matchedA2(letter) {\n  if (letter === 'b') return matchedB2;\n  return start(letter);\n}\n\nfunction matchedB2(letter) {\n  if (letter === 'x') return end;\n  return matchedB(letter);\n}\n\nconsole.log('result: ', match('abcabcabx'));\n\n\nHTTP 协议解析基础知识ISO-OSI 七层网络模型HTTP\n\n组成：\n应用\n表示\n会话\n\n\n对应 node 的代码里，我们有熟悉的 require('http')\n\nTCP\n\n组成：\n传输\n\n\n因为网页是需要可靠传输，所以我们只关心 TCP\n\nInternet\n\n组成：\n网络\n\n\n有时候讲上网有两层意思\n网页所在的应用层的协议（外网）—— 负责数据传输的是 Internet\n公司内网，叫 Intranet\n\n\n\n4G/5G/Wi-Fi\n\n组成：\n数据链路\n物理层\n\n\n为了完成对数据准确的传输\n传输都是点对点的传输\n必须有直接的连接才能进行传输\n\nTCP 与 IP 的基础知识\n流\nTCP 层中传输数据的概念是 “流”\n流是一种没有明显的分割单位\n它只保证前后的顺序是正确的\n\n\n端口\nTCP 协议是被计算机里面的软件所使用的\n每一个软件都会去从网卡去拿数据\n端口决定哪一个数据分配给哪一个软件\n对应 node.js 的话就是应用 require('net')\n\n\n包\nTCP 的传输概念就是一个一个的数据包\n每一个数据包可大可小\n这个取决于你整个的网络中间设备的传输能力\n\n\nIP 地址\nIP 根据地址去找到数据包应该从哪里到哪里\n在 Internet 上的连接关系非常复杂，中间就会有一些大型的路由节点\n当我们访问一个 IP 地址时，就会连接上我们的小区地址上，然后到电信的主干\n如果是访问外国的话，就会再上到国际的主干地址上\n这个 IP 地址是唯一的标识，连入 Internet 上的每一个设备\n所以 IP 包，就是通过 IP 地址找到自己需要被传输到哪里\n\n\nlibnet/libpcap\nIP 协议需要调用到 C++ 的这两个库\nlibnet 负责构造 IP 包并且发送\nlabpcap 负责从网卡抓取所有流经网卡的 IP 包\n如果我们去用交换机而不是路由器去组网，我们用底层的 labpcap 包就能抓到很多本来不属于发给我们的 IP 包\n\n\n\nHTTP\n组成\nRequest 请求\nResponse 返回\n\n\n相对于 TCP 这种全双工通道，就是可以发也可以收，没有优先关系\n而 HTTP 特别的是必须得先由客户端发起一个 request\n然后服务端回来一个 response\n所以每一个 request 必定有一个对应的 response\n如果 request 或者 response 多了都说明协议出错\n\n\nHTTP 请求 —— 服务端环境准备在我们编写自己的浏览器之前，我们首先建立一个 node.js 服务端。\n首先我们编写一个 node.js 的服务端：\nconst http = require('http');\n\nhttp\n  .createServer((request, response) =&gt; {\n    let body = [];\n    request\n      .on('error', (err) =&gt; {\n        console.error(err);\n      })\n      .on('data', (chunk) =&gt; {\n        body.push(chunk.toString());\n      })\n      .on('end', () =&gt; {\n        body = Buffer.concat(body).toString();\n        console.log('body', body);\n        response.writeHead(200, { 'Content-Type': 'text/html' });\n        response.end(' Hello World\\n');\n      });\n  })\n  .listen(8080);\n\nconsole.log('server started');\n\n了解 HTTP Request 协议在编写我们的客户端代码之前，我们需要先了解一下 HTTP 协议。\n我们先来看看 HTTP 协议的 request 部分：\n\n\n\n\n\n\n\n\n\nPOST / HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nfield1=aaa&amp;code=x%3D1\n\nHTTP 协议是一个文本型的协议，文本型的协议一般来说与二进制的协议是相对的，也意味着这个协议里面所有内容都是字符串，每一个字节都是字符串的一部分。\nHTTP 协议的第一行叫做 request line，包含了三个部分：\nMethod：例如 POST，GET 等\nPath：默认就是 “/”\nHTTP 和 HTTP 版本：HTTP/1.1\n\n\n然后接下来就是 Headers\nHeader 的行数不固定\n每一行都是以一个冒号分割了 key: value 格式\nHeaders 是以空行进行结束\n\n\n最后的一部分就是 body 部分：\n这个部分的内容是以 Content-Type来决定的\nContent-Type 规定了什么格式，那么 body 就用什么格式来写\n\n\n\n接下来我们就可以开始编写代码了！\n\n实现 HTTP 请求\n设计一个 HTTP 请求的类\ncontent type 是一个必要的字段，要有默认值\nbody 是 KV 格式\n不同的 content-type 影响 body 的格式\n\nRequest 类class Request {\n  constructor(options) {\n    // 首先在 constructor 赋予需要使用的默认值\n    this.method = options.method || 'GET';\n    this.host = options.host;\n    this.port = options.port || 80;\n    this.path = options.path || '/';\n    this.body = options.body || {};\n    this.headers = options.headers || {};\n\n    if (!this.headers['Content-Type']) {\n      this.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n    }\n    // 根据 Content-Type 转换 body 的格式\n    if (this.headers['Content-Type'] === 'application/json') {\n      this.bodyText = JSON.stringify(this.body);\n    } else if (this.headers['Content-Type'] === 'application/x-www-form-urlencoded') {\n      this.bodyText = Object.keys(this.body)\n        .map((key) =&gt; `${key}=${encodeURIComponent(this.body[key])}`)\n        .join('&amp;');\n    }\n    // 自动计算 body 内容长度，如果长度不对，就会是一个非法请求\n    this.headers['Content-Length'] = this.bodyText.length;\n  }\n  // 发送请求的方法，返回 Promise 对象\n  send() {\n    return new Promise((resolve, reject) =&gt; {\n      //......\n    });\n  }\n}\n\n请求方法/**\n * 请求方法\n */\nvoid (async function () {\n  let request = new Request({\n    method: 'POST',\n    host: '127.0.0.1',\n    port: '8080',\n    path: '/',\n    headers: {\n      ['X-Foo2']: 'custom'\n    },\n    body: {\n      name: 'tridiamond'\n    }\n  });\n\n  let response = await request.end();\n\n  console.log(response);\n})();\n\n\nRequest 类中的 send 函数编写\nSend 函数是一个 Promise 的形式\n所以在 send 的过程中会逐步收到 response\n最后把 response 构造好之后再让 Promise 得到 resolve\n因为过程是逐步收到信息的，我们需要设计一个 ResponseParse\n这样 Parse 可以通过逐步地去接收 response 的信息来构造 response 对象不同的部分\n\n// 发送请求的方法，返回 Promise 对象\n  send() {\n    return new Promise((resolve, reject) =&gt; {\n      const parser = new ResponseParser();\n      resolve('');\n    });\n  }\n\n设计 ResponseParser\nReceive 函数接收字符串\n然后用状态机对逐个字符串进行处理\n所以我们需要循环每个字符串，然后加入 recieveChar 函数来对每个字符进行处理\n\nclass ResponseParser {\n  constructor() {}\n  receive(string) {\n    for (let i = 0; i &lt; string.length; i++) {\n      this.receiveChar(string.charAt(i));\n    }\n  }\n  receiveChar(char) {}\n}\n\n了解 HTTP Response 协议在接下来的部分，我们需要在代码中解析 HTTP Response 中的内容，所以我先来了解一下 HTTP Response 中的内容。\n\n\n\n\n\n\n\n\n\nHTTP/1.1 200 OK\nContent-Type: text/html\nDate: Mon, 23 Dec 2019 06:46:19 GMT\nConnection: keep-alive\nTransfer-Encoding: chunked\n26\n Hello World \n\n0\n\n首先第一行的 status line 与 request line 相反\n第一部分是 HTTP 协议的版本：HTTP/1.1\n第二部分是 HTTP 状态码：200 (在实现我们的浏览器，为了更加简单一点，我们可以把 200 以外的状态为出错)\n第三部分是 HTTP 状态文本：OK\n\n\n随后的部分就是 header 部分\nHTML 的 request 和 response 都是包含 header 的\n它的格式跟 request 是完全一致的\n最后是一个空行，用来分割 headers 和 body 内容的部分的\n\n\n最后这里的就是 body 部分了\n这里 body 的格式也是根据 Content-Type 来决定的\n这里有一种比较典型的格式叫做 chunked body (是 Node 默认返回的一种格式)\nChunked body 是由一个十六进制的数字单独占一行\n后面跟着内容部分\n最后跟着一个十六进制的 0，0 之后就是整个 body 的结尾了\n这个也是用来分割 body 的内容\n\n\n\n实现发送请求这里我们开始实战，通过实现 send 函数中的逻辑来真正发送请求到服务端。\n\n设计支持已有的 connection 或者自己新增 connection\n收到数据传给 parser\n根据 parser 的状态 resolve Promise\n\n通过以上思路，我们来实现代码：\n// 发送请求的方法，返回 Promise 对象\n  send(connection) {\n    return new Promise((resolve, reject) =&gt; {\n      const parser = new ResponseParser();\n      // 先判断 connection 是否有传送过来\n      // 没有就根据，Host 和 port 来创建一个 TCP 连接\n      // `toString` 是把请求参数按照 HTTP Request 的格式组装\n      if (connection) {\n        connection.write(this.toString());\n      } else {\n        connection = net.createConnection(\n          {\n            host: this.host,\n            port: this.port,\n          },\n          () =&gt; {\n            connection.write(this.toString());\n          }\n        );\n      }\n      // 监听 connection 的 data\n      // 然后原封不动传给 parser\n      // 如果 parser 已经结束的话，我们就可以进行 resolve\n      // 最后断开连接\n      connection.on('data', data =&gt; {\n        console.log(data.toString());\n        parser.receive(data.toString());\n\n        if (parser.isFinished) {\n          resolve(parser.response);\n          connection.end();\n        }\n      });\n      // 监听 connection 的 error\n      // 如果请求出现错误，首先 reject 这个promise\n      // 然后断开连接，避免占着连接的情况\n      connection.on('error', err =&gt; {\n        reject(err);\n        connection.end();\n      });\n    });\n  }\n  /**\n   * 组装 HTTP Request 文本内容\n   */\n  toString() {\n    return `${this.method} ${this.path} HTTP/1.1\\r\n      ${Object.keys(this.headers)\n        .map(key =&gt; `${key}: ${this.headers[key]}`)\n        .join('\\r\\n')}\\r\\r\n      ${this.bodyText}`;\n  }\n\n\n实现 RequestParser 类现在我们来具体实现 RequestParser 类的代码。\n\nResponse 必须分段构造，所以我们要用一个 Response Parser 来 “装配”\nResponseParser 分段处理 Response Text，我们用状态机来分析文本结构\n\n/**\n * Response 解析器\n */\nclass ResponseParser {\n  constructor() {\n    this.state = this.waitingStatusLine;\n    this.statusLine = '';\n    this.headers = {};\n    this.headerName = '';\n    this.headerValue = '';\n    this.bodyParser = null;\n  }\n\n  receive(string) {\n    for (let i = 0; i &lt; string.length; i++) {\n      this.state = this.state(string.charAt(i));\n    }\n  }\n\n  receiveEnd(char) {\n    return receiveEnd;\n  }\n\n  /**\n   * 等待状态行内容\n   * @param {*} char 文本\n   */\n  waitingStatusLine(char) {\n    if (char === '\\r') return this.waitingStatusLineEnd;\n    this.statusLine += char;\n    return this.waitingStatusLine;\n  }\n\n  /**\n   * 等待状态行结束\n   * @param {*} char 文本\n   */\n  waitingStatusLineEnd(char) {\n    if (char === '\\n') return this.waitingHeaderName;\n    return this.waitingStatusLineEnd;\n  }\n\n  /**\n   * 等待 Header 名\n   * @param {*} char 文本\n   */\n  waitingHeaderName(char) {\n    if (char === ':') return this.waitingHeaderSpace;\n    if (char === '\\r') return this.waitingHeaderBlockEnd;\n    this.headerName += char;\n    return this.waitingHeaderName;\n  }\n\n  /**\n   * 等待 Header 空格\n   * @param {*} char 文本\n   */\n  waitingHeaderSpace(char) {\n    if (char === ' ') return this.waitingHeaderValue;\n    return this.waitingHeaderSpace;\n  }\n\n  /**\n   * 等待 Header 值\n   * @param {*} char 文本\n   */\n  waitingHeaderValue(char) {\n    if (char === '\\r') {\n      this.headers[this.headerName] = this.headerValue;\n      this.headerName = '';\n      this.headerValue = '';\n      return this.waitingHeaderLineEnd;\n    }\n    this.headerValue += char;\n    return this.waitingHeaderValue;\n  }\n\n  /**\n   * 等待 Header 行结束\n   * @param {*} char 文本\n   */\n  waitingHeaderLineEnd(char) {\n    if (char === '\\n') return this.waitingHeaderName;\n    return this.waitingHeaderLineEnd;\n  }\n\n  /**\n   * 等待 Header 内容结束\n   * @param {*} char 文本\n   */\n  waitingHeaderBlockEnd(char) {\n    if (char === '\\n') return this.waitingBody;\n    return this.waitingHeaderBlockEnd;\n  }\n\n  /**\n   * 等待 body 内容\n   * @param {*} char 文本\n   */\n  waitingBody(char) {\n    console.log(char);\n    return this.waitingBody;\n  }\n}\n\n\n实现 Body 内容解析器最后我们来实现 Body 内容的解析逻辑。\n\nResponse 的 body 可能根据 Content-Type 有不同的结构，因此我们会采用子 Parser 的结构来解决问题\n以 ChunkedBodyParser 为例，我们同样用状态机来处理 body 的格式\n\n/**\n * Response 解析器\n */\nclass ResponseParser {\n  constructor() {\n    this.state = this.waitingStatusLine;\n    this.statusLine = '';\n    this.headers = {};\n    this.headerName = '';\n    this.headerValue = '';\n    this.bodyParser = null;\n  }\n\n  get isFinished() {\n    return this.bodyParser &amp;&amp; this.bodyParser.isFinished;\n  }\n\n  get response() {\n    this.statusLine.match(/HTTP\\/1.1 ([0-9]+) ([\\s\\S]+)/);\n    return {\n      statusCode: RegExp.$1,\n      statusText: RegExp.$2,\n      headers: this.headers,\n      body: this.bodyParser.content.join('')\n    };\n  }\n\n  receive(string) {\n    for (let i = 0; i &lt; string.length; i++) {\n      this.state = this.state(string.charAt(i));\n    }\n  }\n\n  receiveEnd(char) {\n    return receiveEnd;\n  }\n\n  /**\n   * 等待状态行内容\n   * @param {*} char 文本\n   */\n  waitingStatusLine(char) {\n    if (char === '\\r') return this.waitingStatusLineEnd;\n    this.statusLine += char;\n    return this.waitingStatusLine;\n  }\n\n  /**\n   * 等待状态行结束\n   * @param {*} char 文本\n   */\n  waitingStatusLineEnd(char) {\n    if (char === '\\n') return this.waitingHeaderName;\n    return this.waitingStatusLineEnd;\n  }\n\n  /**\n   * 等待 Header 名\n   * @param {*} char 文本\n   */\n  waitingHeaderName(char) {\n    if (char === ':') return this.waitingHeaderSpace;\n    if (char === '\\r') {\n      if (this.headers['Transfer-Encoding'] === 'chunked') {\n        this.bodyParser = new ChunkedBodyParser();\n      }\n      return this.waitingHeaderBlockEnd;\n    }\n    this.headerName += char;\n    return this.waitingHeaderName;\n  }\n\n  /**\n   * 等待 Header 空格\n   * @param {*} char 文本\n   */\n  waitingHeaderSpace(char) {\n    if (char === ' ') return this.waitingHeaderValue;\n    return this.waitingHeaderSpace;\n  }\n\n  /**\n   * 等待 Header 值\n   * @param {*} char 文本\n   */\n  waitingHeaderValue(char) {\n    if (char === '\\r') {\n      this.headers[this.headerName] = this.headerValue;\n      this.headerName = '';\n      this.headerValue = '';\n      return this.waitingHeaderLineEnd;\n    }\n    this.headerValue += char;\n    return this.waitingHeaderValue;\n  }\n\n  /**\n   * 等待 Header 行结束\n   * @param {*} char 文本\n   */\n  waitingHeaderLineEnd(char) {\n    if (char === '\\n') return this.waitingHeaderName;\n    return this.waitingHeaderLineEnd;\n  }\n\n  /**\n   * 等待 Header 内容结束\n   * @param {*} char 文本\n   */\n  waitingHeaderBlockEnd(char) {\n    if (char === '\\n') return this.waitingBody;\n    return this.waitingHeaderBlockEnd;\n  }\n\n  /**\n   * 等待 body 内容\n   * @param {*} char 文本\n   */\n  waitingBody(char) {\n    this.bodyParser.receiveChar(char);\n    return this.waitingBody;\n  }\n}\n\n/**\n * Chunked Body 解析器\n */\nclass ChunkedBodyParser {\n  constructor() {\n    this.state = this.waitingLength;\n    this.length = 0;\n    this.content = [];\n    this.isFinished = false;\n  }\n\n  receiveChar(char) {\n    this.state = this.state(char);\n  }\n\n  /**\n   * 等待 Body 长度\n   * @param {*} char 文本\n   */\n  waitingLength(char) {\n    if (char === '\\r') {\n      if (this.length === 0) this.isFinished = true;\n      return this.waitingLengthLineEnd;\n    } else {\n      // 转换十六进制长度\n      this.length *= 16;\n      this.length += parseInt(char, 16);\n    }\n    return this.waitingLength;\n  }\n\n  /**\n   * 等待 Body line 结束\n   * @param {*} char 文本\n   */\n  waitingLengthLineEnd(char) {\n    if (char === '\\n') return this.readingTrunk;\n    return this.waitingLengthLineEnd;\n  }\n\n  /**\n   * 读取 Trunk 内容\n   * @param {*} char 文本\n   */\n  readingTrunk(char) {\n    this.content.push(char);\n    this.length--;\n    if (this.length === 0) return this.waitingNewLine;\n    return this.readingTrunk;\n  }\n\n  /**\n   * 等待新的一行\n   * @param {*} char 文本\n   */\n  waitingNewLine(char) {\n    if (char === '\\r') return this.waitingNewLineEnd;\n    return this.waitingNewLine;\n  }\n\n  /**\n   * 等待新的一行结束\n   * @param {*} char 文本\n   */\n  waitingNewLineEnd(char) {\n    if (char === '\\n') return this.waitingLength;\n    return this.waitingNewLineEnd;\n  }\n}\n\n\n最后\n\n\n\n\n\n\n\n\n我是三钻，一个在《技术银河》中等你们一起来终生漂泊学习。\n点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n这里我们就实现了浏览器的 HTTP Request 请求，HTTP Response 解析的过程的代码。\n下一篇文我们来一起实现 HTTP 解析并且构建 DOM 树，然后进行 CSS 计算。\n\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n\n\n\n","slug":"frontend/browser-working-logic-1","date":"2020-08-15T18:49:36.000Z","categories_index":"FrontEnd","tags_index":"JavaScript,Browser","author_index":"三钻"},{"id":"78111f2bf31f70cf67b6b3119a253d63","title":"一篇文章搞懂前端学习方法与构建知识体系","content":"在大前端的成长路上，很多的同学都非常的迷茫，看到一座座越来越高的山。慢慢在工作中也对自己的职业发展也特别迷茫。有些粉丝也私信我问过我一些职业发展的问题，还有“我应该学习什么技术？”，“学习到什么层级才是个头”。\n这次我给大家带来一遍文章，给大家讲讲怎么样才是一个优秀的前端工程师，怎么做自己的职业规划，如何学习和构建知识体系。\n\n什么是优秀的前端工程师？\n大家眼中的优秀工程师\n熟练掌握 Vue React\nWeb 标准\n会用 Webpack Babel\n十年经验\n性能优化\n闭包，函数式编程\n会写 NodeJS\n\n\n\n\n\n\n\n\n\n\n这些其实都是错误的认知！\n真正优秀的工程师明确衡量的标准：\n\n领域知识\n不同工程师的工种有不一样的领域\n领域知识是互相关联的，不能只一方面很强\n\n\n能力和潜力\n能力 —— 明确的能力要求，或者角色的要求，能力达标就能进入下一个级别。\n潜力 —— 能力的上限，同样的层级的人，同样能写出同样的代码，但是区别在于独立解决问题的能力和出解决方案。\n每年都有 KPI（30% - 优秀，60% - 普通，10% - 不合格），潜力评估（预计几年内可以晋升）\n\n\n职业规划\n工程师 (P5) —— 独立工作\n资深工程师 (P6) —— 核心和骨干，小组长的位置，能带领突破难题\n专家 (P7) —— 领域专家，在某一种领域成型一种权威，推动发展，在自己的领域内可以用通用的解决办法解决问题\n经理 (P8)\n\n\n如何晋升？\n持续提升技术能力\n在领域中有沉淀\n\n\n成就\n用你达到的成就来证明你的能力\n根据你曾经做过的东西，曾经承担过的事情\n\n\n\n职业规划\n\n\n\n\n\n\n\n\n You  are the owner of your career.\n\n很多人觉得职业规划是“老板”，“爸妈”，“老师”的事，其实你才是职业的主人\n很多同学在执行的时候就走形了，很多人觉得职业晋升是老板的意识，如果老板没有给我们晋升我们就认命了吗？\n不是的，你的职业你才是主人，职业发现的结果我们要为他负责，所以我们要有行动（要不就谈判，要不就离职等等）\n职业规划对我们自己影响是最大的，所以我们要有一个 owner 的态度，拿出一个方案来保障自己的结果\n明确知道自己在这个公司什么时间，要达到什么样一个级别，如果不能就要思考怎么做到\n所以在职场中，要保持一种危机感和紧迫感，如果我们一旦误就会止步不前了\n我们该投入的精力，没有去投入，是没有人可以为你负责的，职业发展也是一样的\n\n职业发展\n成长 - 通过学习，沉淀获得成长\n成就 - 成长后必定能做出一定的成就，成就可以用来证明自己的技术能力级别\n晋升 - 获得成就就能证明自己可以晋升到下一个级别\n\n业务型成就\n业务目标\n理解公司业务的核心目标\n目标转化为指标（UV，PV，页面加载时间，成交的钱）\n\n\n技术方案\n业务指标到技术指标的转化\n形成纸面方案、完成小规模试验\n\n\n实施方案\n确定实施目标、参与人\n管理实施进度\n\n\n结果评估\n数据采集、数据报表\n向上级汇报\n没有结果是不可能获得晋升的，只会落得一个“勤奋耐劳”的称号\n\n\n\n案例：\n\n业务目标 &amp; 指标：点击率\n技术方案：给 tab 组件增加手势操作\n实施 1：在业务中加入对应功能，并上线\n结果：点击率提升 3 倍\n实施 2：编写通用 tab 组件，向所有导购业务推广，形成制度\n\n工程型成就\n目标\n质量\n效率\n\n\n方案与实施\n规章制度\n库\n工具\n系统\n\n\n结果\n线上监控\n\n\n\n案例——XSS 攻击的预防：\n\n目标 &amp; 指标：XSS 攻击白帽子反馈漏洞\n技术方案：整理安全手册，review 历史代码，代码扫码工具\n实施：对全体前端宣讲，整体 review 代码，更改代码发布流程\n结果：XSS 漏洞大幅减少\n\n技术难题\n目标\n公认的技术难题\n能影响业务\n\n\n方案与实施\n依靠扎实的编程能力\n\n\n\n例子——爬取商品价格：\n\n背景：在某浏览器插件项目中，需要爬取各个网站价格比价，但是各个网站会采用图片价格等手段防御\n方案：引入 JS 端的数字识别技术，靠 AI 技术解决\n\n\n前端与学习方法\n\n\n\n\n\n\n\n\n\n对学习知识体系的态度，应该不要去强求，而是去理解知识体系的完整性和框架，多面，多维度，多方面的去累积来补足，补全自己的知识体系。\n\n很多同学在质问学习的东西有没有用\n很多知识其实是没有用的，但是有一些微小的点可能会用上\n但是没有办法确切去知道它的有效性\n我们要知道完整的知识体系，然后抽取重要的知识点进行加固\n重点在于每一个知识点，看到就学一下，学不会不要紧，下次再看到时就加固学习（强扭的瓜不甜）\n系统化学习 + 随机性学习的结合\n\n前端技能模型\n领域知识\n不同的领域会学到不一样的知识\n实践中学习\n\n\n前端知识\n建立知识体系\n对知识体系掌握度是重点，而不是对知识体系的量级\n\n\n能力 —— 刻意练习\n编程能力\n架构能力\n工程能力\n\n\n\n\n\n\n\n\n\n\n\n\n前端技术不是武林秘籍，\n真正的能力是练出来的。\n学习法1. 整理法\n\n\n\n\n\n\n\n\n我们要追求的是一个完备性，而不是追求完整或者完美性。而我们重点是选择对的逻辑关系\n\n顺序关系\n记录一个体系的流程顺序关系\n\n\n组合关系\n纬度关系\n每一个维度单独看都是完整的东西\n多个维度去看是一个立体完整的东西\n\n\n分类关系\n按分类列出知识\n\n\n\n整理方式：\n\n先找线索，通过搜索，看手册，看文章搜集。先找到方向！\n找到多份资料\n进行对比，加强完整性\n\n2. 追溯法\n源头 —— 从源头开始建立知识基础，提升可信度\n最早出现的论文、杂志\n最初的实现案例\n\n\n标准和文档 —— 找权威性，但是不能盲目的看，要做好对比，保证准确性\nW3.org\nDeveloper.mozilla.org\nmsdn.microsoft.com\nDeveloper.apple.com\n\n\n大师 —— 可以去看他们对技术的定义，公信力更高\nTim Berners-Lee\nBrendan Eich\nBjarne Stoustrup\n\n\n\n\n\n\n\n\n\n\n\n\n通过这些方法建立知识基础，可以建立我们知识的准确性，可信度，公信力。同时在面试的时候可以提出你在那个权威的地方看到这个知识，也可以体现出你的专研和深挖能力。\n通过时间的的延伸，知识会不停的演变和被不同的人重新定义，所以我们要知道并对这个知识点有全面认知，从而在不同的领域或者场景下更加能抽丝破茧的方式去理解复杂，繁杂的知识。\n\n面试官怎么想？面试内容三要素\n深度范围\n覆盖面\n区分度\n\n面试过程\n打断\n打断意味着不感兴趣\n打断是一种提示\n如果面试官不要你，直接就让你说，然后叫你走就好了\n\n\n争论\n争论与压力面试 —— 保持自己优雅仪表和态度\n争论的技巧 —— 用追溯法找到可信度高来表达\n\n\n难题\n展现分析过程 —— 一边想一边说\n缩小规模 —— 化繁为简，把问题拆解\n\n\n\n问题类型\n项目型\n针对项目询问\n项目中实现了什么？\n遇到了什么难题，又是怎么解决的？\n主要考量我们在项目中体现出来的能力和思维\n\n\n知识型\n体现自己的知识体系\n会就会，不会就不会\n\n\n开放性问题\n通常是没有标准答案的问题\n设计方案的能力\n思维活跃程度\n管理型问题\n\n\n案例性问题\n设计、编程类\n给予场景并且给出解决方案\n用来考验我们平时的工作状态\n看的是过程不是结果（结果答的是正确的，过程不一定是对的，想看的就是你平时的工作状态，遇到问题时的状态）\n\n\n有趣的问题\n一般到达这个问题，基本面试已经过了\n关键不是你答什么，重点是体现自己思维的活跃度\n不一定要给到完美答案\n\n\n\n知识体系\n\n\n\n\n\n\n\n\n建立自己的知识体系，确保自己体系的完整性。在学习的过程中可以补充这个体系，达到很高的完美性。而且是可以在自己的心里有这么一个完整的知识体系，而不只是在我们电脑放着就好。\n\nQ &amp; A\n\n职业规划，我不知道往哪里去？\n每个人目标不一样\n有人可能喜欢深挖一个技术，有些人就想做一个伟大的项目\n所以你要去哪里取决于你的人生目标是什么\n但是没有什么选择是错的，重点是你想做什么，就找到能做你能做到的地方\n\n\n大厂会不会对 5-6 年工作经验有顾虑\n大厂对工作年龄不稳定\n但是如果你的工龄与你的能力不成对比，那肯定是有问题的\n\n\n在公司学不到东西，怎么办？\n学不到东西是你自己的问题\n要有 owner 意识，学不到东西就去找东西学\n我们不能把学不到东西推卸给公司或者环境\n\n\n我年龄大了，还有可能进入大厂？\n如果你觉得你的年龄无法进入 P6，那就继续提升到更高的级别\n总有一个级别是不在乎年龄的\n不论是年龄还是自己的学历，都不是我们应该关注的点\n更应该关注的是，我们有什么亮点可以让别人忽略我们的缺点\n所以要持续提升自己技术的认知，这些核心竞争力\n不要一直盯着自己不能改变的东西\n\n\n\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n\n\n\n\n\n\n\n\n\n公众号《技术银河》回复”前端知识体系”，可以获得这个系列文章的知识脑图！\n\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"frontend/frontend-study","date":"2020-08-07T14:55:14.000Z","categories_index":"FrontEnd","tags_index":"FrontEnd","author_index":"三钻"},{"id":"bf711582d656c68e5bb5b6ce2c895348","title":"44关学习CSS与CSS3基础「二」","content":"我有一段时间没有更新 FCC 前端教程了，这一周就继续写完 CSS 与 CSS3 基础的教程。最近工作和生活都比较繁忙所以文章更新也受到了一定的影响。不过技术文章写作再忙也不会放弃的。我会继续努力坚持着一周一篇文章的进度，继续为大家带来我学习到的知识。让我们一起继续终身学习吧！\n这一篇文章是上一篇《44 关学习 CSS 与 CSS3 基础「一」》的第二部分，一共闯了 44 关。废话少说，让我们一起来闯关吧！\n\n「第二十三关」使用属性选择器改变元素属性\n\n\n\n\n\n\n\n\n关卡名：Use Attribute Selectors to Style Elements\n知识点\n之前我们使用了id和class属性选择器给特定的元素改变样式；\n这种方式叫做ID和CLASS选择器；\n除了这两种 CSS 选择器之外，还有其他选择让我们选择一组自定义的元素来改变样式的；\n我们把CatPhotoApp拿出来练习其他 CSS 选择器；\n在这个关卡中我们将使用[attr=value]（属性&#x3D;值）这种属性选择来给我们的 checkboxes （复选框）添加样式；\n这个选择器匹配特殊的属性值，然后对这个属性做出样式的改变；\n\n比如一下例子，所有type属性值为radio的元素加入 margin（外边距）做出改变：\n[type&#x3D;&#39;radio&#39;] &#123;\n  margin: 20px 0px 20px 0px;\n&#125;\n\n过关目标\n使用属性选择器，选中所有type属性为复选框的元素；\n并且给与这些元素 10px 的顶部外边距和 15px 的底部外边距；\n\n过关条件\ntype属性选择器必须用来选中所有复选框；\n所有复选框的顶部 margin 必须是 10px；\n所有复选框的底部 margin 必须是 15px；\n\n学会了什么？这关卡主要教会我们：\n\n使用属性选择器来改变元素的样式；\n\n\n答案\n\n「第二十四关」绝对与相对单位\n\n\n\n\n\n\n\n\n关卡名：Understand Absolute versus Relative Units\n知识点\n之前所有的关卡中，我们都是给元素的 margin 和 padding 赋予“像素（pixels&#x2F;px）”单位；\n像素是一个浏览器使用的长度单位，这个单位会告诉浏览器给予一个元素多少大小和空间；\n在 CSS 当中除了 px 单位之外，还可以使用其他可选的单位；\n可用单位主要分为两种 绝对单位（absolute） 和 相对单位（relative）\n绝对单位有 in（英寸） 和 mm （厘米），绝对长度单位近似于屏幕上的实际测量值，但是根据屏幕的分辨率会有一些差异；\n相对单位有 em 或者 rem, 两者分别都是相对单位，都会根据一个相对的元素转换自己的大小；\n\n\n\n那么 em 和 rem 有什么区别呢？\n\n\n\n\n\n\n\n\n\nEM 是相对长度，它是相对于当前元素的字体大小，如果当前元素没有设置字体大小就会一直往父级找，然后相对于父级字体大小来转换。\nEM 特性：\n\nem 的值并不是固定的；\nem 会基层父级元素的字体大小；\n如果父级也是使用了 em 长度单位，那当前元素的 em 换算就会使用父级 em 换算后的结果进行换算。（比如父级使用了 1.2em，换算后是 12px，那当前元素用的 1em 就是 12px，但是我们想要的是 1em &#x3D; 10px，这种情况用 em 就会出现大小错误。）\n\n\n\n\n\n\n\n\n\n\nREM 是 CSS3 新增的一个相对单位，它是 root em 的缩写，顾名思义就是根 em。\nREM 特性：\n\n它与 EM 不一样的是，因为是”根”em，所以它永远都是相对于 HTML 根元素的字体大小；\n与 EM 相同的就是值并不是固定的，都是相对一个元素的字体大小；\n因为 REM 的特性是相对于 HTML 根元素，所以只要改变根元素的字体大小，就会对所有 REM 单位的元素发生大小变化；\n除了 IE8 及更早版本的浏览器内核，所有浏览器均支持 REM；\n对于不支持的浏览器来说，我们就需要加入一个 px 单位的 font-size 属性，如果浏览器发现无法使用 rem 即会使用 px 单位的 font-size 值；\n这个单位可谓集合相对和绝对单位的优点与一身，所以此单位引起了广泛的使用，特别是在做移动端网页时，用于响应不同手机屏幕大小和分辨率大小；\n\n这些相对单位的使用会在《响应式页面开发》的关卡中详细介绍使用场景。\n过关目标\n给拥有red-box类的元素加入 padding 属性，值为 1.5em；\n\n过关条件\nred-box类元素必须含有 padding 属性；\nred-box类元素的padding属性值必须为1.5em；\n\n学会了什么？这关卡主要教会我们：\n\n认识“像素（px）”以外的大小单位；\n认识什么是绝对与相对大小单位，并且分别拥有那些单位可以使用；\n如何使用em，这种相对单位；\n\n\n答案\n\n「第二十五关」HTML 主体属性样式\n\n\n\n\n\n\n\n\n关卡名：Style the HTML Body Element\n知识点\n这一关开始，我们重新开始一个页面，并且一起来学习CSS 继承；\n首先每一个 HTML 页面都会有一个body元素；\n这一关我们用background-color属性给body元素一个背景颜色为black；\n如果这时页面变成了黑色，证明我们页面中是有body元素的；\n\n以下例子演示如何给body应用一个黑色背景的代码：\nbody &#123;\n  background-color: black;\n&#125;\n\n过关目标\n用 CSS 把页面中body元素的背景色变成黑色；\n从而证明我们页面中拥有一个body元素；\n\n过关条件\nbody元素必须拥有background-color属性，并且值为black；\nCSS 的格式必须合格并且遵循规范写法；\nCSS 的规则写法必须用分号结束；\n\n学会了什么？这关卡主要教会我们：\n\n使用背景颜色；\n证明了页面中必定会有一个body元素；\n\n\n答案\n\n「第二十六关」从主体元素中继承样式\n\n\n\n\n\n\n\n\n关卡名：Inherit Styles from the Body Element\n知识点\n上一关我们证明了每一个 HTML 页面中都必定会有body元素；\n而且body元素也是可以使用 CSS 给它定制样式的；\n\n\n\n\n\n\n\n\n\n\n记住：body元素与其他 HTML 中的元素一样，都是可以使用 CSS 给予样式控制的。不同的就是，body元素中的样式会被 HTML 中其他元素默认继承。意思就是说，任何在 body 中的样式都会携带到其他元素中，如果 body 中给予了背景颜色是黑色，那我们加入一个div元素，默认也是黑色背景。\n过关目标\n首先，创建一个h1元素，内容填入文字 “Hello World”；\n接下来我们让这个页面下所有元素的文字颜色都改为绿色，要达到这样的效果只需要在body元素中加入color: green即可；\n最后给body元素定义字体为monospace，我们只需要在body样式中加入font-family: monospace属性值即可；\n\n过关条件\n创建一个h1元素；\nh1元素内容是 Hello World；\nh1元素有关闭标签；\nbody元素应该有color属性，并且值为green；\nbody元素应该有font-family属性，并且值为monospace；\nh1元素的字体应该继承body元素的字体定义；\nh1元素的字体颜色应该继承body元素的字体颜色；\n\n学会了什么？这关卡主要教会我们：\n\n学会继承主体（body）元素的样式；\n\n\n答案\n\n「第二十七关」CSS 样式继承中样式优先级\n\n\n\n\n\n\n\n\n关卡名：Prioritize One Style Over Another\n知识点\n有些时候 HTML 元素会同时存在多个样式，并且产生冲突的可能性；\n举例，我们的h1元素无法同时拥有绿色和粉红色字体颜色的属性；\n让我们来看看，如果我们给一个元素一个类名，并且赋予这个类红粉色的字体颜色；\n这个时候会不会覆盖body元素中的color: greenCSS 属性；\n\n过关目标\n创建一个 CSS 类，名为pink-text；\n然后给pink-text加入字体颜色color: pink；\n把pink-text类赋予h1元素；\n\n过关条件\nh1元素必须拥有pink-text类；\n&lt;style&gt;标签中必须含有pink-text类样式，并且含有改变字体颜色的属性；\nh1元素的字体应该是粉红色（pink）；\n\n学会了什么？这关卡主要教会我们：\n\n如何在 CSS 样式继承中覆盖body元素的样式；\n\n\n答案\n\n「第二十八关」覆盖后续 CSS 中的样式\n\n\n\n\n\n\n\n\n关卡名：Override Styles in Subsequent CSS\n知识点\n上一关我们用pink-text类覆盖了body元素的 CSS 样式；\n这里证明了 CSS 类会覆盖body元素的 CSS；\n所以下一个问题就是，我们是否可以覆盖pink-text类的样式呢？\n一个 HTML 元素是可以叠加多个 CSS 类的，给一个元素多个 CSS 类只需要在多个类名之间加入空格即可；\n\n&lt;div class&#x3D;&quot;class1 class2&quot;&gt;&lt;&#x2F;div&gt;\n\n\n\n\n\n\n\n\n\n\n注意：元素中多个 CSS 类的摆放顺序是不会影响 CSS 样式的权重的。真正决定 CSS 样式的权重的是在 CSS 样式表中的顺序，CSS 样式表的样式规则会从上往下写，越是在后面的权重越高。因为.blue-text的样式在.pink-text的后面，所以最后.blue-text的样式会覆盖.pink-text。\n过关目标\n创建一个新的 CSS 类名为blue-text，然后赋予这个类蓝色字体样式；\nblue-text类在样式表中必须放在pink-text之后；\n在拥有pink-text类的h1元素上叠加blue-text类；\n\n过关条件\nh1元素中需要有pink-text类；\nh1元素中需要有blue-text类；\nblue-text和pink-text都需要赋予给h1元素；\nh1元素中的字体应该是蓝色的；\n\n学会了什么？这关卡主要教会我们：\n\n如何覆盖 CSS 样式，和使用 CSS 权重；\n\n\n答案\n\n「第二十九关」通过使用 ID 属性覆盖类属性样式\n\n\n\n\n\n\n\n\n关卡名：Override Class Declarations by Styling ID Attributes\n知识点\n上一关我们知道了 CSS 样式表是从上到下阅读的，越是后面的权重就越高，就会覆盖前面声明的样式属性；\n所以就算我们在h1元素中，把pink-text放在blue-text的前面，blue-text类中的 CSS 属性权重也是更大，会覆盖pink-text的 CSS 属性；\n但是 CSS 属性权重并不止于此，还有比这个权重更高的；\n这一关我们给h1元素添加一个ID名为orange-text，然后在 CSS 样式表中给这个 ID 橙色字体颜色的样式，从而覆盖掉blue-text类和pink-text类的样式；\n\n给一个元素加入 ID 属性需要使用以下写法：\n&lt;h1 id&#x3D;&quot;orange-text&quot;&gt;&lt;&#x2F;h1&gt;\n\n在 CSS 样式表中定义 ID 属性需要使用以下写法：\n#brown-text &#123;\n  color: brown;\n&#125;\n\n过关目标\n给h1元素一个 ID 属性，值为orange-text；\n保留blue-text类和pink-text类在h1元素中；\n创建orange-text的 CSS 声明，并且给予color: orange的属性；\n\n过关条件\nh1元素需要有一个pink-text类；\nh1元素需要有一个blue-text类；\nh1元素需要有一个orange-textID；\n必须只有一个h1元素；\norange-textID 需要声明好 CSS 的属性；\nh1元素不应该有任何style属性；\nh1元素中的字体应该是橙色的；\n\n学会了什么？这关卡主要教会我们：\n\n使用 ID 属性的样式来覆盖类样式；\n\n\n答案\n\n「第三十关」使用行内样式覆盖类样式\n\n\n\n\n\n\n\n\n关卡名：Override Class Declarations with Inline Styles\n知识点\n上一关我们见证了 ID 属性的样式声明在权重中是高于类属性的样式声明；\n就算在 CSS 样式表中是写在最上面的，也会比其他类属性声明的 CSS 属性要大；\n但是还有一个大佬是被所有这些都权重更高的，还记得行内样式吗？就是在元素中定义的style属性；\n\n不记得行内样式的写法的同学，可以看看以下例子：\n&lt;h1 style&#x3D;&quot;color: green&quot;&gt;&lt;&#x2F;h1&gt;\n\n过关目标\n使用行内样式，让h1元素中的字体变成白色（color: white）；\n保留h1元素中的blue-text类，pink-text类和orange-textID 属性；\n\n过关条件\nh1元素需要有一个pink-text类；\nh1元素需要有一个blue-text类；\nh1元素需要有一个orange-textID；\nh1元素需要有一个style属性；\nh1元素中的字体是白色的；\n\n学会了什么？这关卡主要教会我们：\n\n使用行内样式覆盖元素的样式；\n\n\n答案\n\n「第三十一关」用 Important 覆盖所有样式\n\n\n\n\n\n\n\n\n关卡名：Override All Other Styles by using Important\n知识点\n在上一个关卡中发现，行内样式是会覆盖所有类型的样式声明；\n但是行内样式并不是最大的，还有最后一个比行内样式权重还要高的；\n对那就是使用!important，顾名思义就是“重要”的意识，也是表达着这个样式有最高优先级；\n在我们使用它之前，先来了解一下为什么我们需要强制覆盖 CSS 样式；\n\n\n\n\n\n\n\n\n\n\n为何要强制覆盖 CSS 样式？又有什么时候需要我们这么做呢？\n在很多情况下，我们需要使用到 CSS 库，甚至是某 UI 框架。因为是使用别的开发者写好的样式，自然就有可能我们些的样式是被原有库或则框架的样式所覆盖了。所以当我们需要保证我们编写的 CSS 拥有最高优先级，并且绝对有效，这个时候我们就可以使用 !important。\n\n让我们回到最初的pink-text类样式声明，一开始我们使用了写在后面的blue-text类覆盖了它的样式；\n接下来是使用了orange-textID 属性覆盖它；\n最后使用了行内样式覆盖；\n\n所以样式声明的优先级顺序就是：\n\n\n\n\n\n\n\n\n\nCSS 类声明顺序 &lt; ID 属性样式 &lt; 行内样式\n过关目标\n让我们在pink-text类的颜色声明后面加入!important；\n用这个给pink-text类的样式声明得到最大优先级；\n\n!important 的使用例子：\n.brown-text &#123;\n  color: brown !important;\n&#125;\n\n过关条件\nh1元素需要有一个pink-text类；\nh1元素需要有一个blue-text类；\nh1元素需要有一个orange-textID；\nh1元素中应该有行内属性为color: white；\npink-text类样式声明中应该有 !important结尾；\nh1元素中的字体应该是粉红色；\n\n学会了什么？这关卡主要教会我们：\n\n如何使用最高优先级的!important；\n\n\n答案\n\n「第三十二关」使用 Hex 代码指定特定颜色\n\n\n\n\n\n\n\n\n关卡名：Use Hex Code for Specific Colors\n知识点\n你们知道在 CSS 中还有其他方式可以用来指定颜色的吗？\n其中一种方式就是使用 十六进制（Hexadecimal）或者叫 Hex 颜色代码；\n\n\n\n\n\n\n\n\n\n\n什么是十六进制？\n学过计算机的同学应该都知道，通常用小数，或者以 10 为底的数，那就是用数字 0 到 9。十六进制，顾名思义就是用 16 为底的数。也就是说需要使用 16 个不同的符号。符号 0 到 9 用来代表数字中的零到久，然后 A，B，C，D，E，F 就是第十到十五的符号。从 0 到 9，A 到 F 一共就有 16 个符号组成十六进制的代码。\n\n在 CSS 中，我们可以使用 6 个十六进制的数值来代表颜色；\n每两个都是代表着红（R），绿（G），蓝（B）三种色系。\n拿#000000的黑色作为例子，如果红，绿，蓝都调到最低，自然就是没有颜色，那就是黑色了；\n可以把这三种颜色当成三个颜色的灯泡，然后十六进制是用来控制他们的亮度，数值越高就越亮，0 为最低，也就是灯会关掉，所以所有#000000就等同于三盏灯都关掉，自然是黑色了。如果三盏灯都调到最亮，那就会是白色了，也就是我们用的#FFFFFF；\n\n颜色码使用例子如下：\nbody &#123;\n  color: #000000;\n&#125;\n\n过关目标\n替换body元素中的black属性值为#000000；\n\n过关条件\nbody元素的背景颜色应该是黑色；\n需要替换black，并且使用 Hex 颜色码；\n\n学会了什么？这关卡主要教会我们：\n\n什么是 Hex 颜色码；\n什么是十六进制；\n如何使用 Hex 颜色码；\n\n\n答案\n\n「第三十三关」使用十六进制代码来混合颜色\n\n\n\n\n\n\n\n\n关卡名：Use Hex Code to Mix Colors\n知识点\n我们来回顾一下上一关的知识，Hex 颜色代码中有 6 位十六进制的数值，每两位都是分别代表着红（R），绿（G），蓝（B）三种色系；\n我们可以随意调配这三种纯颜色的亮度来混合出超过 1600 万种颜色；\n比如说橙色，就是纯红色，加一点绿色，然后没有蓝色，对应 Hex 颜色码就是#FFA500；\n数值0在 Hex 码中是最低的数值，等同于把这个颜色调到没有为止；\n数值F就是 Hex 码中最大值，等同于把这个颜色调到最亮值；\n\n过关目标\n转换一下颜色成 Hex 颜色码：\n\n\n\n\n颜色\nHex 码\n\n\n\nDodger Blue\n#1E90FF\n\n\nGreen\n#00FF00\n\n\nOrange\n#FFA500\n\n\nRed\n#FF0000\n\n\n过关条件\nh1元素的字体I am red!需要是红色；\n红色（Red）字体颜色属性应该使用hex 码替换颜色值red;\nh1元素的字体I am green!需要是绿色；\n绿色（Green）字体颜色属性应该使用hex 码替换颜色值green;\nh1元素的字体I am dodger blue!需要是宝蓝色；\n宝蓝色（Dodger Blue）字体颜色属性应该使用hex 码替换颜色值dodgerblue;\nh1元素的字体I am orange!需要是橙色；\n橙色（Orange）字体颜色属性应该使用hex 码替换颜色值orange;\n\n学会了什么？这关卡主要教会我们：\n\n使用 Hex 颜色码替换颜色名词的属性值；\n\n\n答案\n\n「第三十四关」使用 Hex 颜色码缩写\n\n\n\n\n\n\n\n\n关卡名：Use Abbreviated Hex Code\n知识点\n超过 1600 万种颜色码的可能性，让许多人感到不知所措；\n而且很难记住十六进制代码，幸运的是你可以用他们的缩写版；\n比如红色的 Hex 颜色码为 #FF0000 可以被缩写为 #F00，这个缩写版只给红色一个数值，绿色一个数值和蓝色一个数值；\n但是这样的缩写版，就会让我们的颜色总可能数讲到 4000 种；\n就算使用这种缩写版，浏览器会设别 #F00 和 #FF0000 为同一个颜色；\n\n过关目标\n用以下缩写版的 Hex 颜色码来更换对应的 CSS 类中的颜色值：\n\n\n\n\n颜色\n缩写 Hex 码\n\n\n\nCyan\n#0FF\n\n\nGreen\n#0F0\n\n\nRed\n#F00\n\n\nFuchsia\n#F0F\n\n\n过关条件\nh1元素的字体I am red!需要是红色；\n红色（Red）字体颜色属性应该使用缩写hex 码替换颜色值#FF0000;\nh1元素的字体I am green!需要是绿色；\n绿色（Green）字体颜色属性应该使用缩写hex 码替换颜色值#00FF00;\nh1元素的字体I am cyan!需要是宝青色；\n青色（Cyan）字体颜色属性应该使用缩写hex 码替换颜色值#00FFFF;\nh1元素的字体I am fuchsia!需要是樱红色；\n樱红色（Fuchsia）字体颜色属性应该使用缩写hex 码替换颜色值#FF00FF;\n\n学会了什么？这关卡主要教会我们：\n\n使用缩写版的 Hex 颜色码；\n\n\n答案\n\n「第三十五关」使用 RGB 值改变元素颜色\n\n\n\n\n\n\n\n\n关卡名：Use RGB values to Color Elements\n知识点\n除了 Hex 颜色码，还有其他方法可以用来给元素赋予颜色，那就是使用RGB值；\n黑色的 RGB 值是：rgb(0, 0, 0)；\n白色的 RGB 值是：rgb(255, 255, 255)；\n与十六进制一样的原理，都是使用调整红（R），绿（G），蓝（B）三种色系的亮度来混合出 1600 万种颜色；\n十六进制使用的是 0-9 和 A-F，而RGB使用的是 0 到 255，如果我们计算一下，其实 16 x 16 就是 256，而计算机都是从 0 开始，所以 $256-1&#x3D;255$ ；\n所以RGB和十六进制都是拥有一样的颜色种数，并且都是调整三种色系来变换颜色的；\n\n以下是把背景颜色换成橙色的 CSS 代码：\nbody &#123;\n  background-color: rgb(255, 165, 0);\n&#125;\n\n过关目标\n把body元素的背景颜色换成RGB中的黑色值：rgb(0, 0, 0)；\n\n过关条件\nh1元素的字体I am red!需要是红色；\n红色（Red）字体颜色属性应该使用RGB值替换 Hex 颜色值;\nh1元素的字体I am orchid!需要是淡紫色；\n淡紫色（Orchid）字体颜色属性应该使用RGB值替换 Hex 颜色值;\nh1元素的字体I am blue!需要是蓝色；\n蓝色（Blue）字体颜色属性应该使用RGB替换 Hex 颜色值;\nh1元素的字体I am sienna!需要是赭色；\n赭色（Sienna）字体颜色属性应该使用RGB替换 Hex 颜色值;\n\n学会了什么？这关卡主要教会我们：\n\n使用 RGB 值改变元素颜色；\n\n\n答案\n\n「第三十六关」用 RGB 来混合颜色\n\n\n\n\n\n\n\n\n关卡名：Change the Color of Text\n知识点\n与 Hex 颜色代码一样，我们可以用不同的RGB值来混合出各种颜色；\n\n过关目标\n使用以下RGB值来替换 CSS 中的 Hex 颜色代码：\n\n\n\n\n颜色\nRGB 值\n\n\n\nBlue\nrgba(0, 0, 255)\n\n\nRed\nrgb(255, 0 , 0)\n\n\nOrchid\nrgb(218, 112, 214)\n\n\nSienna\nrgb(160, 82, 45)\n\n\n过关条件\nh2元素中需要有style属性；\nh2元素的color样式属性应该赋予red这个值；\nstyle属性值里的样式属性应该以;符号结束；\n\n学会了什么？这关卡主要教会我们：\n\n如何使用RGB混合颜色;\n\n\n答案\n\n「第三十七关」使用 CSS 变量同时改变多个元素样式\n\n\n\n\n\n\n\n\n关卡名：Use CSS Variables to change several elements at once\n知识点\nCSS 变量是一种通过只改变一个值来一次性改变多个 CSS 样式属性的强大方法；\n遵循下面的目标，看看仅改变三个值来改变多个元素的样式；\n\n过关目标\n在penguin类中，改变一下内容：\n改变--penguin-skin的black为gray；\n改变--penguin-belly的gray为white；\n改变--penguin-beak的yellow为orange；\n\n\n必须在/* Only change code below this line */ 和 /* Only change code above this line */ 这两个备注之间修改代码；\n\n过关条件\npenguin类中的--penguin-skinCSS 变量的值改为gray；\npenguin类中的--penguin-bellyCSS 变量的值改为white；\npenguin类中的--penguin-beakCSS 变量的值改为orange；\n\n学会了什么？这关卡主要教会我们：\n\n如何使用 CSS 变量批量改变多个元素样式；\n\n\n答案\n\n「第三十八关」创建自定义 CSS 变量\n\n\n\n\n\n\n\n\n关卡名：Create a custom CSS Variable\n知识点\n创建一个 CSS 变量，我们只需要在变量名前面加上两个“横杠（-）”即可；\n编写语法如下：\n\n--penguin-skin： gray;\n\n\n以上代码会创建一个变量，名为--penguin-skin，并且赋予了这个变量的值为gray；\n现在我们就可以在 CSS 样式表中任何的地方使用这个变量；\n\n过关目标\n在penguin类中，创建一个变量名--penguin-skin；\n并且给予这个变量一个值为gray；\n必须在/* Only change code below this line */ 和 /* Only change code above this line */ 这两个备注之间编写代码；\n\n过关条件\npenguin类中需要含有一个--penguin-skin变量，并且变量值为gray；\n\n学会了什么？这关卡主要教会我们：\n\n如何编写 CSS 变量；\n\n\n答案\n\n「第三十九关」使用自定义 CSS 变量\n\n\n\n\n\n\n\n\n关卡名：Use a custom CSS Variable\n知识点\n上一关我们创建了一个自定义的 CSS 变量，这一关我们来看看是怎么使用的；\n创建了一个 CSS 变量后，这个变量的名字可以在 CSS 样式属性中使用，只要我们关联这个变量名即可；\n在代码中的关联写法如下：\n\nbackground： var(--penguin-skin);\n\n\n以上代码改变了background属性的值，这个值我们用了 CSS 变量；\nCSS 的变量的值，就是我们上一关定义的gray，这个值会被关联过来；\n\n\n\n\n\n\n\n\n\n\n注意：使用的变量名字必须是和定义的变量名完全一致，要不就不会生效！\n过关目标\n把一下几个 CSS 类中的background属性的值都替换成--penguin-skinCSS 变量：\npenguin-top;\npenguin-bottom;\nright-hand;\nleft-hand;\n\n\n\n过关条件\npenguin-topCSS 类中的background属性值需要改为使用--penguin-skinCSS 变量；\npenguin-bottomCSS 类中的background属性值需要改为使用--penguin-skinCSS 变量；\nright-handCSS 类中的background属性值需要改为使用--penguin-skinCSS 变量；\nleft-handCSS 类中的background属性值需要改为使用--penguin-skinCSS 变量；\n\n学会了什么？这关卡主要教会我们：\n\n如何使用自定义 CSS 变量；\n\n\n答案\n\n「第四十关」给 CSS 变量加上回退值\n\n\n\n\n\n\n\n\n关卡名：Attach a Fallback value to a CSS Variable\n知识点\n当我们使用 CSS 变量做为属性的值，我们可以赋予这个变量一个回退值；\n所谓的回退值，就是当这个变量无效或者无法取得值是，就会使用回退的值；\n\n\n\n\n\n\n\n\n\n\n注意：这个回退值并不是用来提高浏览器兼容的，在 IE 浏览器下回退值也不会生效的。所以这个回退值只是用于当变量无法获取到值时，浏览器有一个可回退的值可用，并且可以保证有效显示。\n如下是如何设置回退值的例子：\nbackground: var(--penguin-skin, black);\n\n\n上面的例子中，如果--penguin-skin变量无法获取到值，就会自动回退使用black做为背景颜色属性的值；\n\n过关目标\n同学们应该都注意到，右边的企鹅的身体部分的颜色不见了；\n这个是因为.penguin-top类和.penguin-bottom类中的背景颜色属性的值中的变量名拼写错误了，所以导致变量无法取到变量所定义的值；\n在不修正这个变量名拼写错误的情况下，我们给.penguin-top类和.penguin-bottom类中的background属性的变量值加上回退颜色：black；\n\n过关条件\n在penguin-top类中的background属性的变量值加入回退值black；\n在penguin-bottom类中的background属性的变量值加入回退值black；\n\n学会了什么？这关卡主要教会我们：\n\n如何给 CSS 变量加上可回退的值；\n\n\n答案\n\n「第四十一关」CSS 变量的浏览器兼容\n\n\n\n\n\n\n\n\n关卡名：Improve Compatibility with Browser Fallbacks\n知识点\n当我们使用 CSS 时，很有可能我们会遇到浏览器兼容问题；\n如果遇到需要兼容不支持 CSS 变量的浏览器时，我们要提供一个回退的属性给浏览器读取；\n当浏览器解析页面上的 CSS 时，它会忽略无法识别的 CSS 属性；\n比如此时我们有一个背景颜色属性值使用了 CSS 变量，Internet Explore（简称 IE）会忽略这个 IE 不支持的背景颜色，因为 IE 不支持使用 CSS 变量。这种情况下 IE 浏览器只会寻找其他它认识的背景属性，如果它找不到就会回退到浏览器默认的背景颜色，当然这样不是我们想要的，并且可能默认的颜色和我们理想的效果有很大的出入；\n按照以上的逻辑，如果我们需要给某一个属性一个兼容的回退值，我们只需要在不兼容的属性上面添加一个可兼容的属性即可；\n这样当浏览器遇到一个属性它无法识别，就会往上找可用的属性，这样就可以做到浏览器兼容了；\n\n过关目标\n在代码中我们可以看到，在.red-box类样式中的background属性值使用了--red-colorCSS 变量；\n我们在这个属性的上方加入background: red，从而兼容其他不支持 CSS 变量的浏览器；\n\n过关条件\n.red-box类中的background属性上面添加一个background: red的兼容属性；\n\n学会了什么？这关卡主要教会我们：\n\n如果做到浏览器兼容；\n\n\n答案\n\n「第四十二关」继承 CSS 变量\n\n\n\n\n\n\n\n\n关卡名：Inherit CSS Variables\n知识点\n当我们创建一个 CSS 变量，我们是可以在创建的 CSS 选择器中使用；\n如果我现在把--penguin-skin变量下载.penguin类选择器中，那就能.penguin中可以调用这个 CSS 变量；\n同时也可以在.penguin的所有子节点中使用，除外都是无法调用的；\n\n\n\n\n\n\n\n\n\n\n那些才是子节点呢？\n比如现在我们有一段这样的 HTML：&lt;div class=&quot;foo&quot;&gt;&lt;span class=&quot;bar&quot;/&gt;&lt;/div&gt;\n这段 HTML 中bar就是foo的子节点，他们彼此有继承关系。\n\n为了可以良好利用继承关系，CSS 变量一般都会放入:root元素；\n:root是一个伪类（pseudo-class）选择器，它会直接匹配 HTML 文档（document）中的根元素，那就是html元素；\n在:root伪类中添加我们的 CSS 变量，遵循继承关系这些变量全局都可以使用了；\n\n过关目标\n在:root伪类选择器中声明一个--penguin-belly变量，并且给予pink属性值；\n然后我们就可以看到所有使用到这个变量的地方，都会可以继承并且生效；\n\n过关条件\n--penguin-belly变量需要在:root伪类选择器中声明，并且属性值是pink；\n\n学会了什么？这关卡主要教会我们：\n\n如何使用 CSS 继承关系来使用 CSS 变量；\n\n\n答案\n\n「第四十三关」在特定地方改变 CSS 变量\n\n\n\n\n\n\n\n\n关卡名：Change a variable for a specific area\n知识点\n当我们在:root伪类选择器中定义 CSS 变量，整个页面使用到这个变量的地方都会被影响；\n但是如果我们想再某一元素中重新定义这个变量，我们只需要在这个选择器中重新定义即可；\n\n过关目标\n在penguin类中改变--penguin-belly属性值为white；\n\n过关条件\npenguin类中加入--penguin-belly属性，并且值赋予white；\n\n学会了什么？这关卡主要教会我们：\n\n如何在特定地方改变 CSS 变量值；\n\n\n答案\n\n「第四十四关」使用媒体查询来修改变量值\n\n\n\n\n\n\n\n\n关卡名：Use a media query to change a variable\n知识点\nCSS 变量可以简化媒体查询的使用方式；\n比如当我们屏幕小于或大于媒体查询的范围时，我们可以改变 CSS 变量的值；\n这时候所有使用了这个变量的属性就会跟着改变；\n\n过关目标\n在:root选择器中的media query内，重新定义--penguin-size的值为200px；\n同时也重新定义--penguin-skin变量的值为black;\n最后改变预览区域的宽度，看看又什么变化；\n\n过关条件\n:root中需要重新定义--penguin-size的值为200px；\n:root中需要重新定义--penguin-skin的值为black；\n\n学会了什么？这关卡主要教会我们：\n\n在媒体查询中使用 CSS 变量重定义，从而达到在特定屏幕大小时，变量值发生变化；\n\n\n答案\n\n「总结」\n这一期我们终于完成了 CSS 与 CSS3 基础的所有关卡，个人觉得这个 FCC 集训营的关卡中的 CSS 知识还是比较全面的。在编写这些关卡的过程中确实重温了不少前端基础，也是收益匪浅。在跟着我的教程一起闯关的同学们，也希望你们也有所收获。\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等和你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n系列阅读\n🔥《勇闯 28 个关卡学会 HTML 与 HTML5 基础》 —— 这周我们一起闯过了 22 关，下一期我们会一起把剩余的 22 关完成。学习是一种像爬山一样的过程，要经历过漫长的上坡路，一步一个脚印。“路漫漫其修远兮，吾将上下而求索。”， 在追寻知识的道路上，前方的道路还很漫长，但我们将百折不挠，不遗余力地，上天下地的去追求和探索。让我们继续坚持学习，终身学习成长。在大前端的时代爬到技术的巅峰，做一个有深度的技术人员。\n🔥《44 关学习 CSS 与 CSS3 基础「一」》 —— 这一期我们一起攻破前端第二大知识点《CSS 基础入门》。因为这一课一共有 44 关，我把文章分成两期更新。\n\n推荐系列小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"frontend/fcc-css3-basics-2","date":"2020-07-11T16:19:24.000Z","categories_index":"FrontEnd","tags_index":"HTML&CSS,Free Code Camp","author_index":"三钻"},{"id":"1781b683e9507c36c168e35402e3a5a4","title":"力扣实战之移动零、盛最多的水、爬楼梯","content":"练题法则5-10 分钟读题与思考\n\n不要纠结没有思路就直接看题解；\n不要死磕觉得自己很失败，怎么我们就想不出来；\n基本上这些算法题，让我们自己想出来是不可能的；\n拿跳表的来说，如果我们能从 0-1 把它想出来，那我们就可以拿到图灵奖了；\n所以记住！无思路就直接看题解，无思路就直接看题解，无思路就直接看题解！\n我们只需要知道并且能运用即可！\n\n有思路\n\n自己开始写代码，没有，就马上看题解！默写背题，熟练\n做完题目后，我们需要记住这种题的思路和有N 种解决办法；\n重复再重复的默写，直到自己有深刻的影响；\n\n最后开始自己写（闭卷）\n\n到了这里如果我们还需要看别人代码，那就要回去背题；\n能到达这个阶段基本这种题你已经开始熟悉的，接下来就是反复练习；\n\n在哪里练题？那肯定是力扣了！没有账号的小伙伴，马上就去注册个账号开始日复一日的练习吧！～\n\n283 题 - 移动零\n\n\n\n\n\n\n\n\n283. 移动零｜难度：简单\n题目讲解给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n示例：\n输入: [0,1,0,3,12]\n输出: [1,3,12,0,0]\n\n说明:\n\n必须在原数组上操作，不能拷贝额外的数组。\n尽量减少操作次数。\n\n这里需要注意的重点：\n\n所有 0 移动到数组的末尾；\n保持非零元素的相对顺序；\n必须在原数组上操作，不能拷贝额外的数组；\n\n解题思路\n\n\n\n\n\n\n\n\n思考题解时，使用MECE 原则 — 每一个思路都相对独立的思维，然后想到完全穷尽。首先不要管附加条件，先把有可能解决这个问题的思路都想出来，再评估哪一个办法是最优解。面试的时候也是一样，说出你所有可以想到的思路，然后分别讲出各自的优点与缺点，最后提出最优答案。\n\n统计 0 的个数\n循环数组找到 0 的位置，遇到 0 就为 0 的个数加一；\n遇到不是 0 的时候，把非 0 的元素值与 0 的元素交换即可；\n\n\n开新数组\n给一个指针i从数组的头部开始递增；\n给一个指针j从数组的尾部开始递减（也就是原数组的总长度）；\n遇到零就往j指针的位置放，然后j--；\n遇到非零就往i指针的位置放，然后i++；\n缺点：内存使用会高；\n不符合条件：必须在原数组上操作，所以可以实现但是不符合条件；\n\n\n双指针交换\n给两个指针i和j，并且默认都从 0 开始；\ni指向的是当前位置；\nj指针会一直移动，直到找到一个非零元素，然后与i位置的值交换；\n如果j的位置与i不是一致的话，就可以给j的值换成 0；\n\n\n双指针替换后清零\n这个与第三种方法一致，也是双指针；\n唯一的区别是不在i指针扫描的时候替换零；\n而是在替换完毕所有非零元素后，把剩余的全部位数都改为 0；\n\n\n\n解题代码「方法一」 - 统计 0 的个数：\n\n时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次\n空间复杂度：$O(1)$ - 只对原数组进行替换操作\n\n&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;void&#125; Do not return anything, modify nums in-place instead.\n *&#x2F;\nvar moveZeroes &#x3D; function (nums) &#123;\n  let zeroCount &#x3D; 0\n  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n    if (nums[i] &#x3D;&#x3D; 0) &#123;\n      zeroCount +&#x3D; 1\n    &#125; else if (zeroCount &gt; 0) &#123;\n      nums[i - zeroCount] &#x3D; nums[i]\n      nums[i] &#x3D; 0\n    &#125;\n  &#125;\n&#125;\n\n「方法二」 - 双指针交换：\n\n\n时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次\n空间复杂度：$O(1)$ - 只对原数组进行替换操作\n\n&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;void&#125; Do not return anything, modify nums in-place instead.\n *&#x2F;\nvar moveZeroes &#x3D; function (nums) &#123;\n  let j &#x3D; 0\n  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n    if (nums[i] !&#x3D;&#x3D; 0) &#123;\n      nums[j] &#x3D; nums[i]\n      if (j !&#x3D;&#x3D; i) &#123;\n        nums[i] &#x3D; 0\n      &#125;\n      j++\n    &#125;\n  &#125;\n&#125;\n\n「方法三」 - 双指针替换后清零：\n\n\n时间复杂度：$O(n)$ - N 个元素就需要遍历 N 次，加上最后清零是走了n减非零的个数，那就是O(n+n-i)，总的来说还是O(n)\n空间复杂度：$O(1)$ - 只对原数组进行替换操作\n\n&#x2F;**\n * @param &#123;number[]&#125; nums\n * @return &#123;void&#125; Do not return anything, modify nums in-place instead.\n *&#x2F;\nvar moveZeroes &#x3D; function (nums) &#123;\n  var j &#x3D; 0\n  for (let i &#x3D; 0; i &lt; nums.length; i++) &#123;\n    if (nums[i] !&#x3D; 0) &#123;\n      nums[j] &#x3D; nums[i]\n      j++\n    &#125;\n  &#125;\n\n  for (let k &#x3D; j; k &lt; nums.length; k++) &#123;\n    nums[k] &#x3D; 0\n  &#125;\n&#125;\n\n边界测试用例\n\n\n\n\n\n\n\n\n[0,1,0,3,12][1,2] &gt; [0,0]\n题解对比与分析\n\n\n\n\n\n\n\n\n注意：以下数据都是在力扣中提交后返回的结果，每次提交都有可能不一致。所以相近的方案输出的结果有所差异也是正常的，最终最优方案要通过分析代码来确定，不能只以力扣输出的数据为准，只能供于我们作为参考。\n\n\n\n方法\n执行时间\n内存消耗\n\n\n\n「方法一」- 统计 0 的个数\n96 ms（战胜 17.82%）\n37.1 MB\n\n\n「方法二」- 双指针交换\n72 ms（战胜 87.23%）\n37.2 MB\n\n\n「方法三」- 双指针替换后清零\n76 ms（战胜 73.98%）\n37.2 MB\n\n\n分析一下：\n\n第一种方法是通过统计 0 出现的次数来定位到需要替换 0 的所在位置，里面涉及一个i - zeroCount的运算，所以相对其他方法来说运行时间会更长一些；\n第二个方法是通过两个指针一起运行，一个固定在 0 元素，一个一直走找到非 0 元素，最后做一个交换，这种方法没有涉及运算，同时也是一个循环就可以完成，相对来说是最优解；\n第三种方法也是用了双指针，与第二种方法的唯一区别就是先替换掉所有 0 的元素，最后把剩余的元素全部一次性替换成 0。可读性来说，个人觉得更容易懂，但是时间和空间复杂度和第二种方法是一致的。\n\n\n11 题 - 盛最多水的容器\n\n\n\n\n\n\n\n\n283. 盛最多水的容器｜难度：中等\n题目讲解给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n\n\n\n\n\n\n\n\n\n说明：你不能倾斜容器，且 n 的值至少为 2。\n\n图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n\n\n\n\n\n\n\n\n\n输入：[1,8,6,2,5,4,8,3,7]输出：49\n题目重点：\n\n首先我们的目标是挑选两条柱子，从而让两个柱子之前可以得出最大的面积（面积越大自然可容纳的水就越多）；\n挑选最长的两个柱子不等于拥有最大的面积，因为它们之间的距离也是决定空间的一个维度；\n所以重点是找到高度和宽度比例最大的一对柱子，从而得出最大面积；\n注意在运算面积时，我们只能用一对柱子中最短的一条作为高度，因为水只能填满到最短的那条柱子的高度；\n面积运算公式： 高度 x 宽度 = 面积\n\n解题思路\n枚举 —— 暴力解法\n\n遍历左边和右边，找出所有面积；\n列出所有柱子的组合；\n算出所有组合各自的面积；\n最后输出最大的面积的一组；\n缺点：遍历次数过高，所以时间复杂度会相对偏高\n复杂度：时间复杂度 $O(n^2)$、空间复杂度 $O(1)$\n\n\n双指针\n\n左右两边都往中间移动；\n\n需要移动左右两头的问题都可以考虑双指针；\n\n相同情况下两遍距离越远越好；\n\n区域受限于较短边的高度；\n\n所以让较矮的那边的指针往内移动；\n\n一直以上面的规则移动知道两个指针重合；\n\n\n\n\n解题代码「方法一」 - 枚举（暴力破解）：\n\n时间复杂度：$O(n^2)$ - 双循环，所以总计循环了 N^2。\n空间复杂度：$O(1)$\n\n&#x2F;**\n * @param &#123;number[]&#125; height\n * @return &#123;number&#125;\n *&#x2F;\nvar maxArea &#x3D; function (height) &#123;\n  let max &#x3D; 0\n  for (let i &#x3D; 0; i &lt; height.length - 1; i++) &#123;\n    for (let j &#x3D; i + 1; j &lt; height.length; j++) &#123;\n      let area &#x3D; (j - i) * Math.min(height[i], height[j])\n      max &#x3D; Math.max(max, area)\n    &#125;\n  &#125;\n  return max\n&#125;\n\n「方法二」 - 双指针：\n\n时间复杂度：$O(n)$ - 双指针总计最多遍历整个数组一次。\n空间复杂度：$O(1)$ - 只需要额外的常数级别的空间。\n\n&#x2F;**\n * @param &#123;number[]&#125; height\n * @return &#123;number&#125;\n *&#x2F;\nvar maxArea &#x3D; function (height) &#123;\n  let max &#x3D; 0\n\n  for (let i &#x3D; 0, j &#x3D; height.length - 1; i &lt; j; ) &#123;\n    let minHeight &#x3D; height[i] &lt; height[j] ? height[i++] : height[j--]\n    let area &#x3D; (j - i + 1) * minHeight\n    max &#x3D; Math.max(max, area)\n  &#125;\n\n  return max\n&#125;\n\n题解对比与分析\n\n\n方法\n执行时间（毫秒）\n内存消耗\n\n\n\n枚举（暴力破解）\n984 ms （战胜 9.99%）\n35.9 MB\n\n\n双指针\n56 ms（战胜 99.88%）\n36 MB\n\n\n分析一下\n\n通过使用第二种方法，我们从$O(n^2)$的时间复杂度降到$O(n)$，总的执行时间大概是快了 17 倍。\n\n\n70 题 - 爬楼梯\n\n\n\n\n\n\n\n\n283. 移动零｜难度：简单\n题目讲解假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n注意：给定 n 是一个正整数。\n示例 1：\n\n\n\n\n\n\n\n\n\n输入： 2输出： 2解释： 有两种方法可以爬到楼顶。\n\n1 阶 + 1 阶\n2 阶\n\n示例 2：\n\n\n\n\n\n\n\n\n\n输入： 3输出： 3解释： 有三种方法可以爬到楼顶。\n\n1 阶 + 1 阶 + 1 阶\n1 阶 + 2 阶\n2 阶 + 1 阶\n\n题解重点其实题目本身并不难，在力扣（LeetCode）是属于“简单”级别的题目，但是如果没有思路，或者对这个题目完全不了解的话，一点头绪都没有也是正常的，这种题目也就是属于套路题。如果我们是不知道的话，我们自然会难到不知道怎么做。我们要是知道了的话，那就变得相当容易了。\n这里讲一下解题的思想：\n\n\n\n\n\n\n\n\n\n首先我们解题时最大的误区是什么？\n\n做题只做了一遍\n至少要做五遍\n\n然后我们优化的思想是什么？\n\n空间换时间\n升维思想（升级到二维）\n\n看题时懵了怎么办？\n\n首先我们能不能暴力破解？\n最基本的情况我们应该怎么解决？能否化繁为简？\n\n破解所有问题的法则：\n\n找最近重复的子问题\n为什么？因为写程序我们只能写if，else，for，while，recursion（递归）\n计算机是人类发明的，计算机肯定是没有人脑那么强的，它其实就是一个简单的重复式机器\n那么计算机运行的程序也是同理，它是用重复的东西来解决问题的\n如果我们遇到算法题的时候，就是需要我们用程序去解决的问题，那问题的本身就是可重复的\n无论是算法中的回述、分治、动态规划、递归等，全部都是在找重复性的原理\n所以重点都是“找规律”\n\n深度分析题目：首先我们使用化繁为简的思维来分析：\n要到达第一个台阶，我们只能爬 1 个台阶，所以只有一种方法的可能性，所以 n &#x3D; 1 的时候，只有 1 种可能。\n那如果我们要到达第二个台阶，我们要不就是连续爬 2 次 1 个跨度，要不就是一次性爬两个台阶到达第二个台阶。所以有 2 种可能性。\n那如果是需要到达第三个台阶呢？\n\n\n\n\n\n\n\n\n\n这里有个小技巧，要到达第三个台阶我们可以换一种思维去想，如果我们还是像第一个和第二个台阶的方式去列出可以到达第三个台阶的所有可能性，那如果n很大的时候，我们只靠人的大脑去想，那真的是太费劲了。但是这里有一个很巧妙的思维方式。\n\n返过来想，我们想到达第三个台阶，只有两种可能可以到达：\n\n\n要不就是从第二个台阶爬 1 个台阶到达\n要不就是从第一个台阶爬 2 个台阶到达\n\n\n那其实如果是第四个台阶是不是也是一样的？\n\n\n要不就是从第三个台阶爬 1 个台阶到达\n要不就是从第二个台阶爬 2 个台阶到达\n\n\n这里就有一个`规律`了。要到达第`n`个台阶我们需要知道：\n\n\n到达第n-1的台阶有多少种可能\n到达第n-2的台阶有多少种可能\n然后这两个相加就是到达第n的台阶有多少种可能\n\n那其实这里就是老生常谈的斐波拉次数列:\n$f(n) &#x3D; f(n-1) + f(n-2)$\n解题思路\n斐波拉次（Fibonacci）- “傻递归“\n直接使用递归循环使用斐波拉次公式即可\n但是时间复杂度就很高 - $O(2^n)$\n\n\n动态规划\n用上面讲到的原理，到达第n个台阶只需要：爬上 $n-1$ 台阶的方式数 + 爬上 $n - 2$ 台阶的方法数 &#x3D; 爬上第 $n$ 个台阶的方式数\n所以得出的公式是 $dp[n] &#x3D; dp[n-1] + dp[n-2]$\n同时需要初始化： $dp[0]&#x3D;1$ 和 $dp[1] &#x3D; 1$\n使用这种方式时间复杂度降到 $O(n)$\n\n\n动态规划 2 - 只记录最后 3 个的方法量\n与上面的动态规划的方法一样，但是这里我们只记录最后 3 个的台阶的爬楼方法数\n使用f1，f2，f3作为储存变量\n默认 $f1 &#x3D; 1$ 和 $f2 &#x3D; 2$ 即可\n\n\n通项公式（Binet’s Formular ）\n有观察数学规律的同学，或者数学比较好的同学，会发现本题是斐波那次数列，那么我们也可以用斐波那次的“通项公式”\n公式是：$F_n &#x3D; \\frac{1}{\\sqrt{5}}[(\\frac{1+\\sqrt{5}}{2})^n - (\\frac{1-\\sqrt{5}}{2})^n]$\n时间复杂度：$O(logn)$\n\n\n\n解题代码「方法一」斐波那次\n\n时间复杂度：$O(2^n)$\n空间复杂度：$O(1)$\n\n&#x2F;**\n * @param &#123;number&#125; n\n * @return &#123;number&#125;\n *&#x2F;\nvar climbStairs &#x3D; function (n) &#123;\n  if (n &lt;&#x3D; 2) return n\n  return climbStairs(n - 1) + climbStairs(n - 2)\n&#125;\n\n「方法二」动态规划\n\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$\n\n&#x2F;**\n * @param &#123;number&#125; n\n * @return &#123;number&#125;\n *&#x2F;\nvar climbStairs &#x3D; function (n) &#123;\n  const dp &#x3D; []\n  dp[0] &#x3D; 1\n  dp[1] &#x3D; 1\n  for (let i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n    dp[i] &#x3D; dp[i - 1] + dp[i - 2]\n  &#125;\n  return dp[n]\n&#125;\n\n「方法三」动态规划 2\n\n时间复杂度：$O(n)$\n空间复杂度：$O(1)$\n\n&#x2F;**\n * @param &#123;number&#125; n\n * @return &#123;number&#125;\n *&#x2F;\nvar climbStairs &#x3D; function (n) &#123;\n  if (n &lt;&#x3D; 2) &#123;\n    return n\n  &#125;\n  let f1 &#x3D; 1,\n    f2 &#x3D; 2,\n    f3\n  for (let i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;\n    f3 &#x3D; f1 + f2\n    f1 &#x3D; f2\n    f2 &#x3D; f3\n  &#125;\n  return f3\n&#125;\n\n「方法四」通项公式\n\n时间复杂度：$O(logn)$\n空间复杂度：$O(1)$\n\n&#x2F;**\n * @param &#123;number&#125; n\n * @return &#123;number&#125;\n *&#x2F;\nvar climbStairs &#x3D; function (n) &#123;\n  const sqrt_5 &#x3D; Math.sqrt(5)\n  const fib_n &#x3D;\n    Math.pow((1 + sqrt_5) &#x2F; 2, n + 1) - Math.pow((1 - sqrt_5) &#x2F; 2, n + 1)\n  return Math.round(fib_n &#x2F; sqrt_5)\n&#125;\n\n题解对比与分析\n\n\n方法\n执行时间（毫秒）\n内存消耗\n\n\n\n「方法一」斐波那次\n超出时间限制\nN&#x2F;A\n\n\n「方法二」动态规划\n68 ms\n32.4 MB\n\n\n「方法三」动态规划 2\n53 ms\n32.3 MB\n\n\n「方法三」通项公式\n67 ms\n32.4 MB\n\n\n分析一下\n\n按照时间复杂度来说，应该“通项公式”是性能最优的，但是力扣的执行时间不是很靠谱，这一点我在上面也说到，就不多解释了。\n所以最优解还是第三种方法“通项公式”\n接着就是“动态规划 2”，因为只储存了 3 个变量，第二种方法需要用到数组。在空间复杂度上就占了优势。\n而最后输一下傻瓜式的斐波那次递归，这种方法还没有执行完就已经被淘汰了。时间复杂度过高。\n\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"algorithm/leetcode-moveZero-water-stairs","date":"2020-06-24T22:03:17.000Z","categories_index":"Algorithm","tags_index":"LeetCode","author_index":"三钻"},{"id":"340fc57e8e2087786aea08a4e455e6c0","title":"用动图解说数组、链表、跳表原理与实现","content":"「初」前言在学习数据结构与算法的过程中，感觉真的是一入算法深似海，但是越学越觉得有趣。不过我们会发现在终身学习的过程中，我们都是越学越多，不知的也越来越多，但是更渴望认知更多的知识，越是对知识感兴趣。\n本期讲说最常见的数据结构类型分别有数组、链表、跳表。这一期我们一起来了解它们的原理与实现。\n「一」数组 Array\nJava, C++: int a[100]\nPython: list &#x3D; []\nJavaScript: let x &#x3D; [1, 2, 3]\n\n\n\n\n\n\n\n\n\n\n当今的高级数据语言中，对于数组里面的类型没有严格要求，相对来说比较多元化。\n在语言下有一个标准的叫法叫做泛型，也就说任何一个单元类型都可以放入数组。\n数组的原理\n数组底层的硬件实现是有一个内存管理器的；\n当我们向计算机申请数组时，实际上计算机是在内存中给我们开辟了一段连续的地址；\n每一个地址都是可以通过内存管理进行访问；\n无论我们是访问第一个值，还是里面其中一个值，时间复杂度都是常数O(1)；\n并且可以随意访问任何一个元素，所以它的访问速度非常的快，也是数组的特性之一；\n\n\n数组的缺陷\n\n\n\n\n\n\n\n\n数组的问题关键是在增加与删除元素的时候。\n数组插入操作假设现在我们定义了一个[A, B, C, E, F, G]的数组，然后我们要插入一个D到这个数组里面。现在假设我们要把 D 插入到指针 3 的位置，我们要怎么实现呢？\n\n首先我们需要把E，F，G都挪动到各自的下一个指针；\n然后加入D到指针3上；\n\n详细实现效果请查看下效果图：\n\n\n\n\n\n\n\n\n\n\n因为插入操作的时候，我们需要挪动平均一半的元素（N&#x2F;2），所以数组每次插入元素时，平均就是O(n)的时间复杂度。\n数组删除操作删除元素也是同理的，假设我们现在有[A, B, C, Z, D, E, F]的一个数组，我们现在需要把Z从这个数组中移除。实现逻辑如下：\n\n首先把指针3的值置空；\n然后把D、E、F三个值往上移动一个位置；\n最后在例如Java的数组语言中，我们需要把数组的长度减一即可；\n\n具体的实现效果看下图：\n\n\n\n\n\n\n\n\n\n\n因为删除操作的时候，也是需要挪动平均一半的元素（N/2），所以数组每次删除元素时，平均就是O(n)的时间复杂度。\n数组时间复杂度\n\n\n操作类型\n时间复杂度\n\n\n\n查询上一个 (prepend)\nO(1)\n\n\n查询下一个 (append)\nO(1)\n\n\n查询某一个元素 (lookup)\nO(1)\n\n\n&#x3D;&#x3D;新增结点 (insert)&#x3D;&#x3D;\n&#x3D;&#x3D;O(N)&#x3D;&#x3D;\n\n\n&#x3D;&#x3D;删除结点 (delete)&#x3D;&#x3D;\n&#x3D;&#x3D;O(N)&#x3D;&#x3D;\n\n\n\n「二」 链表 Linked List下来我们一起来看看另外一个数据结构链表。链表的诞生就是为了解决数组的缺点。\n\n链表的特性：\n\n每一个元素有两个成员变量value值与next指针（指向下一个元素）；\n每一个元素串在一起后与数组是非常相似的结构；\n与数组不一样的就是每一个元素一般都要定义一个Class（类）：一般都叫一个Node；\n单链表：只有一个next指针；\n双向链表：拥有一个prev或者previous指针指向前一个元素；\n头指针用Head来表示，尾指针用Tail来表示；\n尾部指针的next指针都会指向一个None（空）；\n循环链表：尾指针的next指针指向头指针；\n\n链表添加结点下来我们一起来看看一个链表新添加一个元素的原理：\n\n首先为新的元素创建一个结点（Node）；\n然后我们需要把这个新元素插入到连个元素之间；\n把前一个元素的next指针指向新的Node；\n把新元素的next指针指向后一个元素；\n\n具体实现效果看下图：\n\n\n\n\n\n\n\n\n\n\n链表的插入操作总共是2 次，但是常数次的，所以时间复杂度为 O(1)。\n链表删除结点接下来我们一起来看看删除结点的原理，删除与新增大致上是一样的，是\n\n在需要把删除的结点的前一个node的next，改为删除结点的下一个node；\n\n具体的实效效果看下图：\n\n\n\n\n\n\n\n\n\n\n链表的删除操作只需要一次，所以时间复杂也是O(1)。\n链表时间复杂度通过分析链表的新增和删除操作，我们发现链表中并没有像数组一样需要挪动一半或者多个的元素的位置和复制元素等。也是因为这样它的移动和修改操作的**效率非常高为 O(1)。 但是在查询的时候，当我们需要访问链表中某一个值的时候，就相对变得复杂了，为O(N)**。\n我们来看看一下的链表时间复杂度：\n\n\n\n操作类型\n时间复杂度\n\n\n\n查询上一个 (prepend)\nO(1)\n\n\n查询下一个 (append)\nO(1)\n\n\n&#x3D;&#x3D;查询某一个元素 (lookup)&#x3D;&#x3D;\n&#x3D;&#x3D;O(N)&#x3D;&#x3D;\n\n\n新增结点 (insert)\nO(1)\n\n\n删除结点 (delete)\nO(1)\n\n\n\n\n\n\n\n\n\n\n\n看完Array和Linked List的两种数据结构的特性后，我们可以发现是没有完美的数据结构的。如果有完美的那就不需要 Array 或者 Linked List 并存了。所以我们需要看场景来决定我们需要用那种数据结构。\n\n「三」跳表 Skip List后续有技术科学家对链表进行了优化，诞生出第三个数据结构叫做跳表（Skip List）。跳表可能有些小伙伴没有怎么接触过，但是其实它一直都在我们身边的应用中使用。在 Redis 里面就使用了跳表。不过面试过程中并不会给大家出跳表的题目来写程序，所以我们只需要理解它的原理即可。\n跳表的核心是为了优化链表元素随机访问的时间复杂度过高的问题 (O(n))。\n\n\n\n\n\n\n\n\n\n这个优化的中心思想其实是贯穿于整个算法数据结构，甚至也贯穿于整个数学与物理的世界。那就是升维思想 / 空间换时间 - 顾名思义就是在原有的链表中添加第二维的链表叫第一级索引。\n添加第一级索引我们看看下面图什么是一级索引：\n\n\n首先索引的第一个索引指向**头 (head)，也就是第一个元素 (1)**；\n然后索引的下一个元素指向的就是next + 1，也就是**第三个元素 (4)**；\n换句话来说，就是第一级索引的元素比原始链表走快 2 倍的速度；\n\n假设现在我们需要访问结点 7，添加了这个索引后，是怎么提高了访问速度呢？我们来看看下面的图：\n\n\n首先从第一级索引中走到索引 7；\n然后从索引 7 下来找到第 7 个结点；\n这里总共的步数4 步降到 2 步就能找到第 7 个结点；\n\n\n\n\n\n\n\n\n\n\n虽然说速度是快了，但是能不能更快呢？可以的，只需要我们再叠加维度，用空间换时间的中心思想即可。\n添加第二级索引第二级索引比第一级的索引再走快一步，那就是每次走两步，也就是next+2。这样访问结点的时候就更快了。首先我们来看看加入第二级索引后的结构图：\n\n\n同理二级索引的第一个是指向一级索引的第一个，最终指向的是头 (head)；\n二级索引的第个人结点指向的就是结点 7，因为二级索引是 next+2，每次跳 3 步的进行步伐；\n\n加入了二级索引后，我们访问结点 7 的时候是怎么样的呢？\n\n\n维度升级到第二级时，只需要 1 步就能到达结点 7 的索引；\n加入二级索引后，我们从4 步降到 1 步完成结点 7 的访问；\n\n\n\n\n\n\n\n\n\n\n所以清晰看到，当我们升级多一层的维度后，链表的访问速度也会相对应的提升。也就是说，在一个非常长的链表中，我们可以加入 N 级索引，也就是提高 N 层的维度就可以提高这个链表访问的速度。总体来说我们就是需要添加log2n个级索引，来达到最高级索引维度。\n跳表查询的时间复杂度分析\n首先每一级索引我们提升了 2 倍的跨度，那就是减少了 2 倍的步数，所以是n&#x2F;2、n&#x2F;4、n&#x2F;8 以此类推；\n第 k 级索引结点的个数就是 **n&#x2F;(2^k)**；\n假设索引有 h 级， 最高的索引有 2 个结点；\nn&#x2F;(2^h) &#x3D; 2, 从这个公式我们可以求得 h &#x3D; log2(n)-1；\n所以最后得出跳表的时间复杂度是O(log n)\n\n跳表查询的空间复杂度分析\n首先原始链表长度为 n\n如果索引是每 2 个结点有一个索引结点，每层索引的结点数：n&#x2F;2, n&#x2F;4, n&#x2F;8 … , 8, 4, 2 以此类推；\n或者所以是每 3 个结点有一个索引结点，每层索引的结点数：n&#x2F;3, n&#x2F;9, n&#x2F;27 … , 9, 3, 1 以此类推；\n所以空间复杂度是O(n)；\n\n跳表现实中的形态\n来源于覃超老师的PPT\n\n\n在现实使用中，链表的索引并不是那么整齐和有规则的；\n这个是因为在元素增加与删除的过程中会有所变化；\n最后经过多次改动之后，有一些索引会跨步多几步或者少哭跨几步；\n而且维护成本相对要高 - 新增或者删除时需要把所有索引都更新一遍；\n最后在新增和删除的过程中的更新，时间复杂度也是O(log n)；\n\n\n\n\n\n\n\n\n\n\n升维思想和空间换时间的思维，我们一定要记下来，并且融会贯通。后面在解决相应的面试题的时候我们会经常用到这种思维。比如：树，二叉搜索树等经常用高级数据库结构。\n\n「四」工程中的应用链表在日常工程中其实应用是很多的，但是因为这些都属于高级的数据结构了，无论是 Java 也好、C++、JavaScript 还是 Go 语言，这些语言里面都提供了封装好的数据结构，我们只需要直接使用就可以了。\n链表的应用链表最常见的一个应用就是LRU Cache，没有接触过的小伙伴，可以百度一下深挖一下。然后这里附上一道Leetcode的题目[面试题 16.25. LRU 缓存，这道题的话使用双链表就可以实现。有兴趣的小伙伴可以尝试实现。\n跳表的应用跳表的话在 Redis 中就有应用到。 想了解更多的小伙伴可以搜索Redis的跳跃表进深挖。\n\n「终」总结\n数据结构：\n数组：随机查询快 O(1)，但是删除与插入较慢 O(n)；\n链表：删除与插入快 O(1)，但是随机查询慢 O(n)；\n跳表：为了提高链表的随机查询而生的，随机查询能提升到 O(log n)，但是维护成本高；\n\n\n思维重点：\n&#x3D;&#x3D;升维思想 + 空间换时间&#x3D;&#x3D;\n\n\n应用：\n链表：LRU Cache\n跳表：Redis\n\n\n\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等和你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n\n\n\n\n\n\n\n\n\n公众号《技术银河》回复”算法资料”，可以获得这个系列文章的PDF 版和其他资料！\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"algorithm/algorithm-array-linked-list-jump-list","date":"2020-06-14T09:50:24.000Z","categories_index":"Algorithm","tags_index":"Linked List,Array,Jump List","author_index":"三钻"},{"id":"d71e3dea9caf5fdc0a76ab95e2b29804","title":"阿里、力扣、政采云的15位专家分享前端面试与招聘视角","content":"「始」前沿有幸在 5 月 31 号参加了《第八届前端早早聊大会》主办的《前端跳槽的新起点｜前端如何搞面试》。在这次大会中从早上 9 点半一直到下午 6 点多结束，大会含金量超高，我此次受益匪浅，屁股坐到起茧都是超级值得的。本次大会一共有15 位来源于各大厂公司的高级前端工程师和技术专家，每个讲师都给我带来了精彩绝伦的知识与干货。\n这次大会的内容不只给我的技术生涯中带来了冲劲，让我认知到自己还有很多的不足与未知。同时也让我认知到了优秀的技术人才与团队的能力模型，讲师们有说到他们的经历和三观，引发了我对自己“保安式”的灵魂拷问。\n听完本次大会后，真的让我重新认识了自己，也重新找到了前进方向与目标。最后还收获了许多知识与秘诀。下来我来总结一下我在这个大会上吸收到的知识精华。\n\n\n「一」候选人视角看待面试首先我们从候选人（面试者）的角度来剖析和分析一下面试者应该怎么从准备到面试成功，最后拿到心仪的 Offer。\n\n「1.」面试准备\n\n\n\n\n\n\n\n\n我以前准备面试的时候都会非常慌张，不知道自己需要复习什么，或者做什么准备工作。甚至还有在某宝，某猫，某东买下了一堆的书籍开始刨书。还有就是下了几个 TG 的视频，然后天天晚上熬夜刨视频学习。这种方法其实作用真的不是很大，而且前端那么多知识，要全部都会，都能深入了解，是并不可能的。更重要的是我们平时每天的累积和沉淀。\n那应该怎么准备呢？通过大会中各位优秀的候选人的分享，其实我们第一步应该是重新认识自己。\n\n「1.1」 重新认识自己在大会中我认识到如何深度剖析自己，从性格和心态、优点与缺点、思维、技能与知识、项目经验等维度开始剖析。\n\n\n\n\n\n\n\n\n\n每位讲师都有重点提及到，在优秀的团队中更看重的是一个人的自我修养，包括积极乐观面对挑战的态度，自信但保持谦虚的心态和突破瓶颈的魄力。如果在技术中没有，那在生活中我们有没有这样的修养，如果都没有那肯定是有待提升的。\n\n性格与心态 —— 深入了解和懂得自己的性格，会对我们在面试和工作中有很大的帮助\n自卑不自信 —— 谦虚但不自卑\n很多小伙伴如果没有强大的学历背景和经历，往往会内心很自卑，不自信，在面试前中后都非常紧张、害怕和焦虑；\n如果我们是有一些自卑不自信的，那我们是需要去调整和克服的；\n但是每一个人的缺点也同时是他的优点，拿内向来说，自然会特别敏感，但是同时也具有洞察和感知他人情绪的能力；\n在面试之前，先平复自己的内心，给自己心理暗示（我们是可以的！）\n面试的过程中，多使用我们的洞察力来看清面试官当前的情绪从而做出调整，让自己在面试中表现的更好；\n\n\n自信 —— 自信但保持谦虚\n自信是我们的优点，那同理也会是我们的缺点；\n自信很容易让我们自大，过于自信时就会忘记谦虚；\n我们要时刻保持着谦虚的心，自信而不自大，谦虚而不自卑；\n自信更多要来源于我们的准备和硬实力，而不是空虚无力的自信；\n\n\n积极乐观 —— 阳光正面面对挑战\n我们可以问问自己是喜欢在一个积极乐观的团队中，遇到问题大家都积极面对，共同寻找解决办法，还是遇到挑战都会一起刷屏“我太难了”？\n个人心态会影响身边的人，一个团队的环境更会影响着大家的效率和工作激情；\n所以优秀的团队都会选择积极乐观，勇于挑战，有主见，有想法，有自信的人来加入；\n注意以下两种消极心态的自己：\n二元轮认知 - 解决问题的态度要正面，找到成功的可能，不是站在对立项目的问题；\n偏执型人格 - 不要为自己的失败辩解找理由，只为成功找办法；\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n找到自己的性格，可以从而先解决自己性格上的缺陷，这个也是我们内心最基本的素养。一个优秀的技术人员首先就要有一个优秀的内心素养。良好的素养可以提高我们的面对困难，面对挑战时的心态，也是能让我们在技术道路上走的更远的基本功底。\n\n自我审视，重新思考 —— 挖掘自己的优势与劣势\n\n\n\n\n\n\n\n\n讲师们讲到的认识自己也包括挖掘自己的优势与劣势。那有哪些是要在面试前要挖掘自己的呢？\n深入思考后发现能自我探索，找到自己的能力和缺陷所在，才能让自己持续的成长，让每一件事情下一次做都能做的更好。有一句话“失败是成功之母”，其实这句话里面还有更深层的意思，如果我们失败后不总结，不找出自己失败的原因，无法自我挖掘自己在这件事情中做的好与不好的地方，那再去尝试总归还是会失败的。\n每一次失败都是一个学习的过程，重点不是我们失败的结果，而是我们在失败的过程中得到了什么，然后我们应该怎么去改变做的更好。\n在开发或者是工作中无非就是从失败到成功，从做的不够好到做的更好的过程。所以我们要善于总结自己，找到自己的优点与缺点，扬长避短，不断提升改变自己，才能让自己越来越优秀，越来越成功。\n认识自己是一个很漫长的过程，持续的自我探索本身也是一种能力。只有发现自身的优势与劣势才能更好的让自己持续突破瓶颈往前迈进，也是一种发现自信的过程。\n\n\n\n\n\n\n\n\n\n那么我们具体要挖掘自己哪些东西呢？\n从古到今：\n\n学习到的知识；\n工作中参与过和负责过的项目；\n在每个项目中的角色和做的事情；\n最终我们得到了什么“量化”的效果和结果；\n\n首先讲讲知识：\n具体剖析自己懂得哪些，哪些是自己的强项，哪些是自己的弱项。强项就深挖学习，弱项就刻意学习。\n\n需要我们懂什么知识？\n基础知识\nJavaScript, HTML(5)，CSS(3)，HTTP，浏览器等\n要懂方法实现和工作原理\n\n\n框架能力\n3 大框架必须至少熟悉到精通使用其一；\n并且深耕到框架底层实现和工作原理；\n重点复习 React 和 Vue；\n还有每个框架的周边产品的运用和原理；\n\n\n常见设计模式\n不能就准备如何实现；\n更多的需要知道设计模式如何在项目中如何应用与实现；\n作用是什么？为了什么？\n\n\n前端性能优化\n4 个层面资源优化，请求优化，渲染优化，JS 优化；\n每一个优化知道 1-2 种优化；\n\n\n数据结构及算法\nLeetCode 刷题量（每天 1-2 题），有较强的逻辑思维与能力；\n以简单到中等难度为主，偶尔练一练高难度的题目；\n常用数据结构：树、栈、队列等；\n运用了数据结构及算法解决了什么复杂的业务问题；\n\n\n源码阅读\n熟悉的技术栈关键源码；\n源码的实现逻辑；\n懂得为什么这么实现，有什么好处，可以列举出来；\n\n\n\n\n\n分析出我们懂得哪些知识和有哪些我们需要加强的，我们应该怎么学习和加强呢？讲师们给到以下意见：\n\n学习与加大知识库：\n形成知识体系\n知识点\n理论\n体系\n\n\n学习 - 输入知识\n看书 - 技术书籍、技术以外的书籍\n看文章 - 博客、官方文档\n源码 - 通过看懂看透底层原理\n看视频 - 报课程\n\n\n构建关系\n思维导图 - 牢固的知识是从有树干到树杈到树叶，都是一环扣一环的\n5 个 Why - 构建知识脑图时的 5 大重点\n背景 - 技术诞生的背景以及迭代史是什么？\n原理 - 技术原理是什么？\n场景 - 有哪些应用场景？\n比较 - 横向比较同类技术，各自的优点，缺点是什么？\n未来 - 未来会支持哪些新特性？\n\n\n\n\n稳固 - 费曼技巧（以教为学）\n提取压缩 - 写成自己的笔记，脑图等等，抽出知识的重点与精华\n转为语言 - 明确任务、拆分知识、清理关系\n列举例子 - 新例子、新视角\n能教能传授 - 能教会一个不懂这门知识的人，这个知识你才是真的达到精通水平\n\n\n\n\n\n然后我们来讲讲项目：\n各位讲师都反复强调，在面试的过程中我们要习惯使用STAR法则来剖析我们的项目经历和经验：\n\nSituation - 场景\nTarget - 目标\nAction - 行动\nResult - 结果\n\n具体表述时使用以下部分，一步一步来讲述自己的项目经验：\n\n背景：项目背景，是什么情况下发生的\n角色：我当时承担了什么角色\n职责：负责工作的哪一方面，协调&#x2F;开发&#x2F;等等\n难题：遇到了什么难题，怎么解决的，为什么这么解决\n结果：项目结果如何，有数据支撑更有说服力\n沉淀：做完这个项目沉淀了什么，给别人带来了什么\n复盘：如果重新让你做这件事，你会怎么做，有什么更好的方案\n评价：项目中的表现，你周围小伙伴怎么评价的，上级怎么评价的\n\n梳理“关键”经历和经验：（阶段性需要回顾经历和经验，以项目或者半年为周期）\n\n梳理2-3 个亮点项目，并能通过 STAR 法则描述\n让面试官了解，我们做了这个项目不只是为了 KAI，我们是有思考，有主动思辩思维\n这个也能体现出 Owner 精神\n在项目中的角色和起到的价值\n工作中对团队&#x2F;他人的影响（不只局限于做好自己）\n\n\n梳理人生的失败经历，传递看法、描述行为、获得成长\n“项目黄了&#x3D;没有受益”？❌❗️，不是的\n通过失败的经历，传递你面对失败的态度\n并且能够反思自己，并加以改变，最后获得了成长\n反面例子：遇到失败就堕落，抱怨，退缩，这样反而让面试官觉你逆商不够\n\n\n梳理人生的高光时刻，传递你的价值观和需求层次\n首先问自己：这件事情为什么让你觉得是人生的高光时刻？\n当前处在《马斯洛》的《需求层次》的那个层次呢？\n\n\n梳理职业规划方向，思考未来想成为一个什么样的人？\n在面试中都是一个高频的问题\n\n\n\n最后再多想想我们自己的经历，过往的人生中做过成功的事情和失败的事情，在这些事情当中多问自己“为什么”。为什么会成功？为什么会失败？做了什么让事情得到了好的结果，又做错了什么导致自己的失败。这个过程其实是很有趣的。\n\n「1.2」明确梦想公司与团队在大会中讲师们也有重复强调一个点“找到合适你的公司&#x2F;团队&#x2F;项目”非常重要。\n这个也是为什么我们第一步先要剖析自己，重新认识自己，因为只有了解自己的能力和自己是怎么样的人，才能更好的找到合适你的公司，团队和项目。\n\n何为合适？\n公司\n企业文化\n企业价值观\n企业规模\n企业发展方向\n\n\n团队\n团队文化\n团队价值观\n团队使用的技术栈\n能否让你成长\n\n\n项目\n业务是否是你感兴趣的\n项目的发展方向\n价值观相同\n能否让你成长\n\n\n\n\n\n找到自己合适，有共同价值观，共同努力目标的公司和团队是完全不一样的体验。在大会中好几个候选人都分享了进入团队后的感想，这里也分享一下他们的感悟：\n\n见识到阿里工程师最基本的职业素养\n既要有过硬的前端基础技术能力打底\n也要有 ONWER 意识，团队推动力，跨团队协作能力，沟通能力非常重要\n优秀人才多，互相吸引，互相敦促成长，共同进退\n\n\n真-海量知识\n进来的第一周感觉知识像洪水一样涌入，技术产品和业务沉淀齐飞\n有非常多的优秀知识在内网\n无论是软实力还是硬实力都在压力下极速成长\n完备的基础设施和工作流\n\n\n终于在国民级应用上大展拳脚\n爽，刺激，有成就感，能让很多亲朋好友都见到自己亲手写的代码\n同时也面临着更大的挑战，千万级流量下更严苛的性能挑战，线上稳定性保障\n\n\n为何要选择阿里巴巴\n大平台、大公司、大机会\n\n\n为何选择淘系技术部\n稳定成熟业务体系\n不缺乏创新点\n\n\n\n\n\n\n\n\n\n\n\n\n经历过这次大会，我发现人生中最重要的两个选择，也是会陪伴我们最长的，那就是梦想公司&#x2F;团队和终身伴侣。\n\n「1.3」准备简历一个好的简历就像等于一块 3 级敲门砖，为我们敲开进入大厂的第一扇门。\n简历中需要注意的：\n\n书写原则：\n排版清晰，技术的简历模版不要“标新立异”（导出 PDF）\n挑选重要、突出的优势表达\n无关次要的不要表达\n适度包装、不能造假\n用量化指标去说明\n\n\n职位 JD：\n挑与岗位匹配的内容\n岗位职责、硬技能、找差距、不齐差距\n\n\n内容排版：\n基本信息（要全面：包括邮箱、联系方式等基本信息）\n专业技能（专业技能按掌、熟悉、了解程度依次罗列）\n项目经验（亮点项目详细写，附带数据描述成果更具说服力）\n教育背景\n\n\n简历模版\nWonderCV、五百丁\n\n\n多份简历\n不同岗位\n不同公司\n不同等级\n以上不同的都需要针对的去调整简历内容\n\n\n\n\n「2.」面试技巧任何事情要做好，首先我们要先了解清楚这个事情的来龙去脉。那面试也是一样的。\n\n「2.1」岗位职级\n\n\n\n\n\n\n\n\n这里主要讲说的是阿里巴巴的技术岗位职级。很多时候去面试失败怀疑自己是不是哪里表现的不好，往往有可能是自己对自己的能力认知有误差。能力在 P6 时，去投了 P7 等级的岗位面试，这样结果很大可能会失败。所以首先要找到对标的岗位职级！\n\nP5 级别\n独立执行既定的任务，寻找更优解\n培养潜力巨大，较强学习能力\n\n\nP6 级别\n独挡一面，能负责多个业务模块\n能团队协同做项目，担任项目 PM\n\n\nP7 级别\n专家，一杆到底的系统性思考\n技术方案可被复制\n\n\n\n注： 详细的岗位职级会在“面试官视角看面试”的部分详细讲说\n\n「2.2」形象建设在面试之前，我们要整理好自己的形象。一般来说在我们首次与陌生人相见，第一形象和眼缘是会给别人带来很大的吸引力。\n\n声音形象 —— 通常第一轮面试都是电话面试，所以我们都是通过声音来交流\n语速\n反面例子：语速过快导致听不清，语速过慢会让面试官失去耐心\n正面例子：保持均匀的水平（一分钟大概 200 字左右）\n\n\n语气\n反面例子：语气上扬太高会显得你很轻浮，不够稳重\n正面例子：心平气和，温和的语气，外显的是平和、尊重与体贴\n\n\n语调\n反面例子：语调太低，语调微弱，会给人感觉胆怯懦弱\n正面例子：用胸腔偏下的位子发声，这样发出来的声音是雄浑有力的，不会显得很沉闷反而会有一些磁性\n\n\n\n\n外在形象\n简单、干练、不邋遢\n头发洗一洗\n头发鼻毛剪一剪\n胡子剃一剃\n穿着干净简单大方\n\n\n内在形象\n人格上吸引力\n自信、踏实、皮实、乐观\n\n\n\n\n「2.3」面试流程\n\n\n\n\n\n\n\n\n根据各位候选人的总结，阿里面试基本上都是 5-6 轮。一般在 1-3 周左右完成。\n我从几个优秀的候选人的面试经历，总结出的大概面试流程：（因为不同部门，不同团队，会更具部门要求有所差异，只供参考）\n\n技术一面 - 同岗研发&#x2F;直属主管（30 分钟左右）\n考察重点：基础和知识广度（专业 80% + 软素质 20%）\n内容：\n计算机基础：算法、数据结构\n前端基础：JS&#x2F;CSS、前端框架、Node、浏览器原理、网络、安全、跨端能力（后端或客户端）\n编码能力：逻辑是否清晰、辩解是否考虑到、思维是否活跃、设计模式能否应用、方案设计与细节\n技术视野： 行业技术现状、新技术的了解和实战\n\n\n\n\n技术二面 - 部门主管&#x2F;前端负责人（40 分钟左右）\n考察重点：工程能力、设计能力、规划能力（专业 60% + 软素质 40%）\n内容：\n工程能力：效率、质量、性能、定义标准、产出规范\n设计能力：抽象能力、拆解能力、健壮性、扩展性\n规划能力：做事的思路是什么\n沟通和推动力：是否有一套自己的项目推动方法和成功案例\n产品意识：事情的目标是什么？存在哪些问题？如何解决？价值体现在哪里？规范？共建（也就是项目 STAR 讲述过程）\n其他软实力：聪明程度、学习能力、责任心、价值观等。\n\n\n\n\n技术三面 - 部门 TL&#x2F;总经理（100 分钟左右）\n考察重点：技术格局和视野、人生规划、软技能考察\n内容：\n沟通表达能力\n工程架构能力\n业务&#x2F;行业思考理解\n综合能力与成长性\nPS：这一轮有可能出现笔试\n\n\n\n\n技术四面 - 交叉面（20 分钟左右）\n考察重点：项目经验、价值和解决问题能力\n内容：\n方案选型与设计细节\n\n\n\n\n技术五面 - 大 BOSS&#x2F;HRG（60 分钟左右）\n考察重点：项目中的亮点技术方案、业务能力、抗压能力\n内容：\nHR 更注重软实力\n综合能力与成长性\n人才调性与匹配度\n发展与薪酬待遇\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n如果面试官觉得还需要深入了解或者确定候选人的能力，还会加多一轮交叉面试。主要还是为了能对候选人有一个公平公正的评估，让候选人能拿到与能力相配比的岗位职级。\n\n「2.4 」面试技巧这次大会中候选人提出了很多不同的面试技巧，这里我总结了我觉得最实用的技巧分享给大家。\n面试模拟\n自我模拟\n讲给自己听\n讲给朋友听\n找一个在你水平之上的前辈模拟面试\n\n\n实战模拟\n收集反馈\n分析问题\n自我调整\n反复实战\n\n\n\n沟通技巧\n沟通原则 ——\n客观描述事实，不做主观臆断\n\n\n三说 ——\n知道的知识-自信说\n模糊的知识-假设说（分情况说）\n陌生的知识-诚实说（比如说我的知识还没有接触到这一块，“但是”我知道什么什么，我可以跟你聊什么什么，把不擅长的话题往你知道的带）\n\n\n三不说 ——\n不说谎话\n不说抱怨的话\n不说轻浮的话\n\n\n\n面试节凑\n引导对方\n每个面试官会问的问题都是无法预测的\n所以我们可以引导面试官问我们擅长的问题\n知识点 A 引申出知识点 B、C，预埋问题坑位，引导对方提问\n注意重点还是要在回答 A 上，顺带 B 和 C 来做引导下一个问题的主题\n\n\n渲染情绪\n在面试的时候要多感知对方的情绪\n感知对方情绪，判断策略，引发对方的共情\n特别是我们有高光时刻，这些是很容易让别人产生共情的\n\n\n反问阶段\n如果在这个阶段不知道问什么的时候，有一个保守的问法\n了解对方团队、技术栈、痛点问题、组织定位\n\n\n\n面试后加微信\n夸赞对方 —— 夸赞对方在技术领域的专业性\n承认不足 —— 勇敢承认自己当前的不足\n询问建议 —— 询问从面试官视角给予你未来的建议\n建立人脉 —— 弱关系，未来关键时刻能帮上你\n\n面试复盘\n复盘结果 —— 梳理答的好&#x2F;不好的知识点，记录，找差距，反复实践\n复盘情绪 —— 回忆面试那种情绪占比多，紧张、开始、严肃、调整心态\n\n\n\n「二」面试官视角说招聘站在候选人（面试者）的视角，我们总是会去思考面试官会怎么面试我们，需要我们具备什么技能和能力，拥有哪些人格魅力与高光点。这一次大会有一半讲师都是从面试官的视角来讲招聘。我们一起来学习，会对我们求职的过程中有很大的帮助。\n\n「1.」简历来源渠道\n\n熟人内推 （推荐 👍👍👍）\n猎头（推荐 👍）\n招聘平台 - BOSS 直聘，拉钩等\n技术大会 - （推荐 👍👍）各类技术大会，会在现场互相认识加微信获得机会\n社区 - 通过朋友圈或者其他活动社交\n自主投递 - 邮箱投递\n\n\n\n\n\n\n\n\n\n\n虽然说每个大公司和团队都有在各个渠道上去招聘。但是占比最大还是内推，毕竟是熟人内推，比其他渠道更可靠，加上有内部朋友背书，TL 会更加认真对待。所以“推荐简历投递渠道：熟人内推、猎头、技术大会和社区”。\n\n「2.」对候选人的要求\n\n\n\n\n\n\n\n\n大会上几个讲师都有讲到这个，优秀的团队都会看重候选人身上是否拥有以下特征。\n「2.1」优势特征 - 能通过的候选人\n基本功扎实\n良好的技术基本功（计算机基础，前端基础，框架应用与底层原理等等）\n良好的开发流程理解\n对既往负责业务的理解\nApi 外对原理的一定探究\n\n\n要性强\n良好的主动性\n能主动探索更多可能性\n对平庸的低忍耐\n抓机会及落地能力\n\n\n证明自己\n主导过的业务\n推动过的建设\n解决过的复杂度\n个人作品\n\n\n较好的认知\n非被动执行思维\n对技术的嗅觉\n非二元论认知\n良好的合作性格\n\n\n\n「2.2」共性问题 - 未通过的候选人\n专业能力的问题\n相关基本工不行\n7 年时间 2 年工作经验\n4 年销售自学前端 2 年 - 基本不是热爱前端知识为了分工作的\n面试沟通一直外围绕圈子\n\n\n职业能力问题\n3 年 4 条（稳定性）\n基本的沟通能力堪忧\n业务经验差，被动执行\n综合深度浅，做完而已\n\n\n性格问题\n二元轮认知 - 解决问题的态度要正面，找到成功的可能，不是对立项目的问题；\n偏执型人格\n\n\n匹配度问题\n简历造假（诚信是红线）\n匹配度（双向阶段匹配）\n背调，口碑\n背面经，过度包装自己\n\n\n\n\n「3.」岗位剖析层级关键能力：\n\nP4 - 前端工程师（做完）\n独立承担，独立执行\n\n\nP5 - 高级前端工程师（做好）\n能思考并践行如何能做得更好\n\n\nP6 - 资深前端工程师（影响）\n通过影响和带动他人，帮助业务和团队拿到更好的结果\n\n\nP7 - 前端技术专家（改变）\n前瞻性、目标感、主导性、整合力\n推动力、拿结果、影响力、领导力\n\n\n\nP6 为例，P6 的关键能力拆解：\n\n专业能力：\n良好的基础知识及运用能力\n熟悉常用规范、类库及周边应用\n能完成相对复杂前端技术方案设计\n快速定位及解决疑难杂症的能力\n一定的 Node.js 或其他服务端语言能力\n\n\n职业能力：\n良好的沟通，沟通及时有效\n独立的前端业务接口能力\n领导跨部门项目的 PM 能力\n理解业务优先级，有效管理业务预期\n跳出前端看问题，寻找最优解方案\n\n\n场景方案：\n业务场景的有效方案沉淀\n能承担团队体系内某专项的建设突破\n思考处理业务场景&#x2F;问题的通用方式\n通过处理一个问题，解决一类问题\n考虑必要的投入产出比\n\n\n推动及落地能力：\n抓住工作重点，解决关键问题\n主导职能领域某一方面的建设\n有效利用团队的力量获取最大的结果\n规划路径，落地既定目标，永不放弃\n\n\n\n\n「4.」面试必要准备\n表述清晰的简历 （10%）\n真实陈述，勿造假\n避免关键词堆砌，空洞\n倒序，提炼，避免“万字文”\nPDF 格式优先\n\n\n必要的基本功复习（30%）\n前端三件套\n基础的算法\n常见的业务场景方案\n别背概念，有价值的是如何应用\n\n\n复盘既往工作中的价值（50%）\n背景、角色、过程、结果\n重点要体现个人生产的影响\n减少执行性陈述的堆砌\n结构性认知、体系化思维（如有）\n过去一段时间最大的成长\n\n\n自己后续的职业规划（10%）\n目前的成长短板\n后续的职业成长方向\n这个方向需要什么样的空间\n为新团队带来的价值是什么\n什么能放大你的价值\n\n\n\n\n「5.」面试官的面试方法一般都会从“聊聊最深刻的项目”开始，在深入到以下点：\n\n业务目标 - 对业务了解是否清楚\n方案选型 - 有没有符合逻辑的思考\n技术细节 - 了解是不是比较深入，基础知识的考查\n最终结果 - 拿结果的能力，是不是可量化的，比如性能优化，最后有没有一些明确数据来证明\n学习思辨 - 思维，思考，思辨，学习的能力，是否有潜力\n\n\n「6.」应聘建议\n第一印象：\n一份有诚意的简历\n👍 项目罗列要突显项目的亮点和思考\n👎 如果以流水账的形式列举就会有不好的印象了\n\n\n明确意向：\n明确个人诉求，确定目标团队\n👍 懂得自己想要什么，确定自己的目标团队\n👎 不希望是大海捞针，随便乱头，碰碰运气\n\n\n回顾总结：\n过去的工作经历、沉淀、成长、收获\n面试之前需要提前准备好\n\n\n自我认知：\n给自己的定位\n有哪些核心竞争力和不足\n\n\n面谈技巧：\nSTAR （SITUATION &#x2F; TARGET &#x2F; ACTION &#x2F; RESULT）\n根据 STAR 原则来应对和面对问题\n\n\n面试复盘：\n不管成功还是失败\n总结自己面试中的表现、经验教训\n\n\n面试中的误区：\n不要死记硬背概念、知识速成、海量刷题\n可做适量的准备，但是不要为了面试而面试\n\n\n不要一问一答、不问不答、话唠、东扯西扯\n找到自己答案中的明确目标和中心点，讲重点，不要跑题\n勿辩解，忌装懂\n可以从中心点扩张，不止于现状，寻求更优方案\n\n\n不知道自己是谁、自己有什么、自己要什么、该去往何处\n目前定位是什么\n核心竞争力是什么\n自己未来的规划是什么）\n\n\n诚信问题！不要造假，不要造假，不要造假\n出现诚信问题，以后就与面试的公司说 88 了\n\n\n尾声时没有问问题\n这个时候可以补充自己的一些亮点\n别错过咨询面试官的机会\n主动加面试官微信，可以继续练习加深第二印象\n\n\n\n\n\n\n\n「三」Q&amp;A - 问答环节问：如何看懂源码？\n\n先从使用场景开始深挖源码；\n了解在这个场景下的实现逻辑；\n然后再从大局的原理来理解；\n不要焦急一下子了解全部源码；\n\n问：工作中项目没有亮点？\n\n跟面试官反馈让自己负责更难更大的事情；\n归纳总结，有自我思考那些简单的业务有什么提升点，用什么技术点可以更好的提高；\n提出自己的优化方案，和提高项目技术的方案；\n\n问：怎么克服业务代码的瓶颈？\n\n只有做业务才能成为专家\n还在执行认知，还在想着怎么做完，没有思考怎么才能做的更好\n代码的分层架构，组件化，设计合理性等方面\n如何跟业务方保持好良好的沟通\n通过定义一个问题来定义一种问题，解决一个问题，解决一种问题。\n\n问：业务执行转架构师怎么做？\n\n用通用方式来解决问题\n架构师不能脱离业务，要深度了解业务\n业务的玩法，运作方式，前端开发中遇到的问题，找落地方案\n落地方案：面线业务的整个闭环 - 团队最大的痛点（人效，成本，体验）\n深入了解业务，再开始深入开始架构\n尝新最新的技术架构选型要优先考虑团队\n\n问：跳槽太平凡可以进入大厂吗？（在小公司）\n\n你女朋友过去两年换了 5 个男朋友你会怎么想？\n公司都是看长期受益的，跳的太平凡都是影响你的稳定性和信誉的。\n有人给你做背书能为你争取；（内推，有朋友在内部）\n先降低你的预期，下一个工作挑一个好的公司稳定一下，沉淀一下；\n\n问：如何控制面试阿里的面试频率？一次面试简历会锁多久？\n\n按照我自己的经历来说，并没有锁的概念\n我失败过一次之后，我还是会被其他面试官撩起来邀请过来面试\n如果同学想要去阿里的话，还是建议好好复习\n\n问： 请问蚂蚁金服招人是否有年龄上的限制？或者有更细的年龄分成？比如：30 岁只有 P7 才能进入\n\n确实是不能很详细说的，年龄不是最重要的考核标准\n在 P6 这样一个起步的职位要求，是希望有独当一面，辅助团队的能力\n比如说应届生或者工作 1 年左右经验的是不太有这些沉淀（一般情况来说，但是也有个别的）\n所以更看重的是有一些 2-3 年工作经验以上的沉淀的，这样会更合适\n像 P7 需要有一写领域深入的理解，一般没有长期的沉淀是不可能符合的（也有同学工作 1-2 年就沉淀了很多很多，所以一加入进来就 P7 了）\n总的来说我们都建议不同的层级有一定时间的沉淀，但是这个是建议不是要求\n\n问： 在前端打磨了 9 年，目前技术专家级别刚入职，但是心里有一个阿里梦，再过两年阿里还要我这样的人么？请问阿里对学历有什么要求？\n\n不管是几年，只要你的能力能达到你的发展的状况，比如说工作了 9 年，你是的能力是否能与你的工龄相匹配，能在一个领域里面成为一个专家。然后通过这些年的沉淀，在各个方面都有全面的知识沉淀和成长。只要是能够有对应这个能力的成长的话，都是能够进入到面试，也可能会成功。\n重点是自己技术的成长，能对的起自己那么多年的沉淀和学习。\n学历来说，举个例子，我团队这里也有专科学历毕业的，重点还是能力和亮点，能搞证明自己的技术实力，这些不是学历能够达到的。（但是也要看团队，像钉钉就不接受专科）\n\n问：工作了 2 年不是主动的情况下换了 3 加公司，如果这种情况想进大厂的话，会不会经历太平凡受到影响呢？\n\n分两个层面，主动和被动跳槽，不会一刀切\n我们都会详细了解跳槽背后的原因是什么\n但是经常换公司会对自己沉淀和成长有一定的影响的\n所以频繁跳槽还是会有一定影响，但是不绝对，还是要看个人实力和沉淀\n\n问：是什么帮助你在技术上和认识上的到一个很好的修炼呢？\n\n技术上更多是兴趣吧，因为接触的比较早，在技术上就是要不断的去尝试和不同的方面，一定要找自己感兴趣的方向，因为兴趣还是一个重要的老师，让自己去探索技术里面的价值和潜力所在。\n认知的话更多的是数学思维，数学对我的帮助是非常大的。它能让我去理解一些从代码角度很难理解的事情，也让我能更好的理解需求和代码上的解耦。\n\n问：平时是如何学习新东西的呢？\n\n这个我也会问候选人这个问题。一般来说每天开始，到公司之前我都会浏览一下科技型的网站。一方面拓宽自己的视野，慢慢这些知识会形成你自己的一个理解之后，就可以分析自己需要深挖的领域或者感兴趣的领域。\n这个前提是非常重要的，如果我们盲目去接触新的领域和框架，自己的精力会非常分散。所以我一般都会经常去听一些业界的声音，大家对这些事情的评论。先从对方的一个主管角度去接收到这些信息，这个可以帮助自己有一个大局观，了解到业界在做一些什么，大家对某一些事情的理解是怎么样的。慢慢变成自己的理解以后你就知道应该去学一些什么知识了\n到了想如何去学习这个知识的时候，那就相对比较简单，因为肯定有很多人，或者某一个知识领域推荐有哪些书籍是最佳实践，最后去找这些书籍去看就好了。\n重点是在这个过程你要非常明确你想要的是什么，千万不要今天出了几个知识点或者框架，我先去把它吃透了，我们要把精力集中在一个你希望深入的领域去探索。忌“什么我都要”，“什么我都会”，这个样是不可取的。\n\n问：你是怎么成长起来的呢？你是怎么安排自己的时间管理？\n\n在业务中多思考，在工作中时间太精凑无法思考，所以这个时候可以考虑在业务中提升自己的能力。站在业务的指点上去学习新的技能和知识。然后在日常积累和封装成论证，放到 GitHub 上，让更多的人给你建议，这样也能提升自己的能力。\n算法上必须每天去 LeetCode 进行练习，每天抽半个小时去刷题，对自己不熟悉的题要反复的去练习。慢慢自己就会慢慢好起来了。算法这一块知识会对你学习新知识会有很大的帮助。\n现在新技术勤出不穷，你要学会在一些网站上去关注一下这些新技术，用自己以往的经历来去对这些新技术的原理有基本的认识，考虑为什么要出这个技术，这个技术给我带来的技术方向是什么，我以后要朝着什么方向学习。\n最后尽量去大厂吧，大厂的话像阿里巴巴这样的平台，学习资源有很多。会发现以前你花很多时间解决的问题，在内网看一篇文章就能解决了。\n\n问：你负责那么多方向，你是怎么兼备的呢？\n\n作为一个 Leader 你要为你的团队找到方向，打开更多的空间。只有帮你的团队往上打开的空间足够大之后，你团队下的小伙伴才能朝着这个方向有足够的发展。\n让团队每一个同学找到位子，能好好的做事，做的事情能得到公平公正的回报。\n根据发展来设计团队的方向。\n更空闲之后就会关注技术方向和落地。\n如何兼备其实重点在于更具事情和阶段来动态调配。\n\n问：阿里 P7 有哪些具象的要求？要做一些什么事情？\n\n技术开发的核心骨干，写代码写的好写的快是基本要求。\n在本专业的技术深度和广度要足够。\n懂如何分析综合性问题的能力。\n技术选型方案，并且与其他团队做到更好的落地。\n技术量级应该如何应对。\n\n问：腾讯与阿里那个更适合上升期的发展？\n\n前端时间我和腾讯的一些朋友聚在一起讨论我应该去那种公司&#x2F;团队呢？技术好的？还是钱多的？其实都不对，应该加入成长性更大的团队。\n主要看这个部门和团队的业务成长性暴发性更大的。无乱是阿里巴巴还是腾讯都在众多的领域中有他的规划，重点还是业务和成长性更高的团队。\n\n问：候选人面试的准备，阅读源码是不是重要的一项？\n\n有源码阅读经验的同学是非常喜欢的，比如说度过 React，Vue，webpack 的源码等，我们就能判断这个小伙伴对于这一块技术有浓厚的兴趣和专研。\n\n问：前端有没有遇到过瓶颈期，是怎么突破的呢？\n\n当时在创业公司待了三年，一个小团队，没有什么学习氛围。如果当时我停下来拿肯定就废了。\n那那时候是怎么做的呢？持续关注行业的动态，注意最流行的技术趋势是什么，我们的业务可能会需要什么。当时创业的时候还写了 node.js 的书。\n当时也是很累的，晚上 12 点回到家继续看博客总结继续输出。\n当时团队需要我做什么我就去接什么，当时做的最杂的时候，前端，PHP，nodejs，甚至最后 C++，IOS 都会接触到。\n遇到瓶颈的时候问自己一个事情\n现在自己想往那个方面去发展？\n当前业务，团队甚至是集团需要你去做什么？\n回答以上两个问题，基本上你就可以知道一个答案了\n\n\n\n问：跨行业面试有什么要求（转行的）？\n\n这个同学应该说是之前做的是两外一个行业，然后对前端特别热爱。\n面试这种跨行业的话，一般来说都会看这个同学的潜力。\n重点看有没有什么 demo 或者业余参与过开源项目，甚至是一些分享或者看源码。还有是怎么学习的。\n做过的一些项目，小 demo 是有深度的，这样话还是可以进来。\n在团队中也有不是科班出生的，具体看硬实力如何，还是可以接受的。\n\n问：面试过程中，面试者提出哪些问题能带来好感？\n\n在面试过程中，有一些同学会问我一些技术点，但是我不推荐问这个，因为技术点都是可以查到的。\n最好是问一些开放性的问题，团队负责的业务时什么？然后团队未来的发展方向是什么？\n或者问面试官一些给自己的建议。\n\n问：新进的团队 Leader 可以如何做好团队管理？\n\n第一点尽快和团队的同学建立连接，产生彼此的信任。\n明确这个团队的一些规则，就是这个团队的要和不要。\n帮助这个团队找到明确方向，获取更多的业务输入，知道团队现状，然后定制团队日后的方向。\n给团队中的每一个人找到自己的赛道，然后让每个人在业务支撑的过程中拿到业务结果和技术的积累，然后可以阶段性的到回报，可以是技术提升，绩效上的，或者是综合能力的提升。\n\n问：你在研究自己性格探索自己的时候是怎么改变的？去挑战自己最大的恐惧，想问问你是怎么克服的？\n\n当你真正意思到你自己必须去改变了，如果不改变未来就只有一个结果了，碌碌无为。\n内心信念感和目标感有没有？如果你有一个去阿里的目标，那就从一个想法落实到行为这样一个改变。\n\n问：多次听到需要 Github 的积累，一般是哪一些方面的积累呢？\n\n文章和项目都是一部分\n比如说 Github 上有很多一些面试的面经，大家都可以去刷一刷\n但是上面的内容都是比较浅显的，都是需要我们在这个基础上做一些扩张和加上自己的思考\n然后在项目中沉淀下来变成自己的东西，在通过自己的话说出来让别人你是真的有去实现过的\n\n问：技术产出方面有没有自己的日计划，周计划或者月计划？怎么督促自己去学习的？\n\n我自己的技术产出计划是跟着项目走的，比如说一个项目它的周期是一个月或者一个季度的情况下，那我就会在项目的最后的复盘阶段去做一些梳理，包括我在这个项目当中经历了一些什么，当初遇到的困难和一些知识点。最后以文档的形式记录下来。\n\n问：女性开发者想转管理岗位，那么日常需要培养哪些方面，或者说有哪些一职业规划上的知道意见？\n\n这个问题背后是女性比起男生的优势在哪里呢？女生是心更细的，女生在人上的感觉是更好的，在现在社会上没有绝对的男女之间的差异性哈。\n如果说女性网管理岗位走，你要在管理岗位上解决什么问题？是带着这个团队去把商业行为给做好，首先你需要对这个业务的理解能力，需要做什么事情能让这个业务更好，走的更远，你需要一个什么样的团队，给团队提要求，需要什么人，这些人大概要什么样的水平。需要构建什么能力，搭建一个什么系统，最后能把这个业务描述出来。\n这个只是当下的一个切面哈，然后长期往前走的时候，怎么把这个团队的人的战斗力提升起来，团队的技术选型是什么？团队成长空间在哪里？才能留得住人，或者才能招更多的人进来。\n在事情上，切面后往前推进了，人往前推进，事也要往前推进。今天这个事情做的好不好，线上监控，反馈渠道，数据化，产品化的东西都要往前推进。\n综合来看的话，我们发现往管理岗走，技术就可以放下了，这个其实是有个误区的。如果今天你的技术这块放下了，对业务的判断，对技术的判断，对团队成长的建议就可能会更不上。做管理也有阶段性的时候自己要针对性的去补知识。所以不建议做管理时过早的去放弃技术的。\n今天在技术的基础上，要求做管理有更多的人上和横向的能力，像沟通能力，项目能力，对业务的认知能力等等。\n\n问：现在前端技术日新月异，有很多知识学过之后又没有怎么使用，过了一两个月就基本上忘了，针对这种情况有没有什么好的建议？\n\n这个是一个很好的问题，不只是对你们，甚至对我自己也是这样子的。\n有的时候前端还是挺残忍的，发展那么快，学的东西那么多。\n其实这个就有点像一个武器库一样，各式各样好的武器都有。今天一个好的前端工程师是不见的要把所有武器都需要会用的。\n有几个建议：\n当下你的业务，你的团队需要你拥有什么样的能力，那就先去练这一部分能力。为什么呢？因为这个能力不是空学的，因为空学太难了，是学了之后就能用的，可以投入实战的，通过实战结合业务去加强，很多项目中就可以用了，知识就真的变成自己的了。就不会学会了不能用，过一段时间就忘了。\n结合兴趣和目标，比如说今天在做 React 的一些事情，但是我以后就一定要做游戏，我一定要去做 Node。如果今天你有带着这种目标感，带着这种个人兴趣去做想做的事情，那就做做开源项目，或者做做私人项目模仿着去做项目。肯定是需要去做去用的，不能只是理论。今天我们不能够什么都想学，或者贪多。最后发现什么都没有学好，我们一定要学好了就能用，结合着业务或者自己的兴趣去做的。\n时间轴上的，一个人的精力是非常有限的，不可能什么都能做的很好。那是一定有取舍的，那么取舍就是当下阶段做什么，第二个阶段做什么，第三个阶段做什么，要这样一个方式去学。然后需要阶段性进行总结，看看最近学习的效果怎么样，如果有效果就坚持，如果没有效果就要复盘，找到为什么没有效果，一定要找问题。通过反思和总结才能知道从我强力意愿去学习到落地到行动，中间有没有变形，自己有没有真的去做到。\n\n\n\n\n「四」推荐书籍\n\n《JavaScript设计模式》\n\n\n出版社：人民邮电出版社\n作者：张容铭\n推荐理由：此书以一个小白为视角，通过各种场景引出设计模式的使用，比较舍和刚接触设计模式的小伙伴。\n\n\n\n\n《超越CSS》—— Web 设计艺术精髓\n\n\n出版社：人民邮电出版社\n作者：Andy Clarke\n推荐理由：“人会失败，会死去，但思想会永远留下来。”“时间的流逝，并不影响本书对 HTML 结构、CSS 样式深刻理解和优雅应用的智慧高光。本书在代码的艺术思维及审美高度，并非 Well Done 而是更高阶的 Beyond。”\n\n\n\n\n《重构》—— 改善既有代码的设计\n\n\n出版社：人民邮电出版社\n作者：马丁·福勒（Martin Fowler）\n推荐理由：“必须谨记，为代码建立必要的单元测试，怎么强调都不过分。 在提取方法时，对变量的处理需要慎之又慎，特别当方法体中存在多个变量，且需要改变其值时。 自以为是的技术高手常喜欢改动大段代码，而不是审慎地按照小步骤进行，这总是会给他们带来麻烦。”\n\n\n\n\n《贝叶斯思维》—— 统计建模的Python学习法\n\n\n出版社：人民邮电出版社\n作者：[美] Allen B. Downey（艾伦·唐尼）\n推荐理由：“贝叶斯思维让我们在开发或者思考为题上有更好的思维逻辑方式，学习统计方法能够让我们对问题&#x2F;需求解耦，去整理思路是一个非常有帮助。”\n\n\n\n\n《为什么》—— 关于因果关系的新科学\n\n\n出版社：中信出版集团股份有限公司\n作者：[美] 朱迪亚·珀尔(Judea Pearl) &#x2F; [美] 达纳·麦肯齐(Dana Mackenzie)\n推荐理由：“是一本非常有价值和融合了非常多学科的书，从生物学到则学到计算机科学到人工资能都包含。锻炼我们的思维方式的。”\n\n\n\n\n《系统之美》—— 决策者的系统思考\n\n\n出版社：浙江人民出版社\n作者：[美] 德内拉·梅多斯\n推荐理由：“一本大智慧的书，教你用系统理论思考和分析问题。我很多年前度过一遍，虽然已经忘记了内容，但已永远改变了我。”\n\n\n\n\n《影响力》—— INFLUENCE\n\n\n出版社：万卷出版公司\n作者：罗伯特•B•西奥迪尼 (Robert B. Cialdini)\n推荐理由：“不管是在生活还是工作当中，影响力的作用无处不在。合理地运用影响力，能够有效地促成合作，减少冲突，从而顺利高效地达到目标。《影响力》总结了打造影响力的几个关键因素，如互惠、承诺与一致、权威、短缺、喜好等。如果你在思索如何提升自己的技术影响力、团队影响力、组织影响力，那么，在本书中可能有你想要的答案。”\n\n\n\n\n《深入理解计算机系统》—— 原书第3版\n\n\n出版社：机械工业出版社\n作者：Randal E.Bryant &#x2F; David O’Hallaron\n推荐理由：“前端是一个技能，不要把他当做一个角色，希望前端同学能够多掌握一些计算机系统知识，做一专多能的人才！”\n\n\n\n\n《横向领导力》—— 不是主管，如何带人成事？\n\n\n出版社：北京联合出版公司·后浪出版公司\n作者：[美]罗杰·费希尔（Roger Fisher） &#x2F; 艾伦·夏普（Alan Sharp）\n推荐理由：“只有“一把手”才能领导是职场最大的误区，只懂自己带人可以维持团队绩效，让每个员工都懂得带人才能成倍提升团队执行力！就算是神一样的管理者，也带不好猪一样的员工。培养员工的横向领导意识，促使员工主动参与团队建设，才能把整个团队拧成一股绳，爆发惊人的战斗力。”\n\n\n\n\n《授权》—— 如何激发全员领导力\n\n\n出版社：中信出版社\n作者：[美] L.大卫·马凯特\n推荐理由：“领导力是一种释放人类才智和潜能的艺术。你也许可以通过金钱、职位、权力或胁迫获取某人的支持，但是才智、激情、忠诚和顽强拼搏的精神只能建立在个人意愿的前提下。无论你处于组织系统的哪个位置，你都需要阅读本书。”\n\n\n\n\n《金字塔原理》—— 思考、表达和解决问题的逻辑\n\n\n出版社：南海出版公司\n作者：[美]芭芭拉•明托\n推荐理由：“介绍了一种能清晰地展现思路的高效方法，是训练思考、使表达呈现逻辑性的实用宝典。金字塔原理能将零散的观点有序组织起来，化繁为简，适合所有需要精进思考、分析、表达能力的读者。”\n\n\n\n\n《金字塔原理》—— 心智成熟的旅程\n\n\n出版社：吉林文史出版社\n作者：[美] 斯科特·派克\n推荐理由：“人生会有很多磨砺，是一个不断修炼的过程。如果你是一个渴望成熟的人，或者正在遭遇人生的挫折，那么你可能会需要这本书。”\n\n\n\n「终」总结编写这边文章的同时，我回去反复看了大会的所有录播和 PPT。发现看第二遍的时候获得了额外的收获和惊喜。有一些第一次听的时候没有 get 到的信息和知识，第二遍，第三遍的时候突然就浮现了。事实证明这次的 15 位讲师给我们带来的分享真的是有非常高的含金量。\n重新认识自己通过这次的大会，我明确找到了我和技术专家的知识和认知差距，也知道自己还有很多的不足，但是现在的我明确知道自己需要的是什么，想往哪里走。\n之前的自己过于执着与学习，看到新的技术和东西就迫不及待的去挖掘和实现。往往就忽略了什么才是自己真正热爱和想深挖的领域。从中就很容易迷失了自己的方向和消磨了自己有限的精力。\n甚至是技术以外的技能都是非常值得我们重视的，在这个大会中，“思辨”、“思维”、“思想”、“沟通”、“复盘”、“要性”、“原理”等知识都是被反复强调的。\n我们日常中也要实时的与业界保持密切的关注与思考，不能随便追捧和跟风。建立独立的思辨能力，强大的独立思维模式和空间。知识吸收到自己的体内后需要有独特的输出才真的是学会了一样东西。\n此刻的自己需要改变、坚持学习和沉淀自己。实力还需要继续稳步提升，让自己全速前进。望有一天能变得更优秀并且拥抱更大的挑战！\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"interview/big-company-interview-2020","date":"2020-06-04T07:48:56.000Z","categories_index":"Interview","tags_index":"Interview","author_index":"三钻"},{"id":"ad0611b4c903187b89bf658ce10afe51","title":"分析时间复杂度与空间复杂度","content":"\n\n\n\n\n\n\n\n\n本文是覃超老师的《算法训练营》的学习笔记，此笔记的内容包含了学习后的个人记录、个人总结、理解和思想。从而更好的学习算法。\n前言学习任何一门知识的时候，我们需要分析清楚这门知识的核心是什么，从而在这个核心中我们可以得到什么。如果我们是盲目的吸收知识，其实很多知识我们都是在目前场景、工作、生活中无法使用的。也是因为学习之后无法运用，所以我们很快就会遗忘，或者是在学习的过程中很容易就会放弃。\n\n\n\n\n\n\n\n\n\n在一生的学习的过程中，发现学习我们急需使用或者能给我们及时带来价值的知识，我们会学的更加牢固，更加能坚持学习。\n学习《数据结构与算法》这门知识的核心是什么？又能得到什么呢？\n\n弄懂编程的底层逻辑；\n在编程的过程中，拥有一个哆啦 A 梦一样百宝工具袋；\n在遇到性能问题的时候，有算法的思维逻辑和规则来解决问题；\n提高编程思维；\n\n这篇笔记记录了算法的核心时间和空间复杂度，《数据结构与算法》都是围绕着这个核心开展的。它的存在也是为了解决我们在编程的过程中性能问题，同时也让我们有更高级的思维和思路，写出更优质的程序。\n\n复杂度指标 Big O Notation\nO (1): 常数复杂度 - Constant Complexity\nO (log n): 对数复杂度 - Logarithmic Complexity\nO (n): 线性复杂度 - Linear Complexity\nO (n^2): 平方复杂度 - N square Complexity\nO (2^n): 指数 - Exponential Growth\nO (n!): 阶乘 - Factorial\n\n如何看时间复杂度\n分析函数；\n根据 n 的不同情况会运行多少次；\n最后得出一个平均的运行次数的量级；\n\nComplexity 例子O (1) - 常数复杂度\nlet n &#x3D; 1000\nconsole.log(&#39;Hello - your input is: &#39; + n)\n\nO (N) - 线性复杂度\nfor (let i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n  console.log(&#39;Hello world - your input is: &#39; + i)\n&#125;\n\nO (N^2)\nfor (let i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n  for (let j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n    console.log(&#39;Hello world - your input is: &#39; + i + &#39; and &#39; + j)\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n那如果我们不是嵌套两层for循环，是把两个循环分开来存放呢？这种方式时间复杂度是？\nfor (let i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;\n  console.log(&#39;Hello world - your i input is: &#39; + i)\n&#125;\n\nfor (let j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n  console.log(&#39;Hello world - your j input is: &#39; + j)\n&#125;\n\n很多小伙伴应该猜到了，就是2* n次的复杂度，那就是**O(2n)**。其实还是O(n)的时间复杂度。\nO(log(n))\nfor (let i &#x3D; 1; i &lt; n; i &#x3D; i * 2) &#123;\n  console.log(&#39;Hello world - your input is: &#39; + i)\n&#125;\n\nO(k^n)\n&#x2F;&#x2F; Fibonacci递归\nfunction fib(n) &#123;\n  if (n &lt;&#x3D; 2) return n\n  return fib(n - 1) + fib(n - 2)\n&#125;\n\n\n时间复杂度曲线\ny轴是Operations就是操作复杂度的指数；\nx轴是Elements就是n我们的循环次数 ；\n这里我们可以看到在n比较小的时候，复杂度是相对稳定的；\n但是当n越来越大时，Big-O 复杂度就会急速飙升；\n\n\n\n\n\n\n\n\n\n\n所以在我们写程序的时候，如果能把时间和空间复杂度从O(n^2)降到O(n)或者O(1)后，我们得到的优化收益是非常高的！\n\n在编写程序的时候一定要注意到它的时间和空间复杂度，这样编写的时候就能预测出这段代码的性能级别；\n用最简洁的时间和空间复杂度完成这段程序；\n这样就是最顶尖的职业编程选手了；\n因为复杂度越高，程序损耗的时间（处理时间）和资源（内存）就越大；\n\n降低时间和空间复杂度我们用个例子就可以看到如何在编程中降低复杂度：\n\n\n\n\n\n\n\n\n\n计算：1 + 2 + 3 + … + n\n方法一： 循环 1 到 n 然后累加 (时间复杂度 O(n))\nlet sum &#x3D; 0\nfor (let i &#x3D; 1; i &lt; n; i++) &#123;\n  sum +&#x3D; i\n&#125;\nconsole.log(sum)\n\n方法二： 求和公式 sum = n(n+1)/2 (时间复杂度 O(1))\nlet sum &#x3D; (n * (n + 1)) &#x2F; 2\nconsole.log(sum)\n\n\n\n\n\n\n\n\n\n\n注意：\n\n在做题或者面试的时候先确认题目，确保一切的条件和题目的理解无误；\n想出所有可能的解决方案；\n同时比较每个方法的时间和空间复杂度；\n接下来找出最优的解决方案（时间最快，内存使用最少）\n\n判断时间和空间复杂度斐波那契（Fibonacci）例子\n\n\n\n\n\n\n\n\n\n公式：F(n) &#x3D; F(n - 1) + F(n - 2)\n我们可以直接使用递归来解题：\nfunction fib(n) &#123;\n  if (n &lt;&#x3D; 2) return n\n  return fib(n - 1) + fib(n - 2)\n&#125;\n\n\n这个fib斐波那契函数中是一个递归；\n每一次传入一个n值时，都会循环递归fib方法来一层一层往下计算；\n最后到达n小于 2，返回最后的n值；\n\n\n\n\n\n\n\n\n\n\n那针对这个递归，我们怎么计算它的时间复杂度呢？\n\n要推断出这个程序的复杂度，首先我们要知道具体在这个函数中程序做了什么；\n我们距离现在传入n为6，那就是运行fib(6)\n这个时候6被传入这个方法，然后返回的就是fib(5)+fib(4)，这时fib(5)和fib(4)就会再进入fib函数，这里就分开了两个分支了。以此类推我们就会出现以下一个树状过程：\n\n\n\n通过上图展开来的树，我们可以看到每一层是上一层的 2 倍：fib(6)展开为fib(5)+fib(4)，然后fib(5)和fib(4)又展开了两个。\n所以fibonacci的执行次数就是一个指数级 - O(2^n)\n这里我们也可以看到fib(3)、fib(4)等等，都被重复计算了多次，所以这个计算的复杂度高达 2 的 6 次方；\n所以在做题和面试的时候就不要运用上面的代码实例，我们要加入缓存机制，缓存重复计算的结果或者用一个循环来写，从而降低这个程序的复杂度。\n\n\n主定理 Master Theorem\n\n\n\n\n\n\n\n\n任何一个分治或者递归函数都可以通过这个定理来算出它们的时间复杂度。这个定理里面有 4 种最常用的，只要记住这 4 种就可以了。\n\n\n\n算法 (Algorithm)\n时间复杂度 (Run time)\n\n\n\n二分查找 (Binary search)\nO(log n)\n\n\n二叉树遍历 (Binary tree traversal)\nO(n)\n\n\n排序二维矩阵 (Optimal sorted matrix search)\nO(n)\n\n\n归并排序 (Merge sort)\nO(n log n)\n\n\n常见面试题\n二叉树遍历中的前序、中序、后序：时间复杂度是多少？\n时间复杂度是 O(n)，无论是前序、中序或者后序每一个节点都会访问一次，并且仅访问一次；\n所以就是二叉树的节点总数，也就是O(n)的线性时间复杂度；\n\n\n图的遍历：时间复杂度是多少？\n时间复杂也是O(n), 这里的n就是图里面的节点总数；\n\n\n搜索算法：DFS、BFS 时间复杂度是多少？\nDFS 是深度优先，BFS 是广度优先算法。\n不管是深度优先还是广度优先，因为访问的节点只访问一次，所以时间复杂度也是O(n)的。（n指的是搜索空间里面的节点总数）\n\n\n二分查找：时间复杂度是多少？\n答案是O(log n)\n\n\n\n\n总结\n程序复杂度：Big O Notation\n**O (1)，O(log n)**， O(n)，O(n^2), … 等等，越复杂程序性能越差；\n分析复杂度法则：分析代码的逻辑，找到程序中运行的次数；\n降低程序时间和空间复杂度可以提升代码的质量，同时优化程序的性能；\n\n\n主定理：\n所有的分治或者递归函数都可以通过主定理来分析出它的时间复杂度；\n\n\n常见面试题：\n二叉树遍历中的前序、中序、后序：时间复杂度是多少？ - O(n)\n图的遍历：时间复杂度是多少？ - O(n)\n搜索算法：DFS、BFS 时间复杂度是多少？ - O(n)\n二分查找：时间复杂度是多少？ - O(log n)\n\n\n\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n\n\n\n\n\n\n\n\n\n公众号《技术银河》回复”算法资料”，可以获得这个系列文章的PDF 版和其他资料！\n推荐专栏小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n","slug":"algorithm/algorithm-time-space-complexity","date":"2020-05-30T00:40:07.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Time Complexity,Space Complexity","author_index":"三钻"},{"id":"27e0b9ca4a5dda5c3deba327dc77f1c7","title":"如何高效学习数据结构与算法","content":"前言\n\n\n\n\n\n\n\n\n本文是个人基于覃超老师的《算法训练营》的学习笔记，此笔记的内容都是学习后的个人记录、个人总结、理解和思想。仅供参考学习。\n很多同学在大学的时候会觉得数据结构与算法很枯燥，很多小伙伴都不愿意听这门课程。甚至以前还觉得能开发一个项目就能成为一个合格的程序员。但是学会算法，或者接触过数据结构与算法后，发现懂这门知识的程序员编写出来的代码相对有更高的质量。代码的性能、写法、底层逻辑和解决问题的能力都会高于不懂数据结构与算法的程序员。\n到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。所以小时不学算法，长大掉头发。\n这系列的《算法学习笔记》，与大家一起重温或者学习数据结构与算法。\n\n\n\n\n\n\n\n\n\n这里也赠送大家一句话：\n“好记性不如烂笔头，好记性更不如好笔记“\n愿大家在技术银河中终身漂泊学习时，习惯编写自己的笔记，以后这些笔记必定成为我们最珍贵的宝藏！✨\n如何系统化学习算法深入到精通一门知识的我们都需要一个系统化的学习方法，如果这门知识越是有难度，前期就越是枯燥无味，或者甚至觉得很困难。所以学习算法也是一样的：\n\n枯燥无味\n所以需要系统化学习；\n小步快跑的方式进行学习；\n不懂就找答案不要埋头苦学；\n\n\n不牢固\n越是庞大的知识，越学就会越觉得之前学到的知识忘的差不多了；\n其实就是缺乏知识的稳固性；\n\n\n预习\n学习任何一门知识，都要先了解和预习这门知识；\n同理，在学习一门新的开发语言时，我们都会先来一个hello world；\n\n\n坚持 leetcode 刷题\n要学会算法，并且稳固这一门知识，不断的刻意练习是重中之重；\n\n\n\n\n系统化的效果系统化学习和拿起一本书最终的效果是不一样的。很多时候我们开始学习一门知识，我们都会看：《xxx 深入浅出》、《xxx 指南》和《从 0 到 1 学会 xxx》，其实里面的知识是很庞大的。只靠知识是无法支撑我们的实战和经验的，所以我们需要系统化的学习方法最终达到的目标也是不一样的，例如：\n\n提升到职业顶尖水平\n通过一线互联网大厂的面试\n要有 Leetcode 300+ 刷题量\n\n\n\n\n\n\n\n\n\n\n推荐阅读《Outliner》这本书中的学习方法\n\n精通一个领域前面说到，任何一个领域的知识都是很庞大的。而且只靠看书，看文章学习都是不够的。所以一套好的学习方法，可以为我们打开一扇大门。而且在打开这扇大门的同时不会因为艰苦、困难、煎熬或者是枯燥而最后放弃。\n\n切碎知识点 Chunk it up\n庖丁解牛\n脉络相连 - 从根部开始学习，到分支，再到树叶。让每一个知识点都有关联关系\n\n\n刻意练习 Deliberate Practicing\n反馈 Feedback\n\n\n数据结构有什么？\n一维：\n基础： 数组 array (string)，链表 linked list\n高级：栈 stack，队列 queue， 双端队列 duque，集合 set，映射 map (hash or map)，等等\n\n\n二维：\n基础：树 tree, 图 graph\n高级：二叉搜索树 binary search tree（红黑树 red-black tree, AVL），堆 heap，并查集 disjoint set，字典树 Trie\n\n\n特殊：\n位运算 Bitwise，步隆过滤器 BloomFilter\nLRU Cache (缓存)\n\n\n\n\n参考：覃超老师的《数据库脑图》\n\n\n算法有什么？任何的高级算法与数据结构都会转换成 If Else，for 循环，其实也是最朴素的计算机的知识，没有什么 AI，人工智能的知识。高级算法重点是找到重复单元。\n\n跳转语句 (Branch) ：If-else，switch\n循环 (Iteration) ：for, which，while loop\n递归 (Recursion) ： Divide &amp; Conquer, Backtrace\n搜索 (Search) ：深度优先搜索 Depth first search，广度优先搜索 Breadth first search，启发式搜索 A*\n动态规划 (Dynamic Programming)\n二分查找 (Binary Search)\n贪心 (Greedy)\n数学 (Math)，几何 (Geometry)\n\n\n参考：覃超老师的《算法脑图》\n\n\n刻意练习 - Deliberate practice无论是科学家、国家运动员、技术专家还是游戏职业选手，他们的优秀的背后都有一个共同点：刻意练习。\n什么是刻意练习？\n\n刻意练习 - 过遍数，持续多边形的练习，用数遍达到质变！（五毒神掌）；\n练习不擅长的地方；\n如果感到不舒服、不爽、枯燥的话，那证明我们正在爬坡，正在提升！\n\n\n反馈 - Feedback很多时候在学习中，特别是在自学的过程，我们永远不知道自己的学习的成果是怎么样的。或者我们有时候会遇到难点但是无法突破，甚至有时候我们以为自己很努力，或者已经很强了。但是其实还只是坐井观天而已。所以我们在学习的时候需要反馈。所谓的反馈有几种：\n\n即时反馈\n学会使用一门语言；\n能写出能执行的代码；\n能写出一个项目；\n能实现一个功能；\n\n\n主动型反馈\n高手代码（Github、LeetCode）；\n第一视角止步（看视频，看高手写的代码，学习思路）；\n\n\n被动式反馈（高手指点）\n代码审查 code review；\n例如：教练看你打，给你反馈；\n\n\n\n\n切题四件套我个人认为也可以叫解题四大法则：\n\n理解题目（Clarification）\n在 LeetCode 看题后，先思考，认真确认和理解题目；\n避免忽略了一些条件或者是误解题目；\n面试的时候更加应该跟面试官确认清楚题目、条件、场景等；\n\n\n多种解题方案（Possible solutions）\n对比时间和空间复杂度 compare (time&#x2F;spaace)\n最优解 optimal (加强)\n\n\n多编写（Coding）\n代码反复练习和编写；\n每一种解法都反复练习和编写；\n\n\n多测试案例（Test cases）\n在 LeetCode 上可以改变测试案例；\n多测试几种案例，确保自己的代码可以适应各种特殊情况；\n\n\n\n\n刷题方式（五毒神掌）第一遍\n5 分钟：读题 + 思考；\n5 分钟过后，没有思路就直接看解法；\n记录多个解题方法，比较解题方法的优弊；\n尝试默写代码，训练刻意手写代码；\n\n第二遍\n自己编写，这时候就不要再看题解了；\nLeetCode 提交代码，确保能通过；\n有 Bug 没有关系，重复 debug 到通过为止；\n编写出多种解题方法；\n持续优化 - 重点是 执行时间 （可参考 LeetCode 中打败了多少的人，也可以点击比较优秀的人，学习更好的写法）；\n\n第三遍\n过了一天后，再重复做题；\n根据自己不熟悉的题目与程度做专项练习；\n专项练习就是针对自己不熟悉的种类的题，从而刻意练习哪一种题；\n\n第四篇\n过了一周后，再反复练习；\n\n第五遍\n面试前，提前 2-3 周开始重复练习；\n\n\n总结这篇笔记中，我们记录了一下关键知识重点点：\n\n如何深入学习一门知识\n通过系统化学习一门知识；\n最高效和持续的学习算法就是通过系统化的学习；\n这里推荐大家，真的想学好一个技术，最好的方法就是找对老师，找对课程，找对人；\n\n\n如何攻破庞大的知识体系变成编程职业高手\n切碎知识点与建立脉络\n刻意练习\n反馈\n\n\n数据结构中有什么？ - 看脑图\n算法中有什么？- 看脑图\n算法练习方法\n切题四件套\n五毒神掌\n\n\n\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中和你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n\n\n\n\n\n\n\n\n\n公众号《技术银河》回复”算法资料”可以获得 PDF 版和脑图资料！\n推荐阅读\n📖《分析时间与空间复杂度《三钻数据结构与算法笔记》》 — 算法的核心时间和空间复杂度，《数据结构与算法》都是围绕着这个核心开展的。它的存在也是为了解决我们在编程的过程中性能问题，同时也让我们有更高级的思维和思路，写出更优质的程序。\n\n📖《28 关学会 HTML 与 HTML5 基础》 — 一个系列的文章和大家一起闯关进攻前端全方位知识点。没有闯过这些关卡的童鞋，无论前端能力如何，这个可以锻炼我们自己，也可以深入知道我们自己的前端水平和差距。想学习前端的童鞋可以从零开始学习，一起排除困难共同打开前端大门！\n\n📖《44 关深入浅出 CSS 基础之第一篇》 — 这周我们一起闯过了 22 关，下一期我们会一起把剩余的 22 关完成。学习是一种像爬山一样的过程，要经历过漫长的上坡路，一步一个脚印。“路漫漫其修远兮，吾将上下而求索。”， 在追寻知识的道路上，前方的道路还很漫长，但我们将百折不挠，不遗余力地，上天下地的去追求和探索。让我们继续坚持学习，终身学习成长。在大前端的时代爬到技术的巅峰，做一个有深度的技术人员。\n\n🔥《前端必看的 8 个 HTML+CSS 技巧》 — CSS 是一个很独特的语言。看起来非常简单，但是某种特殊效果看似简单，实现起来就颇有难度。这篇文章主要是给在学习前端的童鞋分享一些新的 CSS 技巧，一些在前端教程和培训课堂中不会讲到的知识。第二就是让还在前端开发这条道路上的童鞋们，重新燃起对前端排版和特效的热爱和热情！🔥\n\n\n","slug":"algorithm/algorithm-intro","date":"2020-05-23T23:30:44.000Z","categories_index":"Algorithm","tags_index":"Algorithm,Data Structure","author_index":"三钻"},{"id":"bd92dfb9f447e77ff3cfdd5b9c60a568","title":"44关学习CSS与CSS3基础「一」","content":"欢迎回来三钻的FCC前端教程，上一篇文章我们通过 28 关学会了 HTML 与 HTML5 网页开发基础。这一期我们一起攻破前端第二大知识点《CSS 基础入门》。因为这一课一共有 44 关，我把文章分成两期更新。敬请期待！\n「CSS 基础知识」Cascading Style Sheet缩写为 CSS，顾名思义就是层叠样式表的意思。CSS 是 HTML 中的一个样式表，告诉浏览器网页上的文字和其他内容是如何展示的。\n理解 CSS以上是一个官方的定义。我们用一个更简单的方式理解 CSS 到底是一个什么东东：\n\n\n\n\n\n\n\n\n\n如果 HTML 是骨架，那 CSS 就是装饰这个骨架的一层皮和身上的装饰品。我们可以通过 CSS 控制皮肤的颜色，毛孔的粗细。甚至还可以控制我们装饰品上的特效，动效等等（有 LED 灯的口罩也是一种特效）。\n回归 HTML 中的 CSS，我们可以使用 CSS 控制哪些东西呢？\n\ncolor：颜色\nfonts：字体\npositioning：定位\nspacing：间隙\nsizing：大小\ndecoration：装饰\ntransition：过渡&#x2F;特效&#x2F;动效\n\n应用方式\n\n\n\n\n\n\n\n\n我们一共有 3 种应用 CSS 样式的方法。\n\n我们可以在 HTML 元素行内的style中编写样式；\n在 HTML 文档中添加&lt;style&gt;标签，然后在标签内编写 CSS 代码；\n把 CSS 样式单独写入一个CSS样式文件，然后在需要使用的 HTML 文档中使用&lt;link&gt;引入。\n\n一般项目中都会选择使用第三种方式，因为比较大型的前端页面，很多样式都是有重复性的，应用引入型的 CSS 样式，我们就可以把通用的写在一起然后在所有 HTML 中引入即可，不需要重复编写。并且可以把 CSS分类存放，提高可读性和可维护性。\nCSS 原理CSS 背后的原理是，使用 CSS 选择器选中 DOM（文档对象模型）里面的某个 HTML 元素。然后将各种 CSS 样式和属性应用到该元素中，从而改变元素在页面中的展现方式或者样式。\n\n\n\n\n\n\n\n\n\n在本节中，我们将学会如何应用 CSS 样式到 CatPhotoApp 的元素中，从而将它从简单的文本装修成一个页面。让我们立即开始吧！\n\n「第一关」改变文字颜色\n\n\n\n\n\n\n\n\n关卡名：Change the Color of Text\n知识点\n我们这一关来尝试改变文本中一些文字的颜色；\n我们可以给h2元素添加style属性，然后使用样式属性改变文字颜色；\ncolor就是用来定义文字颜色的样式属性；\n\n以下例子演示如何给h2应用一个蓝色字体颜色的代码：\n&lt;h2 style&#x3D;&quot;color: blue;&quot;&gt;CatPhotoApp&lt;&#x2F;h2&gt;\n\n\n\n\n\n\n\n\n\n\n注意： 在行内样式中，所有样式属性结束后需要加上一个;符号，代表这一个样式属性定义结束。然后后面还可以加入更多的样式属性。\n过关目标\n改变h2的文字颜色为红色(red)；\n\n过关条件\nh2元素中需要有style属性；\nh2元素的color样式属性应该赋予red这个值；\nstyle属性值里的样式属性应该以;符号结束；\n\n学会了什么？这关卡主要教会我们：\n\n行内添加style样式属性;\n字体颜色样式属性color;\n\n\n答案\n\n「第二关」使用 CSS 选择器改变元素样式\n\n\n\n\n\n\n\n\n关卡名：Change the Color of Text\n知识点\nCSS 有几百种样式属性可应用到一个 HTML 元素中，来改变它在页面中的显示方式。\n上一关编写的&lt;h2 style=&quot;color: red;&quot;&gt;CatPhotoApp&lt;/h2&gt;，这里我们使用行内样式，使用了文字颜色样式来单独改变h2元素中的文字。\n这种应用方式只能单独针对 HTML 中某一个元素进行样式影响，但是更好的方式是使用 CSS 样式表。\n\n在代码的最顶端加入style标签：\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n在style中，使用CSS 选择器选中所有h2标签，并且给所有h2标签加入字体颜色样式属性color: red：\n&lt;style&gt;\n  h2 &#123;\n    color: red;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n\n\n\n\n\n\n\n\n注意： 选择器名中的样式元素必须用两个大括号包裹着 (开始&#123;与结束&#125;)。在样式属性的最后必须加入一个分号;来结束。\n过关目标\n删除h2行内样式;\n在代码顶部加入style样式表代码区;\n在样式代码区使用 CSS 选择器把所有h2元素内的字体改变为蓝色blue;\n\n过关条件\nh2元素中的style属性需要被移除；\n需要创建一个style元素；\nh2元素中的文字应该是蓝色blue的；\n样式表中的样式属性都应该遵循规范，有大括号和结束时的分号；\nstyle元素有接受标签；\n\n学会了什么？这关卡主要教会我们：\n\n使用style元素\nCSS 样式元素规范\n\n\n答案\n\n「第三关」使用 CSS 类\n\n\n\n\n\n\n\n\n关卡名：Use a CSS Class to Style an Element\n知识点\nCSS 中的类是为了解决服用样式的问题；\n\n类声明例子：\n&lt;style&gt;\n  .blue-text &#123;\n    color: blue;\n  &#125;\n&lt;&#x2F;style&gt;\n\n\n在style元素中我们编写了一个.blue-textCSS 类（CSS 类需要在我们的名字前加入.符号, 然后 CSS 类的命名规范必须使用-分割）；\n接着我们可以把这个类加入 HTML 元素中，比如：&lt;h2 class=&quot;blue-text&quot;&gt;CatPhotoApp&lt;/h2&gt;；\n只要给我们需要应用字体颜色为蓝色的 HTML 元素上加入class=&quot;blue-text&quot;，即可获得该 CSS 类的样式属性。\n记住在 HTML 中加入类，是不需要.这个符号在最前面的。\n\n过关目标\n在style元素中，把h2CSS 选择器改为.red-text；\n并且把颜色值从blue改为red;\n\n过关条件\nh2元素的问题应该是红色的；\nh2元素应该拥有一个red-text的类；\nstyle样式表中有定义一个.red-text，并且样式属性color的值为red;\n不允许在h2中使用行内style属性来改变元素的字体颜色；\n\n学会了什么？这关卡主要教会我们：\n\n在 CSS 样式表中定义类；\n在 HTML 元素中加入类；\n用类改变 HTML 元素的样式；\n\n\n答案\n\n「第四关」使用 CSS 类改变多个元素样式\n\n\n\n\n\n\n\n\n关卡名：Change the Color of Text\n知识点\n一个类可以赋予给多个元素，让所有被赋予同一个类的元素拥有同一套样式；\n\n\n\n\n\n\n\n\n\n\n几年前twitter公司很火的前端框架bootstrap，就是结合很多这种分类好的的类，让我们在 HTML 元素中组合使用就可以快速布局网页。所以合理的分类好不同种类的类，然后给他们一种特定用途，有利于 CSS 开发时提高代码复用性，提高可读性和可维护性。\n过关目标\n给代码中第一个p元素也加入red-text类;\n\n过关条件\nh2元素的文字应该是红色；\nh2元素应该拥有一个red-text类属性；\n第一个p元素的内容应该是红色；\n第二和第三个p元素的内容颜色应该不是红色；\n第一个p元素应该拥有一个red-text类属性；\n\n学会了什么？这关卡主要教会我们：\n\n用类名对多个 HTML 元素赋予同一个样式；\n\n\n答案\n\n「第五关」改变文字大小\n\n\n\n\n\n\n\n\n关卡名：Change the Color of Text\n知识点\n字体大小是font-size样式属性控制的；\n\nh1 &#123;\n  font-size: 30px;\n&#125;\n\n过关目标\n在style元素中，.red-text下方加入p元素选择器；\n在p选择器中加入font-size样式属性，并且把值设置为16px（16 像素）；\n\n过关条件\n在style元素中为p元素的内容的字体改为16px的大小；\n\n学会了什么？这关卡主要教会我们：\n\n改变元素字体大小；\n\n\n答案\n\n「第六关」改变元素字体\n\n\n\n\n\n\n\n\n关卡名：Set the Font Family of an Element\n知识点\n使用font-family样式属性，我们可以定义一个元素所使用的字体；\n举例，如果我们想h2元素使用sans-serif字体，在 CSS 中需要这么些：\n\nh2 &#123;\n  font-family: sans-serif;\n&#125;\n\n过关目标\n让所有p元素使用monospace字体；\n\n过关条件\n所有p元素都使用monospace字体；\n\n学会了什么？这关卡主要教会我们：\n\n使用 CSS 样式属性制定元素使用的字体；\n\n\n答案\n\n「第七关」引入 Google 字体\n\n\n\n\n\n\n\n\n关卡名：Import a Google Font\n知识点\n在我们的操作系统中，会有很多通用的字体可以使用。但是除了这些字体之外我们还可以引入自定义字体，也叫web fonts网页字体。\n在项目中，有一些设计师会使用一些特殊的字体，主要是为了提高整体页面的美观和协调，这种也是非常常见的。\n这个时候我们就需要在 HTML 中引入字体了。\n这个关卡我们使用了Google Fonts库（顾名思义，就是使用谷歌公司提供的公开字体库 - 也就是免费使用的）\n\n\n\n\n\n\n\n\n\n\n注意： 如果我们无法访问谷歌字体的话，这一关是无法过的，只能跳过。但是作为开发人员，我们是有办法的。（你们懂的 😂）\n\n要引入谷歌字体，我们只需要在 HTML 中加入谷歌字体的 URL；\n这个关卡中我们需要引入谷歌字体库中的Lobster字体；\n我们只需要复制黏贴以下代码，加入到我们代码的顶端即可（如果是在正常的 HTML 文件格式中，就是加入到&lt;meta&gt;&lt;/meta&gt;标签之中）；\n\n&lt;link\n  href&#x3D;&quot;https:&#x2F;&#x2F;fonts.googleapis.com&#x2F;css?family&#x3D;Lobster&quot;\n  rel&#x3D;&quot;stylesheet&quot;\n  type&#x3D;&quot;text&#x2F;css&quot;\n&#x2F;&gt;\n\n\n现在我们可以在 CSS 中使用font-family: Lobster;, font-family字体属性值的格式是: font-family: FAMILY_NAME, GENERIC_NAME;;\n里面的FAMILY_NAME就是指定的字体名，如果这个字体找不到，或者语言不适应的话，就会往后面定义的字体进行应用；\n换言之GENERIC_NAME就是后备字体，可以用,分割输入多个，这个也会在下一关详细解说；\n如果我们的字体名中含有空格，那我们就需要用双引号包裹着，例如：&quot;Open Sans&quot;。因为Lobster这个字体不存在这种情况，所以不需要使用双引号；\n\n过关目标\n创建一个font-familyCSS 规则，并且使用Lobster字体。必须保证我们的h2元素应用了这个字体定义。\n\n过关条件\n引入了谷歌字体库中的Lobster字体；\nh2元素中的字体使用了Lobster字体；\n使用h2CSS 选择器的来改变字体；\n其他p元素应该保持原来的monospace字体；\n\n学会了什么？这关卡主要教会我们：\n\n引入谷歌字体;\n使用谷歌字体;\n\n\n答案\n\n「第八关」定义字体如何往后取用\n\n\n\n\n\n\n\n\n关卡名：Specify How Fonts Should Degrade\n知识点\n浏览器中有好几个可用的默认的字体，最普通的字体有：monospace, serif 和 sans-serif；\n当一个字体不存在或者无法使用时，我们可以告诉浏览器“往后取用”下一个指定的字体；\n举例：如果Helvetic作为我们的默认字体，当这个字体无法使用的时候自动往后选择使用sans-serif字体，这种场景我们就需要用以下方式：\n\np &#123;\n  font-family: Helvetica, sans-serif;\n&#125;\n\nGeneric font family的字体名是没有大小写限制的，只要名字正确就可以了。并且不需要双引号，因为它们是 CSS 关键词而已。\n过关目标\n首先给h2追加monospace字体，让h2元素拥有默认字体为Lobster，备用自己为monospace；\n上一关卡，我们使用link标签引入了谷歌字体库中的Lobster字体。这里我们注释掉这个引用，从而Lobster这个字体就变成无法使用了，所以h2元素中就会往后取用monospcae字体；\n\n\n\n\n\n\n\n\n\n\n注意： 如果我们的电脑中安装了Lobster字体，那这个例子中的Lobster字体是可用的，自然就无法看到浏览器往后取用的效果了。\n过关条件\nh2元素使用Lobster字体；\n当Lobster字体无法使用时，h2元素应该往后取用monospace字体；\n注释掉谷歌字体库的引用，在link标签的签名加入&lt;!--和在结尾加入--&gt;；\n注释的结尾必须有--&gt;；\n\n学会了什么？这关卡主要教会我们：\n\n给 HTML 元素追加后备字体；\n\n\n答案\n\n「第九关」控制图片大小\n\n\n\n\n\n\n\n\n关卡名：Size Your Images\n知识点\nCSS 中有一个样式属性叫width（宽度），顾名思义这个元素是用来控制元素的宽度的；\n与字体大小一样，我们使用px（像素）为单位来定义图片的宽度\n举例：如果我们创建一个 CSS 类larger-image，并且使用这个类来把 HTML 元素的宽度定义为 500 像素，我们就用以下写法：\n\n&lt;style&gt;\n  .larger-image &#123;\n    width: 500px;\n  &#125;\n&lt;&#x2F;style&gt;\n\n过关目标\n创建一个smaller-image的 CSS 类，并且用这个类来缩小一个图片的大小为 100 像素宽；\n\n\n\n\n\n\n\n\n\n\n注意：因为浏览器的设置，有一些用户会默认把网页放大缩小了，不是默认的 100%。如果是的话，请还原 100%伸缩值后才能正常通过此关哦！\n过关条件\nimg元素需要有smaller-imge类；\nimg元素应该是100px宽，并且浏览器缩放是在 100%；\n\n学会了什么？这关卡主要教会我们：\n\n控制元素宽度\n\n\n答案\n\n「第十关」添加元素边框\n\n\n\n\n\n\n\n\n关卡名：Add Borders Around Your Elements\n知识点\nCSS 边框有这些属性：style, color 和 width；\n举例：如果我们想给一个 HTML 元素创建一个红色的，5 像素边框，我们就需要用这样一个 CSS 类来实现；\n\n&lt;style&gt;\n  .thin-red-border &#123;\n    border-color: red;\n    border-width: 5px;\n    border-style: solid;\n  &#125;\n&lt;&#x2F;style&gt;\n\n还有一种更简单快捷的写法：\n&lt;style&gt;\n.thin-red-border &#123;\n  border: 5px red solid;\n&#125;\n&lt;&#x2F;style&gt;\n\n过关目标\n创建一个类叫thick-green-border；\n这个 CSS 类给 HTML 元素加入一个 10px，实线（solid）和绿色（green）的边框；\n给我们的猫咪图片加入这个类；\n\n\n\n\n\n\n\n\n\n\n记住：我们是可以给 HTML 元素中的class属性添加多个类，只要使用空格分隔即可。如：&lt;img class=&quot;class1 class2&quot;&gt;\n过关条件\nimg元素需要有smaller-imge类；\nimg元素需要有thick-green-border类；\n图片应有一个 10px 宽的边框；\n图片应有一个实线的边框样式；\n图片应有一个绿色的边框样式；\n\n学会了什么？这关卡主要教会我们：\n\n给元素添加边框；\n给边框加入宽度，线的样式和颜色；\n\n\n答案\n\n「第十一关」使用 border-radius 实现圆边\n\n\n\n\n\n\n\n\n关卡名：Add Rounded Corners with border-radius\n知识点\n我们的喵咪图片现在是直角边的；\n我们可以使用border-radius把图片的四个角改圆边；\n\n过关目标\n我们可以给border-radius一个弧度像素值；\n现在给我们的猫咪图片一个10px的border-radius；\n\n\n\n\n\n\n\n\n\n\n注意：这一关中，是有多个接单方案的：\n\n在.thick-green-border中添加border-radius；\n在.smaller-image中添加border-radius；\n\n过关条件\nimg元素需要有thick-green-border类；\n图片应有一个 10px 的边框弧度；\n\n学会了什么？这关卡主要教会我们：\n\n给属性边框弧度；\n\n\n答案\n\n「第十二关」实现圆形图片\n\n\n\n\n\n\n\n\n关卡名：Make Circular Images with a border-radius\n知识点\nCSS 的border-radius属性不止可以使用像素为单位，我们还可以使用百分比；\n\n过关目标\n给我们的猫咪图片一个50%的border-radius；\n\n过关条件\n图片应有一个50%的边框弧度；\n图片的边框弧度必须是一个百分比值50%；\n\n学会了什么？这关卡主要教会我们：\n\n给元素添加百分比弧度值；\n\n\n答案\n\n「第十三关」给元素一个背景颜色\n\n\n\n\n\n\n\n\n关卡名：Give a Background Color to a div Element\n知识点\n我们可以使用background-color属性来设置一个元素的背景颜色；\n举例：如果我们想给一个元素绿色（green）的背景，我们就要给予这个元素一个background-color属性；\n\n.green-background &#123;\n  background-color: green;\n&#125;\n\n过关目标Create a class called silver-background with the background-color of silver. Assign this class to your div element.\n\n创建一个 CSS 类silver-background，其中加入background-color属性和属性值为silver；\n然后把这个类加入到div元素的class属性中；\n\n过关条件\ndiv元素应有一个silver-background类；\ndiv元素应有银色（silver）背景颜色；\nstyle标签中应该有一个.silver-background类选择器，并且有background-color属性和属性值为silver；\n\n学会了什么？这关卡主要教会我们：\n\n给元素添加背景颜色；\n\n\n答案\n\n「第十四关」给元素 ID 值\n\n\n\n\n\n\n\n\n关卡名：Set the id of an Element\n知识点\n除了classCSS 类属性，我们还可以给每一个 HTML 元素一个id属性；\nid属性是有好几个实用的用途的：我们可以用id选择器来给一个元素 CSS 样式属性，同时也可以让 JavaScript 找到指定id的元素，并且对此进行修改等；\n记住，id属性的属性值应该是唯一的；\n浏览器不会强制要求id的唯一性，但是在实践中被广大认可id是需要唯一的，所以不要在多个一个元素中赋予同一个id属性；\n\n举例：在我们的h2元素中添加一个id属性cat-photo-app：\n&lt;h2 id&#x3D;&quot;cat-photo-app&quot;&gt;&lt;&#x2F;h2&gt;\n\n过关目标\n给form元素添加一个id属性值cat-photo-form；\n\n过关条件\n表格元素中需要有个id属性值为cat-photo-form；\n\n学会了什么？这关卡主要教会我们：\n\n给元素添加id属性；\n\n\n答案\n\n「第十五关」使用 ID 更改元素样式\n\n\n\n\n\n\n\n\n关卡名：Use an id Attribute to Style an Element\n知识点\nid属性与 CSS 类一样可以为他们绑上 CSS 样式；\n但是区别是id是无法复用，只能给予一个元素（源自于我们上一关所说的原因）；\n在权重之中id在样式表中相对比 CSS 类，它有更好的权重，如果class和id的样式同时给予一个元素，那id的样式会覆盖类的样式；\n\n举例：我们现在给一个id属性为cat-photo-element，然后给这个id属性在样式表中绑定一个背景颜色background-color为绿色green。\n#cat-photo-element &#123;\n  background-color: green;\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意：在我们的样式表&lt;style&gt;中，我们用. + 类名来声明类的样式，但是如果是id的话我们会用# + id名来声明id的样式。\n过关目标\n现在尝试给我们的form元素一个id属性，属性值为cat-photo-form；\n并且在样式表中给予这个id一个绿色（green）的背景颜色；\n\n过关条件\nform元素中应有一个id属性为cat-photo-form；\nform元素的背景颜色应该是绿色的；\nform元素应有id属性；\nform元素中不能有class或者style；\n\n学会了什么？这关卡主要教会我们：\n\n使用id属性；\n在样式表中声明id属性的样式；\n\n\n答案\n\n「第十六关」给元素添加内边距\n\n\n\n\n\n\n\n\n关卡名：Adjust the Padding of an Element\n知识点\n我们把 Cat Photo App 放一边，先来学习更多的 HTML 样式；\n可能大家都注意到了，HTML 的元素基本上都是一个个像积木一样的正方形盒子组成的；\n在排版中最常用的三大属性，它们是用来控制 HTML 元素之间的空隙的：padding（内边距），margin（外边距）和border（ 边框）；\n一个元素的padding，控制一个元素内容四边的空间，还有内容与border边框的距离；\n在预览区中的蓝色与红色盒子被包裹在一个黄色盒子之中，我们应该注意到，红色盒子的padding比蓝色盒子的边距要宽；\n\n如果想更深入的理解内容与margin，padding和border之间距离，我们需要一个更好的图解方式，请看下图：\n\n上图中有 3 组颜色，从内到外：蓝色是content(内容部分)，绿色部分是padding(内边距)，黄色部分是border(边框)，最外面的橙色部分是margin(外边距)。通过这个图，我们就能清晰理解这些边距的实际产生的距离的效果。\n\n这里我们可以看到，当我们加大蓝色盒子的padding，盒子内容里面的字体与边框的距离就越远；\n\n过关目标Change the padding of your blue box to match that of your red box.\n\n改变蓝色盒子的padding，从而让蓝色盒子与红色盒子的padding一致；\n\n过关条件\n蓝色盒子的padding应改为20px；\n\n学会了什么？这关卡主要教会我们：\n\n使用padding（内边距），margin（外边距）和border(边框)；\n\n\n答案\n\n「第十七关」调整元素外边距\n\n\n\n\n\n\n\n\n关卡名：Adjust the Margin of an Element\n知识点\n一个元素的margin(外边距)，控制这个元素与周围元素之间的空间；\n所以我们可以看到黄色盒子内的蓝色盒子与红色盒子，红色盒子拥有一个更大的margin，同时让红色盒子看起来更小了；\n当我们加大蓝色盒子的margin的时候，也会看到同等的变化。因为蓝色盒子与周边元素的间距会加大，同时蓝色盒子的content内容可以用的空间就需要伸缩适应。最后蓝色盒子就会变小了；\n\n为了更好的理解为什么内容区域宽高会变动，我们先来看看红色盒子的空间信息：\n\n首先这个例子中，红色盒子的content内容区域是没有给宽高的，所以会根据浏览器窗口大小适应。也就是说，内容区域是一个弹性宽高盒子。这个时候我们给了20px的padding，5px的border，20px的margin。那盒子的总宽高是多少？\n这个时候盒子的总宽高 &#x3D; content宽高 + padding + border + margin 对吧？\n假设现在浏览器窗口的宽度是1000px，这里我们先假设外层没有一个黄色盒子，这个红色盒子可以填满这个浏览器宽度。这个时候红色盒子的content宽度就是:\n\n\n\n\n\n\n\n\n\n1000 - 20*2 (左右的margin外边距) - 5*2(左右的border边框) - 20*2(左右的padding内边距) &#x3D; 910px。\n如果现在我把浏览器窗口变成 800px 呢？安装刚刚的公式我们会得出 710px，对内容部分少了 200px。\n好了按照我们刚刚的公式，现在浏览器窗口宽度不变，只把margin外边距加大，这个时候内容是不是也会变？因为最终内容区域的大小都是受到margin，border和padding的总额所影响的？所以在上面的例子里面我们发现加大了蓝色盒子的margin后，蓝色盒子显然是变小了。因为我们加大了margin。\n同时也是因为我们看到的盒子大小是基于盒子的边框，不是真的在看盒子的content内容部分。\n\n如果我们给盒子一个宽高后，我们加大padding时盒子就会变大。甚至有时候在排版的过程中，使用padding就会发现盒子会超出了父级的元素盒子。这里我们可以深入解说一下**CSS 中的两种盒模型**：\n盒模型：标准盒模型\n\n盒子宽度 &#x3D; 内容的宽度\n盒子高度 &#x3D; 内容的高度\n\n\n\n\n\n\n\n\n\n\n其他间距都是额外加入的，会影响盒子总体呈现的宽高\n\n\n\n\n\n\n\n\n\n\n如果不希望使用盒子的padding的时候影响盒子总体大小，我们就要把盒子变成IE盒模型\n在盒子的 CSS 中添加box-sizing: border-box\n盒模型：IE盒模型\n\n盒子宽度 &#x3D; border + padding + 内容的宽度\n盒子高度 &#x3D; border + padding + 内容的高度\n\n\n\n\n\n\n\n\n\n\n盒子的框高包含了边框和内边距，所以整体的盒子高度不受padding和border影响。\n\n过关目标\n改变蓝色盒子的margin，从而让蓝色盒子和红色盒子又一样的展示效果；\n\n过关条件\nblue-box类应有20px的margin；\n\n学会了什么？这关卡主要教会我们：\n\nmargin的使用；\npadding对盒子的宽高的影响；\n标准盒模型和IE盒模型；\n\n\n答案\n\n「第十八关」给元素负外边框\n\n\n\n\n\n\n\n\n关卡名：Add a Negative Margin to an Element\n知识点\n一个元素的margin控制它的周边与它的边框之间的空隙；\n如果我们给一个元素一个负数的margin，这个元素会变大；\n\n\n\n\n\n\n\n\n\n\n所以给一个元素负margin就会变大？是，也不是！但是为什么呢？margin是外边框，不应该会对元素的内容产生大小变动呀？\n要回答这个疑问，我们首先来看看改为负margin之前和之后是怎么样的：\n\n\n\n首先第一最外层的黄色盒子没有定义宽高，所以它是自适应浏览器窗口宽高；\n第二我们没有给蓝色盒子定义宽高，所以它的内容宽高也是跟随着父级宽高；\n蓝色盒子原本的margin是20px，那盒子的宽度就是149 (内容) + 20+20 (左右内边距) + 5+5 (左右边框) &#x3D; 199px，最后还有左右的20px的margin；\n蓝色黑子换成了margin为-15px后，这时宽度就是 219 (内容) + 20+20 (左右内边距) + 5+5 (左右边框) &#x3D; 269px，最后左右的-15px的margin；\n以上就是最后在浏览器的盒子属性的区别，这两个之中哪个的数值变了呢？对内容的宽度变了！为什么呢？\n219 - 149 &#x3D; 70px，那这 70 像素的增加是从哪里来的呢？\n对的！就是-15px和20px的区别。因为蓝色盒子没有定义宽度，所以宽度是自适应的。从左右负 15 来算一共给这个盒子左右各增加了 15 像素的空间。然后原本是 20 像素的边框现在没有了，所以另外再加了左右 20 像素的距离。一共就是15+15+20+20 &#x3D; 70。就是这样我们的内容就多了70px的宽度，所以蓝色盒子总体来说是不是宽度扩大了70px呢？懂了！\n\n\n\n\n\n\n\n\n\n\n问题来了，为什么刚刚说给一个元素的margin变化时，会，也不会导致元素放大呢？主要原因是因为我们这个例子中的蓝色盒子没有给宽度。如果给了宽度，盒子正数的margin和负数margin都不会影响这个盒子的宽的。所以只有当这个盒子的宽度是自适应的时候才会导致盒子变大变小哦。\n过关目标\n给蓝色盒子一个负margin，让它与红色盒子的呈现样式一样；\n把蓝色盒子的margin改为-15px，从而让蓝色盒子与红色盒子一样占了黄色盒子的总宽度；\n\n过关条件\nblue-gox的类应有一个-15px的margin；\n\n学会了什么？这关卡主要教会我们：\n\n给元素负margin；\n\n\n答案\n\n「第十九关」给元素每个边缘不同的内边距\n\n\n\n\n\n\n\n\n关卡名：Add Different Padding to Each Side of an Element\n知识点\n有时候我们需要自定义一个元素，并且要给一个元素每个边缘一个不同的padding；\nCSS 让我们可以控制一个元素 4 个边的内边距，控制的属性分别是：padding-top (上)、padding-right (右)、padding-bottom (下)和padding-left (左)；\n\n过关目标\n给予我们蓝色盒子的顶部与左边40px的padding, 然后底部和右边20px；\n\n过关条件\nblue-box类中应有40px的padding-top；\nblue-box类中应有20px的padding-right；\nblue-box类中应有20px的padding-bottom；\nblue-box类中应有40px的padding-left；\n\n学会了什么？这关卡主要教会我们：\n\n单独给每一个边缘不同的内边距；\n\n\n答案\n\n「第二十关」给元素每个边缘不同的外边距\n\n\n\n\n\n\n\n\n关卡名：Add Different Margins to Each Side of an Element\n知识点\n有时候我们需要自定义一个元素，并且要给一个元素每个边缘一个不同的margin；\nCSS 让我们可以控制一个元素 4 个边的外边距，控制的属性分别是：margin-top (上)、margin-right (右)、margin-bottom (下)和margin-left (左)；\n\n过关目标\n给予我们蓝色盒子的顶部与左边40px的margin, 然后底部和右边20px；\n\n过关条件\nblue-box类中应有40px的margin-top；\nblue-box类中应有20px的margin-right；\nblue-box类中应有20px的margin-bottom；\nblue-box类中应有40px的margin-left；\n\n学会了什么？这关卡主要教会我们：\n\n单独给每一个边缘不同的外边距；\n\n\n答案\n\n「第二十一关」使用顺时针语法指定元素内边距\n\n\n\n\n\n\n\n\n关卡名：Use Clockwise Notation to Specify the Padding of an Element\n知识点\n除了使用padding-top (上)、padding-right (右)、padding-bottom (下)和padding-left (左)来给一个元素特定的内边距；\n我们还可以在一行内写完一个元素的出内边距：padding: 10px 20px 10px 20px;；\n这里面的四个数值顺时针的从上到左旋转来分配的：上，右，下，左；\n\n其他语法：\n&#x2F;* 应用于四个边 *&#x2F;\npadding: 1em;\n\n&#x2F;* 垂直方向| 水平方向*&#x2F;\npadding: 5% 10%;\n\n&#x2F;* 顶部| 水平方向| 底部*&#x2F;\npadding: 1em 2em 2em;\n\n&#x2F;* 顶部| 右边| 底部| 左边*&#x2F;\npadding: 2px 1em 0 1em;\n\n过关目标\n顺时针语法指定.blue-box类的顶部和左边padding为40px，然后底部和右边padding为20px；\n\n过关条件\nblue-box类中应有40px的顶部padding；\nblue-box类中应有20px的右边padding；\nblue-box类中应有20px的底部padding；\nblue-box类中应有40px的左边padding；\n使用顺时针语法来分配padding；\n\n学会了什么？这关卡主要教会我们：\n\n使用顺时针语法给元素分配内边距；\n\n\n答案\n\n「第二十二关」使用顺时针语法指定元素外边距\n\n\n\n\n\n\n\n\n关卡名：Use Clockwise Notation to Specify the Margin of an Element\n知识点\n除了padding可以使用顺时针语法，margin也一样可以；\n除了使用margin-top (上)、margin-right (右)、margin-bottom (下)和margin-left (左)来给一个元素特定的外边距；\n我们还可以在一行内写完一个元素的出外边距：margin: 10px 20px 10px 20px;；\n这里面的四个数值顺时针的从上到左旋转来分配的：上，右，下，左；\n\n其他语法：\nmargin: 5%; &#x2F;* 所有的边都是 5% 的边距 *&#x2F;\n\nmargin: 10px; &#x2F;* 所有的边都是 10像素 的边距 *&#x2F;\n\nmargin: 1.6em 20px; &#x2F;* 上和下边是 1.6字距, 左和右是 20像素 边距 *&#x2F;\n\nmargin: 10px 3% 1em; &#x2F;* 上边 10像素, 左和右 3%, 下边 1字距 边距 *&#x2F;\n\nmargin: 10px 3px 30px 5px; &#x2F;* 上边 10像素, 右边 3像素, bottom 30px, left 5px margin *&#x2F;\n\nmargin: 1em auto; &#x2F;* 上和下边 1字距 边距, 该盒子是水平居中的 *&#x2F;\n\nmargin: auto; &#x2F;* 该盒子是水平居中的, 上下边距为0 *&#x2F;\n\n\n\n\n\n\n\n\n\n\n在现代浏览器中，如果要把一些东西水平居中，使用 display:flex; justify-content: center; .\n然而, 在一些老的浏览器，如 IE8-9, 这些是不可用的. 想要把一个元素在其父元素中居中, 使用 margin: 0 auto;\n过关目标\n顺时针语法指定.blue-box类的顶部和左边margin为40px，然后底部和右边margin为20px；\n\n过关条件\nblue-box类中应有40px的顶部margin；\nblue-box类中应有20px的右边margin；\nblue-box类中应有20px的底部margin；\nblue-box类中应有40px的左边margin；\n使用顺时针语法来分配margin；\n\n学会了什么？这关卡主要教会我们：\n\n使用顺时针语法给元素分配外边距；\n\n\n答案\n\n「待续」总结\n这周我们一起闯过了 22 关，下一期我们会一起把剩余的 22 关完成。学习是一种像爬山一样的过程，要经历过漫长的上坡路，一步一个脚印。“路漫漫其修远兮，吾将上下而求索。”， 在追寻知识的道路上，前方的道路还很漫长，但我们将百折不挠，不遗余力地，上天下地的去追求和探索。让我们继续坚持学习，终身学习成长。在大前端的时代爬到技术的巅峰，做一个有深度的技术人员。\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等和你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n系列阅读\n🔥《勇闯 28 个关卡学会 HTML 与 HTML5 基础》 — 这周我们一起闯过了 22 关，下一期我们会一起把剩余的 22 关完成。学习是一种像爬山一样的过程，要经历过漫长的上坡路，一步一个脚印。“路漫漫其修远兮，吾将上下而求索。”， 在追寻知识的道路上，前方的道路还很漫长，但我们将百折不挠，不遗余力地，上天下地的去追求和探索。让我们继续坚持学习，终身学习成长。在大前端的时代爬到技术的巅峰，做一个有深度的技术人员。\n\n推荐阅读\n🔥《前端必看的 8 个 HTML+CSS 技巧》 — CSS 是一个很独特的语言。看起来非常简单，但是某种特殊效果看似简单，实现起来就颇有难度。这篇文章主要是给在学习前端的童鞋分享一些新的 CSS 技巧，一些在前端教程和培训课堂中不会讲到的知识。第二就是让还在前端开发这条道路上的童鞋们，重新燃起对前端排版和特效的热爱和热情！\n🔥《带你体验 Vue2 和 Vue3 开发组件有什么区别》 — 使用 Vue2 和 Vue3 开发一个简单的表格组件来展示一下 Vue2 和 Vue3 开发组件的区别。看完这文章后，你将会有一个概念 Vue2 和 Vue3 开发组件时的区别，并且为 Vue3 的开发之路做好准备。\n\n","slug":"frontend/fcc-css3-basics-1","date":"2020-05-17T15:02:46.000Z","categories_index":"FrontEnd","tags_index":"HTML&CSS,Free Code Camp","author_index":"三钻"},{"id":"9538a9b5abca2d63aa9a99e5cbde9d10","title":"28关学会HTML与HTML5基础","content":"「经历」我自学前端已经有 6 年多了，自问当时学前端是没有系统化学习的。一开始边看文档，连滚带爬学 HTML 和 CSS 排版，然后深入研究 JavaScript，因为当时最火的就是 JQuery，所以用了很长一段时间的 JQ。\n到了后面遇到有一个项目需要我做 APP 开发，但是不可能去学 IOS 开发和安卓开发，因为项目时间也不可能给我们这么充裕的学习时间。所以当时的我深入分析了几个混合 APP 开发的框架。分析对象包括当时基于 AngularJs 的 Ionic 框架和 React Native。综合考虑最后选择了 Ionic，然后自学了 Angular2。（过程也是踩过成千上万的坑学会的）\nAPP 开发的这个过程让我深入感觉到那时候前端的革命性变化。庞大的前端知识扑面而来，也没有想到前端已经发展到这样一个地步。这段时间让我深刻领会到前端的博大精深，并且被前端这个技术领域深深的吸引住了。\n到了后面 Vue 突然开始火了，各大技术公司都开始使用 Vue+Cli 脚手架搭建前端应用。越来越多的企业要求使用 Vue 开发前端应用和 WebAPP。热爱前端的我从来不畏惧需要学更多的知识，既然 Vue 来势汹汹，我也开始深入研究和学习 Vue 开发前端。经过一番折腾 Vue 也上手了。\n至今我依然在不停的学习前端无边无际的知识和技术。\n最近我发现，现在学习技术容易了很多。有各种技术文章、手摸手教学、线上培训课程和视频，甚至还有全免费的线上学习课程和练习。相比以前从看文档，连滚带爬的在项目中试错式的学习真的是容易多了。\n\n「前言」我们都深刻知道，如果想在前端走的更远更久，基础知识必须是要牢固的。最近发现一个免费学习编程的网站 freeCodeCamp(🔥) - 官方版（英文） ｜ 中文社区版 。我好学的性格牵动着我的灵魂，忍不住就去研究了一下。我发现里面的课程确实很全面，而且还有实时和实战编程练习。就算是对于零基础的童鞋，也是可以开始学习编程的。\n在一个夜深人静的夜晚，我看着电脑思考人生的时候，我灵机一动，要不我开始写一个系列的文章和大家一起闯关进攻前端全方位知识点。没有闯过这些关卡的童鞋，无论前端能力如何，这个可以锻炼我们自己，也可以深入知道我们自己的前端水平和差距。想学习前端的童鞋可以从零开始学习，一起排除困难共同打开前端大门！\n使用这个免费网站学习编程，每一个知识学习完成后会给大家发放一个证书，然后每一个关键学习点之后，还有项目实战。自从 2014 年，有超过 4 万个freeCodeCamp毕业的童鞋获得了大企业工作机会。（里面有提到谷歌，苹果，微软，亚马逊，Spotify 等公司）\n还有看到一些学员的评价：\n\n\n\n\n\n\n\n\n\n\n“我在实习的时候，导师就叮嘱我在 freeCodeCamp 上做题闯关。技术的精进不仅给了我强大的自信，也让我得以进入大厂 ThoughtWorks。” — 姜玉珍\n“对于还没有形成编程思维的新人，即使是 leetcode 上面 easy 级别的算法题目都感到非常有难度，而 freeCodeCamp 的算法题恰好是一个良好的过渡。” — 魏朝欣\n\n无论这些证书是否对我们在中国的企业有一定的价值。但是能获得多一个证书，没有什么不好的呀。废话不多说了，我们这里就开始勇闯第一课《基础 HTML 与 HTML5 入门》！\n\n「规则」如何一起闯关在开始这个闯关的系列之前，讲一下我们具体怎么一起闯关。\n\n\n\n\n\n\n\n\n\n首先，如果我是单纯在这里给大家发布答案，我觉得这些文章就没有太大意义了。所以我希望在闯关的过程中一起学习到更多的知识，弄懂更深层的技术和用我的相关经验讲说这些知识在工作中的使用场景和小技巧。\n\n个人觉得英文版本的操作和体验都更好，加上英文版本的课题会更新。所以我会在英文版中与大家一起闯关。但是喜欢用中文社区版本也是可以的哦。酸甜苦辣各有所爱，但是效果和课题基本都是一样的哈。\n每一篇文章的大概内容：\n\n首先我们每一篇文章会尽量包含一个大知识点中的 N 个关卡。每一个知识点的关卡数量不一，所以有时候可能会拆分成几篇文章来讲说。\n每一个关卡当中的知识点在 freeCodeCamp 中有一定的知识材料。但是在一起闯关的文章当中也会做一些详细的知识补充和一些有趣的理解方式。\n每一个较难的关卡，都会在文章当中做详细的思路，多种实现方式等等的讲说，让我们在每一个关卡中能带走更多深层的知识点。\n\n\nfreeCodeCamp 使用教程\n课程内容FCC 一共有 6 大课程，一共大约 1800 个小时的内容和练习。如果是新人，推荐从第一个开始一个一个闯关学习。如果是老司机，是来这里学习你需要的知识，那可以随意选择你需要的课程开始学习。\n\n响应式 Web 设计（300 个小时）\n算法和数据结构（300 个小时）\n前端库和框架（300 个小时）\n数据可视化（300 个小时）\nAPI 和微服务（300 个小时）\n信息安全和质量保证（300 个小时）\n\n最后还有一个是数千个小时的面试题可以提供给我们使劲的刷哦！\n\n进入关卡首先我们展开第一课看一下：\n\n\n第 1 点这里是基础知识的文章，可以点击查看。看完基础知识之后可以点击下方的回到第一小节开始闯关！\n第 2 点这里下面所有的都是练习题，一个一个顺着闯关即可。\n\n\n关卡教程\n\n\n\n\n\n\n\n\n⚠️ 注意：大家闯关之前，推荐大家都先使用 GitHub 登陆，到时候颁发的证书和闯关进度才能得到保存和跟踪哦！！！\n我们先从左边 👈 部分的内容开始说明：\n\n简单讲说了这个关卡涉及的知识点\n描述关卡的挑战内容\n本关卡的所有目标，点击测试代码的时候，完成的会出现 ✅，没有全部 ✅ 那就是还有部分我们没有实现哦。所有 ✅ 才能通关。\n\n\n接下来就是说明中间的代码区：\n\n代码区，用于编写我们这个关卡的代码。\n错误输出区域，当我们点击测试代码后，如果有错误就会显示在这里。\n\n\n最后，最右边的部分是代码被编译后的效果，也就是我们在代码去编写的代码最终会在浏览器呈现出来的效果哦。（这里的效果会在我们编写代码的同时触发变化哦！）\n\n提交代码&#x2F;测试成功后：\n\n\n「知识」闯关基础知识点\n\n\n\n\n\n\n\n\nHTML 是什么？HTML 的全称是 HyperText Markup Language（超文本标签语言），它是一种用来描述网页结构的标签语言。它采用一种特殊的语法或符号来组织网页的内容，元素通常都有开始标签和结束标签，例如标题、段落、列表。\n更好的理解 HTML对于没有计算机基础的童鞋（就算是有）都会觉得有点抽象，不太好理解。我们换一个说法来理解一下：\n\n\n\n\n\n\n\n\n\nHTML 就等同于我们人体里面的骨架，一块一块骨头（标签）组装起来建立起一个人的骨架和结构。比如说经常可以见到的head，body，footer等标签，就等同于一个人的头，身体和脚。那其他的标签比如h1，h2，div，section和ul，li等标签就是用来组建我们人体每一个部位的小骨头。\n\n\n如果 HTML 加上了 JavaScript（人体中的大脑和肌肉）就可以操控整个人的动作，让一个人活起来了。但是只有骨头和肌肉，这个也太难看了吧？想想都觉得吓人。所以我们会有皮肤来把这些不太好看的东西藏起来，这个时候就需要在 HTML 中使用 CSS（人体的皮肤）。这样子我们有好的皮肤加上衣服和化妆品的打扮，这样才可以貌美如花嘛对吧？\n\n\n如果我们上面说的骨头和骨架，在代码中又是什么样子的呢？我们一起来看看：\n&lt;h1&gt;Top level heading: Maybe a page title&lt;&#x2F;h1&gt;\n\n&lt;p&gt;\n  A paragraph of text. Some information we would like to communicate to the\n  viewer. This can be as long or short as we would like.\n&lt;&#x2F;p&gt;\n\n&lt;ol&gt;\n  &lt;li&gt;Number one on the list&lt;&#x2F;li&gt;\n  &lt;li&gt;Number two&lt;&#x2F;li&gt;\n  &lt;li&gt;A third item&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\n这段代码被编译后就会在浏览器呈现出这个样子：\n\nHTML5 又是什么？HTML 这种超文本源自于 Web 早期和最初的用例。当时页面都是静态文档，并且文档中也有连接和引用到其他的文档。通过浏览器中的 hypertext links（超文本链接）在文档之中跳转与导航。这样用户就可以自由的在文档之中翱翔，不用在文档直接搜索查看。\n后期 web 页面和 web 应用渐渐变得越来越复杂，W3C 更新了 HTML 的规范来让所有的浏览器更加兼容彼此。为什么呢？大家应该都知道市面上有五花八门的各种浏览器，如果每一个浏览器都对 HTML 有不同的写法，不同的规范，那我们做前端开发的，有多少的浏览器规范我们就需要学会多少种写法。不用后浪推上来，已经累死在沙滩上了。\n那 HTML5 其实就是第五版的 HTML 规范，也是目前最新的版本。\n基础知识弄懂了，我们马上就来开始闯关吧！GO GO GO！\n\n「第一关」用 HTML 元素与世界问好\n\n\n\n\n\n\n\n\n关卡名：Say Hello to HTML Elements\n身在技术领域的童鞋们都知道，入门任何语言的开头都是先与世界问个好（所谓的输出一个”Hello World”）。所以第一关当然是用 HTML 元素与世界问好啦！😂\n知识点\n这一关我们看到代码区域有&lt;h1&gt;hello&lt;/h1&gt;这一段代码，这个就是所谓的 HTML 元素了！也就是人体中的一小块骨头 🦴！。\nHTML 中每一个标签都需要开始与结束标签：&lt;h1&gt; 为开始，&lt;/h1&gt; 为结束。\n开始与结束标签的区别，就是结束标签多了/（斜杠）。\n\n过关目标\n修改开始标签&lt;h1&gt;与关闭标签&lt;/h1&gt;之间的内容。\n把内容从Hello改为Hello World。\n\n学会了什么？这关卡主要教会我们：\n\nHTML 中的开始与结束标签的格式与规范\n标签的内容是什么\n如何修改标签内容\n\n\n答案\n\n「第二关」使用 H2 元素加入副标题\n\n\n\n\n\n\n\n\n关卡名：Headline with the h2 Element\n接下来的几个关卡中，我们会慢慢的一步一步的搭建一个 HTML5 的 “猫星人图片的网页应用”。\n知识点\nh2元素是常用的副标题，其实就是比h1字体要小的标题，用过WPS或者word文档的童鞋应该秒懂了。\n这些标题标签会告诉浏览器去显示一些默认的标题样式\nh1一般用于网页大标题，而h2就是用于副标题。\n其实在 HTML 当中还有很多自带的标题元素，例如h3，h4，h5和h6，每一个代码一个等级的副标题，这里数字越大，标题的大小就越小哦。\n\n过关目标\n在h1标签后面（第二行）加入一个h2标签。\n并且在h2元素中加入CatPhotoApp的文字内容。\n\n过关条件\n创建一个h2元素\nh2元素必须有一个结束标签\nh2元素必须含有”CatPhotoApp“的文字内容\nh1元素必须含有”Hello World“的文字内容\n\n学会了什么？这关卡主要教会我们：\n\n什么是副标题\nHTML 有哪些副标题\n如何加入副标题\n\n\n答案\n\n「第三关」段落元素加入信息内容\n\n\n\n\n\n\n\n\n关卡名：Inform with the Paragraph Element\n知识点\np是paragragh（段落）的缩写，就是我们在写文章中的段落一样，一般都是用来放信息内容的。\n我们可以用&lt;p&gt;我是一个p标签&lt;/p&gt;，这样的方式来加入段落元素。\n\n过关目标\n在我们的h2元素下方加入p元素。\n在p元素的内容中加入文字”Hello Paragraph“。\n注意：HTML 的规范中说明，所有标签的英文字母都必须使用小写！\n\n过关条件\n代码中必须有一个规范的p元素。\np元素中必须含有文字”Hello Paragraph“。\np元素必须有一个结束标签。\n\n学会了什么？这关卡主要教会我们：\n\np元素是什么\n如何加入信息内容段落\n\n\n答案\n\n「第四关」加入“占位”文字\n\n\n\n\n\n\n\n\n关卡名：Fill in the Blank with Placeholder Text\n知识点\n开发者们用一个传统，就是在没有内容的时候，排版时都会用统一的占位文字“lorem ipsum text”。很多人很好奇，为什么都用这个？\n\n\n\n\n\n\n\n\n\n\nLorem ipsum 从 15 世纪开始就被广泛地使用在西方的印刷、设计领域中，在电脑排版盛行之后，这段被传统印刷产业使用几百年的无意义文字又再度流行。由于这段文字以“Lorem ipsum”起头，并且常被用于标题的测试中，所以一般称为 Lorem ipsum，简称为 Lipsum。\n\n原先大家以为这段拉丁文只是没有意义的组合，目的是让阅读者不要被文章内容所影响，而只专注于观察字型或版型，并借此填满空间。但根据美国拉丁学者 Richard McClintock 的研究，Lorem ipsum 原来起源于西赛罗《善恶之尽》（De finibus bonorum et malorum）第一章（Liber Primus）的 32、33 两节。\n\n这段占位文字用了 5 个世纪也是够长情的了，既然我们这些关卡是在搭建一个“猫星人”的应用，那么我们改为“kitty ipsum text”。😁\n\n过关目标\n把p元素的内容替换成这一段占位文字：“**Kitty ipsum dolor sit amet, shed everywhere shed everywhere stretching attack your ankles chase the red dot, hairball run catnip eat the grass sniff.**”\n\n过关条件\np元素需要含有“kitty ipsum text”的首几个单词。\n\n学会了什么？这关卡主要教会我们：\n\n什么是“lorem ipsum text”\n为什么“lorem ipsum text”经常用于设计和排版的占位文案\n\n\n答案\n\n「第五关」清除 HTML 代码注释\n\n\n\n\n\n\n\n\n关卡名：Uncomment HTML\n知识点\n代码注释是为了在代码中留下备注的一种常用写法。通常为了给自己和其他开发者留下有意义的备注，让大家可以更容易的懂得代码的作用或者含义。代码注释是不会影响代码的运行，或者是显示出来给到用户看到的。\n代码注释还有一个非常使用的目的，就是屏蔽代码。被注释的代码就不会被编译器运行，这样被注释的代码就不会生效了。\n不同语言有不同的注释写法，HTML 的注释写法开始是&lt;!--，结束使用--&gt;。例如：&lt;!-- &lt;p&gt; abc &lt;/p&gt; --&gt;。\n\n过关目标\n此关卡的代码都被注释掉了，所以所有的代码都没有生效。（预览区可以看到是空白的）\n我们需要清除掉这里的注释，让h1，h2和p元素生效。\n\n过关条件\n页面预览区需要可以看到h1元素内容\n页面预览区需要可以看到h2元素内容\n页面预览区需要可以看到p元素内容\n页面中没有遗漏结束注释标签--&gt;\n\n学会了什么？这关卡主要教会我们：\n\n什么是代码注释\n代码注释有什么作用\n如何清除代码注释\n\n\n答案\n\n「第六关」局部 HTML 代码注释\n\n\n\n\n\n\n\n\n关卡名：Comment out HTML\n知识点\n上一关我们看到可以把整个代码注释掉，但是其实很多时候我们可能需要注释掉局部的代码，或者是多段代码。\n使用方式也是一样的，在想开始注释的地方加入&lt;!---，然后结束的地方加入--&gt;。\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：在注释代码的时候要注意的一个点，HTML 的元素都是有开始与结束标签的，注释的过程中如果我们注释掉半个元素，那代码就会有结束没有开头了。这样是会报错的哦。同等概念，后面我们会学到，HTML 元素是可以加入属性的，属性也是无法单独注释的。\n过关目标\n注释掉整个h1元素和p元素，h2元素要生效。（也可以说页面上只能看到h2这个元素的效果）\n\n过关条件\nh1元素应该被注释掉，页面看不到该元素效果\np元素应该被注释掉，页面看不到该元素效果\n页面预览区需要可以看到h2元素内容\n每一段注释都应该有结束注释标签--&gt;\nh1，h2和p元素在代码中的顺序不能变\n\n学会了什么？这关卡主要教会我们：\n\n如何局部注释代码\n\n\n答案\n\n「第七关」删除 HTML 元素\n\n\n\n\n\n\n\n\n关卡名：Delete HTML Elements\n知识点\n场景：因为手机的屏幕高度可呈现的空间不多，所以我们要把h1元素删除掉。\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：删除代码和注释代码都有一个一样的原则。就是开始与结束的标签不能缺了其中之一，要不代码就会报错。所以删除元素的时候也要注意元素的开始与结束标签的完整性。\n过关目标\n删除掉代码中的h1元素，让我们的页面更加整洁和更有空间感。\n\n过关条件\nh1元素应该被完整的被删除\n页面预览区需要可以看到h2元素内容\n页面预览区需要可以看到p元素内容\n\n学会了什么？这关卡主要教会我们：\n\n如何正确的删除元素\n\n\n答案\n\n「第八关」HTML5 元素\n\n\n\n\n\n\n\n\n关卡名：Introduction to HTML5 Elements\n知识点\nHTML5 给我们带来了更多具备丰富代表性的 HTML 标签。这些标签包括main（主要内容）、header（头部）、footer（脚步）、nav（导航）、video（视频）、article（文章）、section（区域&#x2F;分段内容）和更多。\n这些标签给 HTML 的结构带来了更多可描述性的意义。就好像人体也有很多代表性的结构与区域名称，比如说：肱骨、股骨、腕骨、肩胛和不规则骨等等。\n人体的骨头要分类，也是为了让医生更好的在大量的骨头中找到或者描述到具体的那种骨头。那 HTML5 中的这些丰富的标签也是一样的。他们可以更好的帮助搜索引擎找到对应的内容，加入这些标签也让我们的网页做到更好的搜索引擎优化（SEO）。\n\n\n\n\n\n\n\n\n\n\n什么是搜素引擎？我们可以把搜索引擎看作是一本很大很大的书中的目录。我们想想在现代的互联网中，全世界有多少个网站或者网页应用？如果没有一个目录让我们可以搜索，我们怎么可以找到我们想看的内容或者网站？可以说基本是不可能的！\n\n搜索引擎怎么运作？那搜索引擎的目录是怎么生成的呢？这个世界有一种很厉害的虫，那就是”爬虫”。每天搜索引擎的公司会派出成千上万的爬虫军队出去，在互联网上到处找网站，然后进入每一个网站中阅读里面的内容。然后收集回来的内容会经过做过滤和分析，然后建立关键词等等，最后生成一个搜索目录。我们经常用的搜索引擎包括：百度搜索，谷歌搜索，搜狗搜素，360 搜素等等。\n用其中一个标签来举例，一个main元素中嵌套了两个子元素：\n&lt;main&gt;\n  &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;\n  &lt;p&gt;Hello Paragraph&lt;&#x2F;p&gt;\n&lt;&#x2F;main&gt;\n\n\n\n\n\n\n\n\n\n\n小贴士：这些 HTML5 的标签的作用和适用性会在后面的“Applied Accessibility（应用无障碍）”的课程中详细讲说。\n过关目标\n在原有的p元素下方添加一个新的p元素，并且加入这段内容Purr jump eat the grass rip the couch scratched sunbathe, shed everywhere rip the couch sleep in the sink fluffy fur catnip scratched.\n然后用一个main元素两个p元素包裹起来。\n\n过关条件\n应该有 2 个p元素，每个都有文字内容\n每个p元素都有结束标签\n第二个p元素的内容含有“Purr jump eat…”这段文字\n代码中必须含有main元素\nmain元素中必须含有两个p子元素\nmain元素开始必须在第一个p元素之前\nmain元素结束必须在第二个p元素之后\n\n学会了什么？这关卡主要教会我们：\n\n学到了更多丰富的 HTML5 标签\n学会使用main元素\n学会嵌套元素\n\n\n答案\n\n「第九关」网站中插入图片\n\n\n\n\n\n\n\n\n关卡名：Add Images to Your Website\n知识点\n我们可以通过使用img元素为我们的网页插入图片，然后使用元素中的src属性来指定图片地址。\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：img元素是不需要结束标签的，它是属于自动关闭型元素。\n\nW3C 规范中，所有img必须填写alt属性（alt 是“Alternative”的缩写，就是“替代”的意思）。当一个图片无法加载或者显示时，alt属性的值就会替代这个图片显示出来。\n另外alt对于搜索引擎优化是有一定的帮助的，因为这个属性是用来描述一个图片的。如果这个图片是一只猫，对于搜索引擎的爬虫会针对图片的 Alt 取得关于这个图片的描述。这样搜索引擎才能知道这个图片大概是什么。\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：\n\n如果图片是单纯为了装饰的，那alt就留空：alt=&quot;&quot;\n尽量不要在alt属性中加入特殊字符（或者符号），除非是必须的\n\n一个完整的img元素例子如下：\n&lt;img\n  src&#x3D;&quot;https:&#x2F;&#x2F;www.your-image-source.com&#x2F;your-image.jpg&quot;\n  alt&#x3D;&quot;Author standing on a beach with two thumbs up.&quot;\n&#x2F;&gt;\n\n过关目标\n在main元素中的p元素之前添加img元素。\nimg元素的src属性的值指向https://bit.ly/fcc-relaxing-cat\n给予img元素的alt属性一个合适的名字：比如“Kitty” (小猫咪的意思)\n\n过关条件\n页面中必须有一个img元素。\nimg元素中的src属性指向一个猫咪的图片地址。\nimg元素中的alt属性值不能为空。\n\n学会了什么？这关卡主要教会我们：\n\n如何使用img图片元素\n懂得使用src属性\n懂得使用alt属性\n\n\n答案\n\n「第十关」使用锚元素实现链接跳转\n\n\n\n\n\n\n\n\n关卡名：Link to External Pages with Anchor Elements\n知识点\n在 HTML 当中，a (锚) 元素是用于跳转页面，可以是内部页面或者是外部页面。（内部指的是本网站内的页面，外部指的是本网站以外的其他网站的页面。）\na 元素需要一个网页地址的属性叫href。也需要一个 anchor text（锚文字）：\n\n\n\n\n\n\n\n\n\n\n例如：&lt;a href=&quot;https://freecodecamp.org&quot;&gt;这个链接会跳转到 freecodecamp.org&lt;/a&gt;\n\n网页地址：https://freecodecamp.org\n锚文字（其实就是跳转链接的文案）：这个链接会跳转到 freecodecamp.org\n\n\n使用以上例子，在浏览器中就会显示一段文字链接 “这个链接会跳转到 freecodecamp.org”，点击该链接就会跳转到https://www.freecodecamp.org这个网址。\n\n\n\n\n\n\n\n\n\n\n额外知识点：以上例子讲说的是跳转外部链接，如果我想跳转当前网址的子页面呢？(所谓的内部跳转，但是其实还可以做到当前页面的位置跳转，这个下一个关卡就会学到咯！)\n\n比如现在我们当前的页面是”www.freecodecamp.org&quot;，我们的链接想跳转到“www.freecodecamp.org/learn”。\n这个时候我们的a元素的href属性可以这么写\n\n&lt;a href&#x3D;&quot;&#x2F;learn&quot;&gt;这个链接会跳转到 freecodecamp.org&#x2F;learn&lt;&#x2F;a&gt;\n\n过关目标\n创建一个a元素，链接文案为“cat photos”，并且指定跳转到http://freecatphotoapp.com\n\n过关条件\na元素的链接文案必须含有“cat photos”\na元素的跳转地址必须是http://freecatphotoapp.com。\na元素必须有结束标签。\n\n学会了什么？这关卡主要教会我们：\n\n如何在网页中添加链接\n懂得使用href属性\n懂得如何添加链接文案\n\n\n答案\n\n「第十一关」使用锚元素跳转内部页面区域\n\n\n\n\n\n\n\n\n关卡名：Link to Internal Sections of a Page with Anchor Elements\n知识点\na（锚）元素还可以用于跳转页面内部的特定区域。\n创建一个内部跳转链接，首先我们需要在href属性的值中绑定一个哈希符号#和一个唯一id属性。\nid属性是在 HTML 中任何一个元素都可以绑定的唯一标识。id属性可以给予一个元素一个唯一的识别名，让这个元素可以在 HTML 中被选择到。\n\n以下是一个内部跳转链接的例子，其中的...代表被省略的一段代码。\n&lt;a href&#x3D;&quot;#contacts-header&quot;&gt;Contacts&lt;&#x2F;a&gt;\n...\n&lt;h2 id&#x3D;&quot;contacts-header&quot;&gt;Contacts&lt;&#x2F;h2&gt;\n\n\n\n\n\n\n\n\n\n\n我们来分析一下这个例子：\n\n这里的h2元素被绑定了一个id属性，名字为“contacts-header”。\n我们的a元素链接的指定href跳转地址为#contacts-header。\n我们可以看到#后面的名字与h2的id值一致，就是这样点击这个链接的时候，页面就会移动到绑定了同一个名字的元素的位置。\n我们要注意的是id属性的值，在当前页面中必须是唯一的。\n\n\n\n\n\n\n\n\n\n\n知识点：在这个例子里面，我们可以看到a元素多了一个target属性。这个属性在链接中是非常常用的。我们经常用的各大电商平台，我们点击一个商品的链接都会打开一个新窗口，但是有一些链接就不会。这种就是用target属性控制的。\n\ntarget属性的常用值有：\n\n_blank：在新窗口中打开被链接文档。\n_self：默认。在相同的框架中打开被链接文档。\n_parent：在父框架集中打开被链接文档。\n_top：在整个窗口中打开被链接文档。\n_framename_：在指定的框架中打开被链接文档。\n\n过关目标\n修改我们的外部跳转链接的href属性为#footer，并且把链接的文案“cat photos”改为”Jump to Bottom”。\n移除target=&quot;_blank&quot;属性，因为这个属性会让我们的链接在全新的窗口打开这个跳转链接。\n最后在页面最底部的footer元素中添加id属性，属性值为”footer“。\n\n过关条件\n页面中必须含有一个锚元素\n页面中只有一个 footer 标签\na元素的href属性值必须是#footer\na元素必须没有target属性\na元素的链接文章应该是“Jump to Bottom”\nfooter元素的id属性值必须是”footer”\n\n学会了什么？这关卡主要教会我们：\n\n如何在网页中添加内部链接\n懂得使用id属性\n懂得使用哈希符号链接跳转\n\n\n答案\n\n「第十二关」文章中嵌套锚元素\n\n\n\n\n\n\n\n\n关卡名：Nest an Anchor Element within a Paragraph\n知识点\n我们可以在文字中添加链接：\n\n&lt;p&gt;\n  Here&#39;s a\n  &lt;a target&#x3D;&quot;_blank&quot; href&#x3D;&quot;http:&#x2F;&#x2F;freecodecamp.org&quot;&gt;link to freecodecamp.org&lt;&#x2F;a&gt;\n  for you to follow.\n&lt;&#x2F;p&gt;\n\n\n\n\n\n\n\n\n\n\n分析一下这个例子的实现原理：\n\n首先我们有一个文字段落&lt;p&gt;Here&#39;s a ... for you to follow.&lt;/p&gt;\n在这个文字段落中”…“的部分我们加入a (锚) 元素：&lt;a href=&quot;http://freecodecamp.org&quot;&gt; ... &lt;/a&gt;，这里我们用a元素包裹了”…“这个文字内容，这样这个文字内容就会变成一个链接，并且可点击跳转网页。（记住这里需要我们有开始&lt;a&gt;与结束&lt;/a&gt;标签，这样才能指定这个链接的开始与结束区域）\n这里a元素中加入target=&quot;_blank&quot;可以让链接在新窗口打开，href属性指定了跳转链接。\n最后”…”的内容在这个例子里面就是” link to freecodecamp.org”，也就是链接的文案（锚文字）。\n\n过关目标\n首先在main元素中加入一个新的p元素。\np元素中的文案写入”View more cat photos”。\n使用我们原来的a元素替换这段文案中的“cat photos”，从而把这段文案中的”cat photos”改为一个链接。\n\n过关条件\na元素的链接需要指定跳转”http://freecatphotoapp.com“\na元素的链接文案应该是“cat photos”\na元素需要被p元素包裹着，然后main元素中需要一共有 3 个p元素\na元素需要被新的p元素包裹着，不能是其他的p元素\np元素中必须含有“View more ” （more 后面需要含有一个空格）\na元素中不能含有“View more”等文字\n所有p元素必须有结束标签\n所有a元素必须有结束标签\n\n学会了什么？这关卡主要教会我们：\n\n在文章段落中添加链接\n\n\n答案\n\n「第十三关」使用哈希符号创建死链接\n\n\n\n\n\n\n\n\n关卡名：Make Dead Links Using the Hash Symbol\n知识点\n有时候我们需要添加一个死链接（顾名思义，就是一个点击后无效的链接，不会触发页面跳转）\n这种链接有几个用途，第一种在排版的过程中还不知道需要链接哪里，第二种就是后面这个链接交给 JavaScript 处理。（后面的 JavaScript 关卡中会讲到哦）\n\n代码例子：\n&lt;a href&#x3D;&quot;#&quot;&gt;死链接&lt;&#x2F;a&gt;\n\n过关目标\n当前的a元素中的href是指向一个链接地址”http://freecatphotoapp.com“\n把href属性值改为#，就可以把这个锚元素变成一个死链接\n这里还需要把target属性移除掉，要不还是会跳转页面的\n\n过关条件\na元素的href属性值是#，是一个死链接\n\n学会了什么？这关卡主要教会我们：\n\n用哈希符号创建死链接\n\n\n答案\n\n「第十四关」把图片变成链接\n\n\n\n\n\n\n\n\n关卡名：Turn an Image into a Link\n知识点\n我们可以通过用a元素包裹一个元素，让这个元素变成一个链接\n比较常用的一个例子就是使用a元素包裹一个img元素，这样就可以把一个图片变成一个链接。（也就是说，点击这个图片就可以跳转页面了）\n\n代码例子：\n&lt;a href&#x3D;&quot;#&quot;&gt;\n  &lt;img\n    src&#x3D;&quot;https:&#x2F;&#x2F;bit.ly&#x2F;fcc-running-cats&quot;\n    alt&#x3D;&quot;Three kittens running towards the camera.&quot;\n  &#x2F;&gt;\n&lt;&#x2F;a&gt;\n\n\n\n\n\n\n\n\n\n\n这个例子中，我们希望这个图片的链接是一个”死链接”，所以href属性的值需要使用#。\n过关目标\n用a元素包裹页面中的img元素\n改变后，我们在最右边的预览区把鼠标放到图片上方，我们可以看到我们的鼠标从一个“普通鼠标志”变成一个“点击手指的标志”\n\n过关条件\nimg元素需要包裹在a元素之中\n图片的链接必须是一个死链接\n所有的a元素必须有结束标签\n\n学会了什么？这关卡主要教会我们：\n\n给图片添加链接\n\n\n答案\n\n「第十五关」创建无序列表\n\n\n\n\n\n\n\n\n关卡名：Create a Bulleted Unordered List\n知识点\nHTML 当中有特殊的元素用于创建无序列表。\n无序列表需要使用ul元素包裹着多个li元素，开始标签为&lt;ul&gt;，结束标签为&lt;/ul&gt;。\n\n*代码例子：**\n&lt;ul&gt;\n  &lt;li&gt;牛奶&lt;&#x2F;li&gt;\n  &lt;li&gt;芝士&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n这段代码就会创建一个无序列表，列表内容有“牛奶”与“芝士”。\n过关目标\n移除代码中最后两个p元素。\n然后添加一个无序列表，列出 3 个喵咪喜爱的东西。\n\n过关条件\n创建一个ul元素\nul元素应该包裹着 3 个li元素\nul元素必须有结束标签\n所有li元素必须有结束标签\nli元素中必须有内容，也不能是只有空格\n\n学会了什么？这关卡主要教会我们：\n\n使用ul元素\n使用li元素\n创建无序列表\n\n\n答案\n\n「第十六关」创建有序列表\n\n\n\n\n\n\n\n\n关卡名：Create an Ordered List\n知识点\nHTML 当中还有一种叫有序列表（就是前面会按照 1，2，3，4… 以此类推）\n需要使用ol元素包裹着多个li元素，开始标签为&lt;ol&gt;，结束标签为&lt;/ol&gt;\n\n代码例子：\n&lt;ol&gt;\n  &lt;li&gt;肥猪&lt;&#x2F;li&gt;\n  &lt;li&gt;肥牛&lt;&#x2F;li&gt;\n&lt;&#x2F;ol&gt;\n\n以上这段代码会创建一个有序列表，有序的列出“肥猪”和“肥牛”。\n过关目标\n在“**Top 3 things cat hate:**”的p元素下方加入一个有序列表\n有序列表中列出 3 样喵咪讨厌的东西\n\n过关条件\n有一个有序列表列出 3 样喵咪讨厌的东西\n有一个无序列表列出 3 样喵咪喜欢的东西\n只有一个ul元素\n只有一个ol元素\nul元素中有 3 个li元素\nol元素中有 3 个li元素\n所有li元素必须有结束标签\n所有li元素的内容不能为空或者只有空格\n\n学会了什么？这关卡主要教会我们：\n\n使用ol元素\n创建有序列表\n\n\n答案\n\n「第十七关」创建文本输入框\n\n\n\n\n\n\n\n\n关卡名：Create a Text Field\n知识点接下来的几个关卡，我们一起来创建一个表单。\n\n\n\n\n\n\n\n\n\n什么是表单？\n表单就是一个网页端的表格，让用户在其中填写信息提交给我们保存起来。在办理事情的时候，我们经常会需要填写表格，然后提交给工作人员。在网络上填写表格也是一样的。用户在表单中填写表格，然后提交给我们保存起来，工作人员在后台管理系统就可以对这些表格进行处理了。\n\n一个表单就必定会有文字填写的地方，在 HTML 中我们会使用input元素来创建一个文本输入框，给到用户填写文字。\n\n代码例子：\n&lt;input type&#x3D;&quot;text&quot; &#x2F;&gt;\n\n\n\n\n\n\n\n\n\n\n知识点：\n\ninput元素是一个自我关闭型标签，所以不需要结束标签的。\ninput元素中有一个type属性，这个是用来定义这个输入框的类型，这里因为我们需要文本类型，所以就是text。那其他类型有什么呢？其他的类型在后面的关卡中会讲到哦。\ninput元素中的name属性也是非常重要的，后端接受表单的输入框数据时，用的就是name属性值来获取数据的。\n\n过关目标\n在有序列表的ol元素下方创建一个input元素，type元素值使用“text”\n\n过关条件\n需要有一个input元素，type属性值为text\n\n学会了什么？这关卡主要教会我们：\n\n使用input元素创建文本输入框\n\n\n答案\n\n「第十八关」文本输入框中添加占位文本\n\n\n\n\n\n\n\n\n关卡名：Add Placeholder Text to a Text Field\n知识点\n占位文本（Placeholder）也叫输入框提示语，这段文字会在用户为输入前在输入框中显示。\n\n我们可以用以下方式加入占位文本：\n&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;这个是占位文本&#x2F;提示语&quot; &#x2F;&gt;\n\n\n\n\n\n\n\n\n\n\n⚠️ 记住：\ninput元素是自我结束型元素，不需要结束标签哦！\n过关目标\n在input元素当中添加placeholder属性，属性值为”cat photo URL”\n\n过关条件\ninput元素中有placeholder属性\nplaceholder的属性值必须为“cat photo URL”\ninput元素不需要有结束标签\ninput元素语法不能有误\n\n学会了什么？这关卡主要教会我们：\n\n在input元素中添加placeholder属性\n\n\n答案\n\n「第十九关」创建一个表单元素\n\n\n\n\n\n\n\n\n关卡名：Create a Form Element\n知识点\n我们知道在现实生活中，提交一个表单&#x2F;表格，只需要填写好后递交给一个人就可以了。但是在网页中的表单是怎么提交让我们保存起来的呢？\n其实也很简单，我们首先创建一个form元素来建立一个表单，然后在form元素中添加一个action属性，并且给他一个提交的地址即可。\n\n\n\n\n\n\n\n\n\n\n小知识：\n我们知道现实中我们会把表格提交给工作人员，那在网页中我们提交给谁呢？我们用一个简单接地气的例子来理解一下：\n\n首先表格的内容都是电子化数据不是纸质的，那肯定是要提交给一个电子化储存的地方\n电子化储存的地方就是服务器，也就是一台电脑\n但是总要有一个人这样的东西接收我们的表单吧？是的，操控这个服务器的就是后端\n所以表单的action顾名思义是一个提交动作，表单需要指定给一个“人”来接收，在网络上就是“服务器地址或者后端地址”\n我们再想想现实中，工作人员拿到我们的表格，会存放到文件仓库对吧？那在网络应用中电子表单的数据放哪里呢？\n表单数据提交给到后端之后，后端会拿着这个数据储存到数据库中，数据库也就是文件库了\n\n通过这个例子大家应该可以能理解表单数据提交和储存的概念了。也更能懂得这个action背后的基本逻辑是什么了。\n代码例子：\n&lt;form action&#x3D;&quot;&#x2F;url-where-you-want-to-submit-form-data&quot;&gt;...&lt;&#x2F;form&gt;\n\n过关目标\n把我们的input元素包裹在form元素之中，然后在form元素中加入action属性值“**&#x2F;submit-cat-photo**”\n\n过关条件\n文本输入框应该包裹在form元素之中\nform元素需要有action属性值为“&#x2F;submit-cat-photo”\nform元素需要有完整的开始与结束标签\n\n学会了什么？这关卡主要教会我们：\n\n如何完成使用表单\n使用表单form元素\n懂得action属性的意义和用法\n\n\n答案\n\n「第二十关」添加表单提交按钮\n\n\n\n\n\n\n\n\n关卡名：Add a Submit Button to a Form\n知识点\n用户输入了表单中的信息，但是没有一个提交的按钮，这个信息是不会自动提交到服务端的\n所以我们需要在表单中加入button元素（按钮元素），并且给它的type属性一个“submit（提交动作）”的类型\n用户点击这个按钮就会提交表格中所有输入框内的信息\n\n过关目标\n在form元素中的最后添加button元素，类型为submit\n\n过关条件\n表单元素中必须含有一个按钮\nbutton元素必须有一个type属性值为submit\nbutton元素中的文字内容必须是”Submit”\nbutton元素必须有结束标签\n\n学会了什么？这关卡主要教会我们：\n\n使用button元素\n如果添加提交表单按钮\n\n\n答案\n\n「第二十一关」设置一个输入框为必填 ​\n\n\n\n\n\n\n\n\n关卡名：Use HTML5 to Require a Field\n知识点\n我们可以让表单中某个特定的输入框变成必填，如果用户没有填写是无法提交表单的\n举例，现在我们需要一个文本输入框变成必填项，我们只需要在input元素中添加一个require属性\n\n代码例子：\n&lt;input type&#x3D;&quot;text&quot; required &#x2F;&gt;\n\n\n\n\n\n\n\n\n\n\n⚠️ 注意：input元素中的require属性是不需要填写属性值的，只要加入这个属性就起效了。\n过关目标\ninput元素加入required属性，把输入框变成一个必填项，用户如果没有填写内容将无法提交表单\n加入后尝试在输入框中没有填写内容时点击”Submit”按钮，看看 HTML5 时如何提醒我们必填内容未完成的。\n\n过关条件\ninput元素应该有一个required属性\n\n学会了什么？这关卡主要教会我们：\n\n使用input元素中的required属性\n给表单加入必填输入框\n\n\n答案\n\n「第二十二关」添加一组单选按钮\n\n\n\n\n\n\n\n\n关卡名：Create a Set of Radio Buttons\n知识点\n当我们在表单中询问用户一个问题，并且希望用户只给出多选一的答案。这个时候我们就可以使用单选按钮。\n单选按钮是input元素中其中一种类型。\n要使用单选按钮，我们需要把每一个单选的input元素包裹在一个label元素中。这时label元素就会与input元素绑定上。意思就是label中的任何文字，在点击的时候都可以选中这个选项。\n所有相关的单选项需要有同一个name属性值才能把这些单选项组成一组选项。\n单选项被列为一组后，才能选择这组其中一个单选项时，才会自动去除选中其他这组里面的选项。\n\n单选按钮的例子：\n&lt;label&gt;\n  &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;indoor-outdoor&quot; &#x2F;&gt;\n  内门\n&lt;&#x2F;label&gt;\n\n\n最佳实践是在label元素上设置一个for属性，其值与输入元素的id属性值相匹配。这允许辅助技术在标签和子input元素之间创建链接关系。例如:\n\n&lt;label for&#x3D;&quot;indoor&quot;&gt;\n  &lt;input id&#x3D;&quot;indoor&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;indoor-outdoor&quot; &#x2F;&gt;\n  Indoor\n&lt;&#x2F;label&gt;\n\n过关目标\n添加一对radio单选按钮到我们的表单中，每个需要有自己的label元素包裹着。\n一个选项显示为indoor和另外一个选项显示outdoor。\n两个选项的name属性值都必须是indoor-outdoor，从而把它们组成一组。\n\n过关条件\n需要有两个radio元素的单选按钮\nradio元素的单选按钮都需要有name属性值为indoor-outdoor\n两个radio元素的单选按钮都需要有自己的label元素包裹着\n每个radio元素都有结束标签\n一个单选为indoor\n一个单选为outdoor\n所有radio元素都必须在form元素之内\n\n学会了什么？这关卡主要教会我们：\n\n使用label元素\n使用input元素中的radio类型\n如何组合一组单选项\n\n\n答案\n\n「第二十三关」添加一组复选框\n\n\n\n\n\n\n\n\n关卡名：Create a Set of Checkboxes\n知识点\n表单中，通常用checkbox来建立复选框的表单问题。\ncheckbox是input元素的其中一种类型。\n要使用复选框，我们需要把每一个复选框的input元素包裹在一个label元素中。这时label元素就会与input元素绑定上。意思就是label中的任何文字，在点击的时候都可以选中这个选项。\n所有相关的复选框需要有同一个name属性值才能把这些选项组成一组选项。\n与单选的原理相同：最佳实践是在label元素上设置一个for属性，其值与输入元素的id属性值相匹配。这允许辅助技术在标签和子input元素之间创建链接关系\n\n复选框例子：\n&lt;label for&#x3D;&quot;loving&quot;&gt;\n  &lt;input id&#x3D;&quot;loving&quot; type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;personality&quot; &#x2F;&gt;\n  Loving\n&lt;&#x2F;label&gt;\n\n过关目标\n在form元素内添加一组 3 个checkbox类型的复选框。\n每一个复选框的input都要有自己的label包裹着。\n三个复选框都需要使用同一个name属性值为personality。\n\n过关条件\n需要有 3 个复选框元素。\n每个复选框元素必须包裹着在自己的label元素内。\n每一个label元素都需要有结束标签。\n所有复选框都需要用同一个name属性值为personality。\n所有复选框都需要添加在form元素之中。\n\n学会了什么？这关卡主要教会我们：\n\n使用input元素中的checkbox类型\n\n\n答案\n\n「第二十四关」复选框与单选框中使用 value\n\n\n\n\n\n\n\n\n关卡名：Delete HTML Elements\n知识点\n当一个表单提交时，表单所有的数据会发送到服务端（后端），这里也包括我们选择的选择框数据。\ncheckbox复选框和radio单选框的选中数据也是会一起提交到服务端，那后端怎么判定我们选中了那些呢？\n无论是复选还是单选，后端接收到的都是选中的选项输入框value属性的值。\n所有我们需要给每一个checkbox或者radio类型的输入框一个value属性。\n\n代码例子：\n&lt;label for&#x3D;&quot;indoor&quot;&gt;\n  &lt;input id&#x3D;&quot;indoor&quot; value&#x3D;&quot;indoor&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;indoor-outdoor&quot; &#x2F;&gt;\n  Indoor\n&lt;&#x2F;label&gt;\n&lt;label for&#x3D;&quot;outdoor&quot;&gt;\n  &lt;input id&#x3D;&quot;outdoor&quot; value&#x3D;&quot;outdoor&quot; type&#x3D;&quot;radio&quot; name&#x3D;&quot;indoor-outdoor&quot; &#x2F;&gt;\n  Outdoor\n&lt;&#x2F;label&gt;\n\n以上例子中，我们有两个radio单选框类型的输入框。假设用户选中了”Outdoor”并且提交了表单，表单数据中会含有indoor-outdoor=outdoor这样的参数。indoor-outdoor这部分来源于这个输入框的name属性，然后outdoor就是用户选中的选项的value属性值。\n如果我们没有填写value属性值，用户选中了任何一个选项然后提交表单。后端接收到的数据就是indoor-outdoor=on。这个数据里面只能告诉我们indoor-outdoor这个选项，用户有选中一个值，但是是什么，我们不知道。这样这个表单的数据就没有任何意义了。所以我们一定要给每一个选项input元素加入一个value属性值。\n过关目标\n给每一个radio和checkbox输入框类型的元素一个value属性值。\n这里value属性值常规来说我们都是用英文的，在这个例子中因为我们的选项本身就是英文，所以我们直接用选项名作为value的值即可。\n\n过关条件\n其中一个radio的value属性值需要是”indoor“\n其中一个radio的value属性值需要是”outdoor“\n其中一个checkbox的value属性值需要是”loving“\n其中一个checkbox的value属性值需要是”lazy“\n其中一个checkbox的value属性值需要是”energetic“\n\n学会了什么？这关卡主要教会我们：\n\n使用value属性\n给radio或者checkbox加上value属性值\n多选项或者单选项数据提交的原理\n\n\n答案\n\n「第二十五关」默认选中单选框&#x2F;复选框\n\n\n\n\n\n\n\n\n关卡名：Check Radio Buttons and Checkboxes by Default\n知识点\n很多时候，表单当中都会有默认选中值。\n如果我们想默认选中单选项中的其中一个，或者是默认选中复选项中的几个怎么实现呢？\n想默认选中，我们只需要在radio或者checkbox的input元素中添加checked属性即可（这个也是一个不需要属性值的属性）\n\n代码例子：\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;test-name&quot; checked &#x2F;&gt;\n\n过关目标\n把radio单选框组合的第一个单选项设置为默认选中。\n把checkbox复选框组合的第一个复选项设置为默认选中。\n\n过关条件\n单选框组合的第一个单选项默认被选中\n复选框组合的第一个复选项默认被选中\n\n学会了什么？这关卡主要教会我们：\n\n给radio单选项或者checkbox复选项添加默认选中属性checked\n\n\n答案\n\n「第二十六关」将许多元素嵌套在单个 div 元素中\n\n\n\n\n\n\n\n\n关卡名：Nest Many Elements within a Single div Element\n知识点\ndiv元素，也称为分割元素，是其他元素的通用容器。\ndiv元素也是最常用的 HTML 元素之一。\n与其他非自我结束元素一样，可以使用div元素来开始，然后在另一行使用&lt;/div&gt;来结束。\n\n过关目标\n嵌套“Things cats love”和“Things cats hate”的两个列表到div元素之中\n\n\n\n\n\n\n\n\n\n\n提示：把&lt;div&gt;开始标签放在”Things cats love”的p元素上方，然后&lt;/div&gt;结束标签在&lt;/ol&gt;的下方。最后整个div元素把所有内容包裹起来。\n过关条件\np元素内容被包裹在div元素之中\nul元素内容被包裹在div元素之中\nol元素内容被包裹在div元素之中\ndiv元素必须有结束标签\n\n学会了什么？这关卡主要教会我们：\n\n使用div元素分割内容\n使用div元素嵌套多个元素\n\n\n答案\n\n「第二十七关」声明 HTML 文档的 Doctype\n\n\n\n\n\n\n\n\n关卡名：Declare the Doctype of an HTML Document\n知识点到目前为止，我们闯过的关卡当中包括了特定的 HTML 元素以及使用。但是那些都是一个完成 HTML 页面的其中一部分。其实还有一些元素是每一个 HTML 页面都需要存在的。\n在文章的顶部我们需要告诉浏览器，我们需要使用哪一个版本的 HTML。HTML 这个语言一直在持续更新升级。各大浏览器基本都兼容最新的配置与版本（那就是 HTML5）。但是还有一些浏览器只兼容一些历史版本的 HTML（例如旧版本的 IE 浏览器）。\n\n要告诉浏览器我们需要使用那个版本的 HTML，我们需要在 HTML 文件的头部添加&lt;!DOCTYPE ...&gt;，这里的...可以写入 HTML 的某个版本。如果是 HTML5 的话，那就是&lt;!DOCTYPE html&gt;即可。\n在这个声明的代码中!和DOCTYPE都是非常重要的，而DOCTYPE也是必须大写的。然后html这个就无大小写限制了。\n跟着这段文件 HTML 版本声明就是html元素。所有我们网页的代码和元素都必须在html元素内编写。\n\nHTML 代码例子：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;!-- Your HTML code goes here --&gt;\n&lt;&#x2F;html&gt;\n\n过关目标\n在代码区域第一行，加入DOCTYPE声明，并且选择使用 HTML5 版本。\n声明后加入html元素，并且在html元素内嵌套一个h1标题元素。\nh1标题元素内必须含有一个标题文案，文案可以随意填写。\n\n过关条件\n代码中必须含有&lt;!DOCTYPE html&gt;标签。\n代码中必须含有html元素。\nhtml元素必须包裹着一个h1元素。\n\n学会了什么？这关卡主要教会我们：\n\n如何声明 HTML 版本\n使用html标签\n\n\n答案\n\n「第二十八关」定义 HTML 文档的头部和主体\n\n\n\n\n\n\n\n\n关卡名：Define the Head and Body of an HTML Document\n知识点\n在标准的 HTML 文档结构中，我们需要丰富这个基础结构的分区。\n所以在html元素中我们会分出head头部元素和body主体元素。\n所有CSS 引用，字体引用，网页标题等等这些网页定义的内容都是放在head元素之内。\n然后所有页面的布局元素都需要放在body元素之内。\n\n\n\n\n\n\n\n\n\n\n小贴士：\n我们用一个一个更好的理解方式，让我们更容易记住这个规则的原理。\n\n如果我们想一下，所有的知识，思想，印象等等就等同于 HTML 当中的”CSS 引用，字体引用，网页标题“，那东西是不是都应该在我们的脑袋里面呢？所以呀“CSS 引用，字体引用，网页标题”都应该放在head头部元素中！\n我们的骨头和骨架是不是在我们身体内呢？所以剩下所有的页面布局代码就要放在body主体元素中！\n\nHTML 结构代码例子：\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;!-- metadata elements --&gt;\n    &lt;!-- CSS引用，字体引用，网页标题等等元素 --&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;!-- page contents --&gt;\n    &lt;!--页面的布局元素 --&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n过关目标\n代码区域里面有title页面标题元素，h1文章标题元素和p文章段落元素。\n把title元素嵌套到一个head元素中。\n剩余的h1和p的内容都嵌套到一个body元素中。\n\n过关条件\n只有一个head元素\n只有一个body元素\nhead元素需要被html元素包裹着\nbody元素需要被html元素包裹着\ntitle元素需要被head元素包裹着\nh1和p元素都需要被body元素包裹着\n\n学会了什么？这关卡主要教会我们：\n\n建立完成的 HTML 文档结构\n\n\n答案\n\n「终」总结恭喜大家一起闯过 28 关。我们学习到了 HTML 与 HTML5 的基础知识。虽然说这些都是很基础的知识，可以说闯过这 28 关，前端入门级别都还没有到。但是庞大与伟大的事业和建筑物都是从稳固的基础建立起来的。无论是多么简单还是无比困难的任务，我们都需要耐心和细心对待，把每一件小事都做到极致，才能逐步壮大，成功才会在远方等着我们。\n下一期，我们开始第二课，深入浅出 CSS 基础。一起继续闯关打怪，打开前端技术大门。敬请期待哦！\n\n\n\n\n\n\n\n\n\n我是三钻，一个在技术银河中等和你们一起来终身漂泊学习。点赞是力量，关注是认可，评论是关爱！下期再见 👋！\n系列阅读\n🔥《44 关学习 CSS 与 CSS3 基础「一」》 — 这周我们一起闯过了 22 关，下一期我们会一起把剩余的 22 关完成。学习是一种像爬山一样的过程，要经历过漫长的上坡路，一步一个脚印。“路漫漫其修远兮，吾将上下而求索。”， 在追寻知识的道路上，前方的道路还很漫长，但我们将百折不挠，不遗余力地，上天下地的去追求和探索。让我们继续坚持学习，终身学习成长。在大前端的时代爬到技术的巅峰，做一个有深度的技术人员。\n🔥《44 关学习 CSS 与 CSS3 基础「二」》 —— 我有一段时间没有更新 FCC 前端教程了，这一周就继续写完 CSS 与 CSS3 基础的教程。最近工作和生活都比较繁忙所以文章更新也受到了一定的影响。不过技术文章写作再忙也不会放弃的。我会继续努力坚持着一周一篇文章的进度，继续为大家带来我学习到的知识。让我们一起继续终身学习吧！\n\n推荐系列小伙伴们可以查看或者订阅相关的专栏，从而集中阅读相关知识的文章哦。\n\n📖 《数据结构与算法》 — 到了如今，如果想成为一个高级开发工程师或者进入大厂，不论岗位是前端、后端还是 AI，算法都是重中之重。也无论我们需要进入的公司的岗位是否最后是做算法工程师，前提面试就需要考算法。\n\n📖 《FCC 前端集训营》 — 根据 FreeCodeCamp 的学习课程，一起深入浅出学习前端。稳固前端知识，一起在 FreeCodeCamp 获得证书\n\n📖 《前端星球》 — 以实战为线索，深入浅出前端多维度的知识点。内含有多方面的前端知识文章，带领不懂前端的童鞋一起学习前端，在前端开发路上童鞋一起燃起心中那团火 🔥\n\n\n推荐阅读\n🔥《前端必看的 8 个 HTML+CSS 技巧》 — CSS 是一个很独特的语言。看起来非常简单，但是某种特殊效果看似简单，实现起来就颇有难度。这篇文章主要是给在学习前端的童鞋分享一些新的 CSS 技巧，一些在前端教程和培训课堂中不会讲到的知识。第二就是让还在前端开发这条道路上的童鞋们，重新燃起对前端排版和特效的热爱和热情！🔥\n🔥《带你体验 Vue2 和 Vue3 开发组件有什么区别》 — 使用 Vue2 和 Vue3 开发一个简单的表格组件来展示一下 Vue2 和 Vue3 开发组件的区别。看完这文章后，你将会有一个概念 Vue2 和 Vue3 开发组件时的区别，并且为 Vue3 的开发之路做好准备。ღ(◔ڼ◔ღ)ミ\n🔥《VSCode 常用快捷键大全｜ VSCode 高级玩家宝典之第一篇》 — 所以对于个好的程序员，一个好的代码编辑器可以起到很大的作用，在开发的过程中可以给我们带来很多便利、帮助、效率和影响。甚至一个好的编辑器可以给开发者日常编程中带来更高的喜悦感。\n🔥《VSCode 插件大全｜ VSCode 高级玩家宝典之第二篇》 — VSCode 没有安装插件，就等同于一把枪没有安装配件，打把的时候还是缺失精准度，开枪的时候也会有很重的后坐力。当然没有插件，也可以很好的编写代码，就是没有那么强而已。\n🔥《VSCode 配置同步｜ VSCode 高级玩家宝典之第三篇》 — 有了武功秘籍（快捷键）和高深的内功心法（插件），那 VSCode 是不是应该是无敌了呢？天灾难逃，人祸难免，我们电脑可能会坏或者电脑还可能要退休，甚至是我们有多台电脑的可能。那这个时候我们精心配置的 VSCode 不是要从头再来？\n\n\n","slug":"frontend/fcc-html5-basics","date":"2020-05-09T17:21:19.000Z","categories_index":"FrontEnd","tags_index":"HTML&CSS,Free Code Camp","author_index":"三钻"},{"id":"8b2cfe872b7cb9696e1812ee34aa03bc","title":"VSCode配置同步","content":"在上两篇文章中，我们学到了 VSCode 是怎么使用快捷键让我们编写代码时更灵活便捷，甚至是可以基本脱离鼠标。还介绍了很多常用的插件让我们如虎添翼，就像 VSCode 穿上了传奇级别的装配一样。\n还没有阅读以上说到的两篇文章《VSCode 常用快捷键大全》，《VSCode 插件大全》，可以先过去学习学习哈。\n有了武功秘籍（快捷键）和高深的内功心法（插件），那 VSCode 是不是应该是无敌了呢？天灾难逃，人祸难免，我们电脑可能会坏或者电脑还可能要退休，甚至是我们有多台电脑的可能。那这个时候我们精心配置的 VSCode 不是要从头再来？\n所以这篇文章我来给大家介绍一个 VSCode 的插件专门来解决这个问题。​ 读完这篇文章我们将学会如果一键同步所有 VSCode 中精心配置的插件，快捷键和配置。\n「一」配置同步插件\nSettings Sync是一款免费好用的 VSCode 插件。它是一款使用 GitHub 中的 Gists 作为配置文件存储来实现同步的。它可以让我们在无数个设备上同步 VSCode 的配置。\n可以为我们同步以下内容：\n\n配置文件\n快捷键配置\n启动文件记录\nSnipper 文件（自定义代码模版）\nVSCode 插件和插件配置\nWorkspace 文件夹\n\n\n听起来确实觉得很高大上，但是真的如此容易就可以做到所说的效果吗？确实是的，配置不复杂也不繁琐。最多就是复制黏贴以下一个 ID，而且首次使用都是自动的。只要登陆 GitHub，然后接下来的一切就可以交给这个插件的脚本了。\n虽然说简单，但是我第一次配置的时候也掉坑了几次，所以接下来我一步一步给小伙伴们讲解详细的配置方式。\n\n「二」插件配置与搭建\n插件的文档简单的描述了使用步骤，但是个人在使用的过程中，还是觉得颇为迷惑。很多细节方面如果文档有的话就可以少掉几根头发了。\n​ 所以这里我整理了一套手牵手教程带大家一起把配置同步一起搭起来。\n\n安装 Settings Sync 与准备在插件搜索栏输入Settings Sync然后狠狠的按下安装按钮。\n在介绍这个插件的时候提到，这个插件是使用GitHub账号中的Gists来储存配置的，所以我们必须要有一个GitHub账号。如果已经有 Github 账号的可以跳过注册教程。\n\n注册 GitHub 👉「 点击这里注册一个账号 」 👈 \n\nUsername：填入你的用户名，如果以后有做开源项目的打算，给自己取个好名，可能会跟你一辈子的哦。\nEmail address：填入我们常用的电子邮箱。\nPassword：顾名思义，填入我们的登陆密码。\nEmail preferences： 勾上的话，GitHub 会不定时给你邮箱发送产品更新，公告或者是优惠等通知。（不想被邮件打扰，可以不勾）\n\n\n账号信息这里的防机器人验证，只需要点击图片两方的箭头让图片旋转到图片的正确方向然后点击Done即可。然后点击Create account。\n\n\n\n\n\n\n\n\n\n\n如果点击Create account后出现以下错误，证明是你的密码安全级别不够，GitHub 认为你的密码太容易被猜到。所以推荐大家的密码要用“大小写+数字+符号”的规则。\n点击Create account之后，GitHub 会开始验证你的账号 … …\n最后还会出现一次刚刚说到的防机器人验证图片。旋转好这个图片，然后点击Join a free plan即可（顾名思义，“加入免费套装”）。\n\n注册成功后会到达这个页面，这里会问你几个问题：\n\nWhat kind of word do you do, mainly? — 你主要是从事那种工作？\nHow much programming experience do you have? — 您的编程熟悉程度？\nWhat do you plan to use GitHub for? — 您准备用 GitHub 来做什么？\nI am interested in — 您对什么感兴趣？\n\n这些问题如果你在意的话，可以回答下，主要用于 Github 给你推送&#x2F;推荐项目的。最后点击 Complete setup，就可以了。\n最后 GitHub 会给我们的电子邮箱发一封验证邮件，前往我们的邮箱点击验证链接就可以完成 GitHub 的账号注册了。\n\n\n用 GitHub 账号登陆前面说到这个插件是基于 GitHub 中的 Gist 来储存配置的，所以我们需要使用 GitHub 授权登陆，获取到 Gist 的读写权限才能实现配置的保存和读取。简单来说所有我们的配置数据，都被储存在我们 GitHub 上的 Gist 之中。方便保存和下载。\n\n授权登陆 GitHub安装好 VSCode 之后会自动出现这个页面，如果你们是第一次使用，点击LOGIN WITH GITHUB\n\n\n\n\n\n\n\n\n\n\n以前我看过有很多教程，要我们到 GitHub 上创建个人访问令牌之类的。那些都是过时的配置方式，现在可以直接通过 VSCode 插件页面登陆 GitHub，即可获取到一个自动生成的私密个人令牌。这种方式方便多了。\n点击后，VSCode 上方会弹出一个提示框，狠狠的点击打开就完事！\n\n\n\n\n\n\n\n\n\n\n当然谨慎和强迫症的童鞋很害怕任何链接，感觉都是诈骗。不用怕这里其实就是这个插件尝试打开一个 GitHub 的授权页面，从而获得我们 GitHub 中的访问令牌。\n此刻 VSCode 会使用我们的默认浏览器打开 GitHub 的授权页面。大家不用慌，这个授权只是授权给 VSCode 配置同步插件读写权限和账号基本信息（包含，名字，用户名等，不会暴露自己的敏感信息的）。所以大家可以安心和狠狠的点击Authorize shanalikhan即可授权!\n\n授权成功后，页面会跳转到这样一个页面，中间写着“成功！您现在可以关闭此页面&quot;。这个时候好奇的童鞋会问：为什么我们的 URL 是 http://localhost:54321/callback?code=XXXXXXXXXX:？\n其实就是配置同步的插件开启的监听地址，用来获取 GitHub 回调传回来的Code密钥。现在我们可以回到 VSCode 当中，看看有什么变化。\n\n回到 VSCode，如果我们是看到以下的页面证明成功登陆了！🎉\n\n\n\n\n\n\n\n\n\n\n🌟 如果回到 VSCode 发现右下角出现这个报错，一般都是因为 GitHub 的接口连接失败。这个可能是突然 GitHub 无法访问成功导致的。（毕竟我们是在伟大的网络城墙之下的，所以有时候有连接 GitHub 的问题是很正常的）如果是遇到这个问题，只要我们回到 Settings Sync 的首页，再充满信仰的点一次 LOGIN WITH GITHUB。第二次基本都是可以的了。 &gt;\n\n使用原有配置如果我们曾经使用过这个配置同步插件，先在另外一台电脑上的全新 VSCode 编辑器安装这个插件，然后使用同一个 GitHub 账号登陆。这个时候我们就会发现，这个页面会展示我们历史的 Gist 配置记录（如下图）。\n如果有历史记录，我们可以选择一个记录，然后一键下载这些配置到当前的 VSCode。这样所有我们同步过的插件，快捷键配置，编辑器配置和主题等等都会自动下载下来。完美的还原与我们之前 VSCode 的使用场景！\n\n创建全新配置如果我们是第一次使用，我们只需要在这里点击 SKIP 即可。当我们首次上传配置的时候，就会创建一个新的 Gist 来保存。\n\n\n「三」使用指南\n上面我们配置好了 VSCode 中的配置同步插件Settings Sync，我们开始讲讲该如何使用这个插件来同步的。\n\n上传配置快捷键：\n\nWindows&#x2F;Linux：Shift + Alt + U\nMac：Shift + Option + U\n\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Update/Upload Settings。可以不全部输入完，只需要输入头几个字母就可以看到这个命令了。然后直接选择就可以了。\n当我们上传配置的时候，右下角会提醒我们，是否需要强制上传或者下载配置，并且覆盖 GitHub Gist 上面的配置数据。这个是为了防止我们误操作覆盖了自己的配置文件。\n\n\n\n\n\n\n\n\n\n⚠️ 比如我们现在在一台全新的电脑，安装了一个全新的 VSCode，目前是没有安装任何插件和设置任何配置的。这个时候我们首先是需要下载 Gist 上面的配置设置对吧？如果我们误操作了，先运行了上传配置呢？那么我们本地的空配置就会覆盖了 Gist 上面我们精心配置好的。这个时候我们就会把一个没有任何插件和自定义过的 VSCode 配置覆盖了 Gist 上面的。不过也不用太怕，只要我们回到另外一台电脑把那台电脑的 VSCode 配置强制覆盖上去，配置文件就还原了。但是如果我们设置了自动强制上传和下载的话。那就炸锅了，没救了。所以强制和自动同步我们一定要慎重使用。\n我们这个时候就是想上传目前最新的配置设置到 Gist 上，所以我们狠狠的点击是就完事儿了！\n上传完毕之后，我们会看到在输出栏中的上传日志：\n\n\n下载配置快捷键：\n\nWindows&#x2F;Linux：Shift + Alt + D\nMac：Shift + Option + D\n\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Download Settings。可以不全部输入完，只需要输入头几个字母就可以看到这个命令了。然后直接选择就可以了。\n下载的过程中，下面的控制台的输出栏会输出所有下载日志。\n\n\n\n\n\n\n\n\n\n🌟 我们的插件会自动重新下载到 VSCode 中，所有快捷键和用户自定义配置都会自动重新同步下来。因为有某些插件是需要重启 VSCode 才生效的，所以同步完之后最好重启下编辑器。\n\n\n重置插件配置如果我们想归零，重新配置这个插件。这个时候我们可以使用插件自带的重置功能。\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Reset Extension Settings。可以不全部输入完，只需要输入头几个字母就可以看到这个命令了。然后直接选择就可以了。\n\n强制下载强制下载默认是关闭的。当本地记录的配置版本是最新的版本（插件是根据时间来判断的），就不会自动强制下载最新的 Gist 上的配置了。但是如果我们在本地的 VSCode 中删除了某些插件，并且我们没有上传到 Gist 上。这个时候根据配置记录来说是没有更新的云配置的，所以不会自动获取最新的云配置，也就是说缺失的插件是不会自动补回来。\n如果我们把强制下载开启，就会在每次 VSCode 启动的时从 Gist 上下载最新的配置，有缺失的插件会被补回来，有改变了的配置也会被覆盖回来哦。\n在某种情况下，这个是很实用的，比如有时候我们只是在某种开发条件或者环境下，改变了一下配置，或者禁用了一下插件，或者是在尝试几个不同的配置与插件。等我们完成之后希望可以用回原来的配置。这个时候就很实用了。\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：开关强制下载，选择后可以开启&#x2F;关闭此设置。\n\n改变时自动上传自动上传默认是关闭的。如果我们不希望每次改变了配置后，快捷键和插件需要手动上传到 Gist。我们可以开启改变时自动上传。这样还可以避免我们在不同电脑改变了 VSCode 配置和插件后忘记上传，回到家后下载不了最新的配置。\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：切换配置更新后自动上传，选择后可以开启&#x2F;关闭此设置。\n\n开启&#x2F;关闭摘要输出上传与下载是输出的日志是默认开启的。这个日志会输出所有新增和删除的文件和插件。我们可以通过这个设置把其关闭。\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：开关同步时显示摘要页面，选择后可以开启&#x2F;关闭此设置。\n\n🌟 创建共享云配置Setting Sync默认创建的是私有 Gist，所以只有我们自己可以查看，但是在很多团队和项目中，大家使用同一套配置和插件往往是非常有必要的。想想在一个团队中，每一个开发者使用的编辑器和插件不统一，我们过去协助他们 debug（调试）和教学的时候，很多时候都会感觉非常的不顺手。\n而且一个统一的插件和使用规范和配置规范，可以影响到真个团队项目的代码的规范。最明显的就是整个团队有使用同一套Prettier插件配置和没有用的时候！\n新加入团队的开发同事，还要安排人过去协助安装一些我们团队的规范插件和配置。想想是不是我们是需要这么一个东西的呢？\n\n如何创建共享配置？首先我们来了解一下是怎么共享我们 Gist 上的配置。\n我们以前的私有 Gist 是无法从私有改为公开的，所以我们把 Gist 上的共享配置打开后，插件中的 Gist ID 会重置。当我们开启后首次上传时，会创建一个全新的 Gist 并且是公开的。\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：在公开Gist上分享配置，选择即可。\n对就如此简单！然后我们就上传一次配置即可！\n\n\n\n\n\n\n\n\n\n这里我们需要注意： 我们公开出去的 Gist 其他用户可以下载，但是是无法更改的。其他用户下载了共享出来的配置后，还是需要配置一个自己的私有 Gist 来同步自己的配置哦。当然我觉得这个是很合理的，共享出来的配置，是用来初次使用为主的。下载了团队中的插件后，他们还是可以自定义一些插件和配置，根据个人习惯调整一下。毕竟编辑器对于每个人来说，使用时都有一些不一样的习惯。\n\n如何下载共享的配置？讲解了如果共享自己的配置给我们亲爱的小伙伴，那也要告诉他们怎么下载我们的配置呀。\n首先我们要找到我们公开的 Gist ID，这个 ID 可以在我们的插件配置里面找到：\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：打开设置，选择即可。\n选择后就会打开我们Setting Sync的设置页面，下图框住的位置就是我们 Gist ID。只要复制这个 ID 然后分享给需要下载我们共享配置的小伙伴们。\n小伙伴们拿到我们的Gist ID后，有两种情况：\n\n如果他们之前有配置过Settings Sync的话，那就需要先重置自己的插件配置。如何清楚，我在前面讲解过了，跟着之前的教程清楚即可（有配置过的童鞋还需要记得把自己的 Gist ID 和 获取令牌记下来，后面需要用到哦！）。\n如果没有配置过Settings Sync的话，可以直接走到我下来说的步骤。\n\n一切准备就绪，现在我们来下载共享的配置：\n\n首先用上面说到的方式打开设置，然后在Gist ID的那个输入框，输入我们拿到的共享Gist ID， 最后聚焦离开输入框（意思就是点击输入框以外的任何地方）就可以保存了。\n然后执行以下操作:\n\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Advance Options 。选择后会出现一个设置列表，找到Sync：从公开Gist下载配置，选择即可。选择后右下角会出现这个提示：意思就是说，我们现在不需要填写 GitHub 的令牌，只要填写 Gist ID 就可以下载插件了！\n好最后一步就是下载插件：\n快捷键：\n\nWindows&#x2F;Linux：Shift + Alt + D\nMac：Shift + Option + D\n\n\n\n\n\n\n\n\n\n\n🌟 打开编辑器命令行 Command + Shift + P （Mac）然后输入 &gt;Sync: Download Settings。可以不全部输入完，只需要输入头几个字母就可以看到这个命令了。然后直接选择就可以了。⚠️ 如果插件比较多的时候，可能会需要等待一会儿哦。\n可以一直盯着控制台实时输出的日志，看到同步完成后即可哦！（如果途中因为 GitHub 连接失败，重新启动下载配置即可。最近 GitHub 网络不是很稳定，所以可能会有点颠簸，童鞋们记得带上安全带哈。😂）\n最后一步就是与我们原来的 GitHub Gist 重新绑定上，这里需要手动绑定哦 ​：\n\n我们只需要再重置一次这个插件的配置。\n然后打开插件的配置，把我们刚刚记下来的Gist ID和获取令牌​重新填入对应的配置项里面。\n最后强制上传一次我们现在的配置 ​，记住是强制！\n\n\n「终」总结写到这里，VSCode 高级玩家系列就结（未）束（必）了。如果这个系列有帮助到你们，而且童鞋们觉得这个系列应该继续下去的话，就给我点个赞，并且在评论区回复“还要！”。如果我看到有大量的需求的话，我会继续深度挖掘 VSCode 中的各种高级技巧分享给大家哦！😁。\n对了！差点就把大事给忘了！如果有看我上一篇文章《VSCode 插件大全》的童鞋，知道我在上一篇文章里面分享了大量我在使用的插件。如果想一键下载下来使用的话，我这里有建立好一个共享配置的Gist ID给大家使用。\nGist ID: 5ca94da358b6833763017e1fbafd994b\n\n\n\n\n\n\n\n\n\n快乐的时光总是过得特别快，珍惜每一寸光阴我是三钻，一个在技术银河中等你一起来终身漂泊学习的程序员。文章对你们有帮助的，给我来个三连操作（点赞，关注，评论支持）。Happy coding 🎉！\n","slug":"tools/vscode-setting-sync","date":"2020-05-01T02:11:07.000Z","categories_index":"Tools","tags_index":"VSCode,VSCode Settings","author_index":"三钻"},{"id":"5632221ad69588971354770029883ced","title":"VSCode插件大全","content":"上一篇文章《VSCode 常用快捷键大全》，我们了解到了 VSCode 中的常用快捷键。学会了快捷键可以让我们更高效和迅速的编写代码。但是没有 IDE 中的一些辅助功能，还是美中不足。\nVSCode 没有安装插件，就等同于一把枪没有安装配件，打把的时候还是缺失精准度，开枪的时候也会有很重的后坐力。当然没有插件，也可以很好的编写代码，就是没有那么强而已。\n所以这篇文章会给大家介绍 VSCode 中最常用的插件，让我们的编辑器加上一双翅膀，让我们在编写代码的过程中如虎添翼的感觉。\n\n\n\n\n\n\n\n\n\n🌟 所有插件，只要搜索插件名就能找到哦！\n\n「一」国人必备集合这些插件都是我们作为中国人必备的，妈妈再也不怕我们看不懂英文了。\n\nVSCode 中文简体包插件名：Chinese (Simplified) Language Pack for Visual Studio Code\n这个插件一键把整个 VSCode 的文字转换成中文。一个全中文化的 IDE 是我们特别需要的。而且这个是官方汉化包，理解无障碍。\n\n\n代码翻译插件名：翻译(英汉词典)\n英语不是很好的童鞋，在写代码的时候经常会使用“某道翻译”，但是其实对于代码来说，很多时候我们会用驼峰、小驼峰、下划线等等写法来写变量名、属性名、类名和方法名的。这种写法想使用“某道翻译”在编辑器中悬浮翻译就是不可能了。\n找了很久我为大家找到一个非常好用的一个插件可以解决这个问题！\n\n\n\n\n\n\n\n\n\n本地 77 万词条英汉词典，不依赖任何在线翻译 API，无查询次数限制。可翻译驼峰和下划线命名，及对整个文件中的标识符批量翻译。\n\n\n检测代码英文单词错误插件名：Code Spell Checker\n一个基本的拼写检查器，可以检测驼峰写法。这个拼写检查程序的目标是帮助捕获常见的拼写错误。在编写代码的时候，我们都是用英文单词，很多时候我们都会写错单词的可能性。用错了单词其实对于维护性是有一定的影响的。\n使用有意义的单词做为方法名、类名和变量名会给自己代码更多的意义和含义。当自己或者别人去查看代码时更容易懂其中的用意。但是如果我们拼错了单词，有些时候就无法理解这个单词是什么意思了。\n所以这个插件对我们来说非常实用，就算是老外都非常多人在使用它。（目前有 100 多万下载量）\n\n\n「二」主题集合一个程序员一天 8-12 个小时都是看着编辑器和代码。如果我们的编辑器不好看，没有一定的美观和吸引力，怎么可能耐看不厌呢？加上长期看代码，一个舒服的主题自然是必备之一。\n这里介绍几款我最喜欢的主题给大家使用。有更多大家喜欢的主题欢迎在评论中提出，我会补充到这里哦！\n\nDracula Theme主题名：Dracula Official\n这款主题主调色是偏深紫色，我用了这个主题至少也有 2-3 年，一直都很喜欢。里面代码的高亮和颜色都很细致，很适合长期看。这个主题的颜色有根据不同的语言做了适配，无论我们是在开发什么语言都非常好看。\n\nMaterial Theme主题名：Material Theme\n这款也是非常出名的主题，在非常多的 IDE&#x2F;编辑器都有。用习惯这个主题的可以在 VSCode 中安装使用。使用量也是有 200 多万+。这款主题在我使用SublimeText的时候非常热爱。（也用了好几年）\n\n\nNebula Theme主题名：Nebula Theme\n这一款是我现在在用的小众主题。配色与 Dracula 非常相似，但是有更多的亮色，颜色的变化幅度也没有那么大，相比 Dracula 更为顺眼。当然这个也要看个人喜好哈。\n\n\nAtom One Dark Theme主题名：Atom One Dark Theme\n我认识的一些小伙伴用过 Atom，也有这么一部分小伙伴特别喜欢这个主题。\n\n\nOne Monokai Theme主题名：One Monokai Theme\n对长期使用SublimeText的Monokai的童鞋们，对这款主题应该感兴趣。毕竟 Monokai 主题陪伴了我们挺长一段时间的。（不好了要暴露年龄了 😂）\n\n\nGitHub Plus Theme主题名：GitHub Plus Theme\n对终于有一个白色的主题了，但是个人对白色的主题不怎么感冒。最近连微信都加入了黑暗世界，所以我已经习惯所有 UI 都是黑暗模式了。但是毕竟还是有童鞋特别喜爱白色的。\n这里推荐一款与 GitHub 一样色系的白色主题（我可以说是我唯一可以考虑使用白色的一款，有童鞋有自己喜欢的白色主题可以在评论中留言给我哦！）\n\n\n\n\n\n\n\n\n\n\n\n🌟 小总结VSCode 中还有非常多的主题可以选择，如果我推荐的主题中没有你们喜欢的，可以在插件搜索框中输入theme，就会出来很多的主题供大家自由选择哦！\n\n\n「三」图标主题集合安装了编辑器主题，不安装图标主题就等同于 💐 鲜花插在了 💩 牛粪上。这里推荐两款我自己使用过的图标主题。\n\nMaterial Icon Theme主题名：Material Icon Theme\n占了大部分人都是用这个图标主题，内含非常齐全的图标，基本你能想到的文件都在内了。非常推荐使用！\n\n\nVSCode Icons主题名：vscode-icons\n这一款是 VSCode 官方的图标主题包，有超过 500 万+下载量。可以说是和 Material Icon 一样占了另外一大部分人在使用的一款主题。看个人喜好选择使用。个人觉得两款最大的区别在于文件夹。但是觉得 Material Icon 做的图标相对更加协调一些。\n\n\n「四」实用插件集合这里给小伙伴们介绍一些在其他 IDE 都有可能用过的超级实用插件和功能。这些插件主要是强化编辑器的功能，让我们在开发过程中得到非常大的帮助。\n\n代码书签插件名：Bookmarks\n它是代码中导航，在重要位置之间轻松快速地移动。不再需要搜索代码。它还支持一组选择命令，允许我们选择书签行和书签行之间的区域。它对于日志文件分析非常有用。\n以下是书签提供的一些功能:\n\n在代码中标记&#x2F;取消标记位置\n在代码中标记位置并给出名称\n在书签之间来回跳转\n查看一个文件中所有书签的列表\n查看项目中所有书签的列表\n专用侧杆\n带有书签的行\n选择书签之间的区域\n\n\n这里附上我经常使用的几个这个插件的命令：\n\nBookmarks: List 列出当前文件中的所有书签\nBookmarks: List from All Files 列出当前项目下所有书签\nBookmarks: Clear 删除当前文件中的所有书签\nBookmarks: Clear from All Files 删除当前项目下的所有书签\n\n我们还可以通过打开侧边栏中的书签 tab 查看所有标签：\n\n括号对彩色化插件名：Bracket Pair Colorizer 2\n这个扩展使用颜色来标识匹配的括号。用户可以定义要如何匹配，以及要使用哪些颜色。在代码量比较多的情况下，括号也会变得非常的多，有了颜色的标识会给开发者带来更好的识别能力。\n\n\n增强 Git 功能插件名：GitLens\n增强 VSCode 中内置的 Git 功能——通过 Git blame 注释和代码透镜，一眼就能看到代码作者的身份，无缝导航和探索 Git 存储库，通过强大的比较命令获得有价值的见解，等等。使用Git代码管理的开发者们，这个是一个必装插件之一！\n\n\nGit 历史记录插件名：Git History\n对于一些开发者习惯使用编辑器中的 Git 管理工具的，不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。\n\n查看和搜索 git 日志中的图形和详细信息。\n查看文件以前的副本。\n查看和搜索历史\n比较分支&#x2F;提交记录&#x2F;文件\n更多～\n\n\n\n实时协作编辑插件名：Live Share\nVisual Studio Live Share 允许我们与他人实时协作编辑和调试，不管我们使用的是哪种编程语言或正在构建的应用程序类型。它允许我们立即(并且安全地)共享我们当前的项目，然后根据需要共享调试会话、终端实例、本地主机 web 应用程序、语音呼叫等等！加入我们的会话的开发人员从我们的环境中接收所有的编辑器上下文(例如，语言服务、调试)，这确保了他们可以立即开始有效地协作，而不需要克隆任何代码或安装任何 sdk。\n此外，与传统的结对编程不同，Visual Studio Live Share 允许开发人员一起工作，同时保留他们的个人编辑器首选项(例如主题、键绑定)，以及拥有自己的游标。这允许我们在跟随他人和自己探索想法&#x2F;任务之间无缝过渡。在实践中，这种协作和独立工作的能力为许多常见用例提供了一种更自然的协作体验。\n\n要使用这个协同软件，首先我们需要登陆（推荐使用 GitHub 登陆）。登陆后点击下方的Live Share:\n\n然后编辑器就会弹出以下提示，具体意思就是说，我们的实时共享会话已经开启，邀请连接已经被复制，可以发给你的协助开发者。\n\n这个时候我们可以把连接发给我们的协助者，这里对方必须安装了Live Share的插件并且必须是登陆状态。\n这个时候对方只需要点击侧边栏的Live Share图标，然后在会话详细信息中找到并且点击加入协作会话...。\n点击后编辑器上方会出现一个输入框，对方只需要输入我们提供的邀请连接然后按回车即可。\n\n协助完毕后，我们可以点击下方的图中的图标点击图标后，上方会出现一个选择弹窗，选择Stop Collaboration Session就可以停止协助会话了。\n\n路径智能提示插件名：Path Intellisense\n加入此插件让我们在应用文件（例如图片）时，有智能的路径提示。\n\n\n「五」前端开发插件集合这里提供给各位童鞋世上最全的前端开发插件集合，没有“之一”。（当然要做到最强还需要大家给我多提意见，欢迎小伙伴们给我补充一些我也还没有使用过的实用前端插件哦！可以在评论区留言哈！）\n程序员最好的朋友无非就是编辑器中的插件，有插件和没有使用插件在开发中简直就是天差地别。这里让我想到自己一开始学习编程的时候，使用notepad++，一行一行代码纯手敲的经历。现在有了各式各样的 IDE，估计已经差不多没有人还在用文本编辑器手敲代码了。\n\n自动关闭标签插件名：Auto Close Tag\n自动添加HTML/XML关闭标签，与 Visual Studio IDE 或 SublimeText 相同。当我们填写了开始标签，结束标签就会被自动加上。这个非常实用，减少很多我们写html和xml的时间。\n\n如果是使用SublimeText过来的或者习惯SublimeText的童鞋，可以开启Sublime Text 3模式，在settings.json文件里面加入这个配置：\n&#123;\n  &quot;auto-close-tag.SublimeText3Mode&quot;: true\n&#125;\n\n\n\n自动同步标签名插件名：Auto Rename Tag\n自动重命名成对的 HTML&#x2F;XML 标记，与 Visual Studio IDE 相同。用这个插件可以告别每次改变标签的时候要重复修改头部和尾部标签。特别是标签内内容非常多的时候，要改确实很费劲的。\n\n\nCSS 颜色高亮插件名：Color Highlight\n这个插件会对页面上所有的 CSS&#x2F;web 的颜色编码进行高亮，高亮的颜色就是编码对应的颜色。在写 CSS 的时候非常实用。\n\n\n高亮匹对标签插件名：VSCode Highlight Matching Tag\n此插件高亮显示匹对的开始和&#x2F;或结束标签。还可以在状态栏中显示标签的路径。这个插件将尝试在任何地方匹配标记: 从标记属性、字符串内部、任何文件，同时还提供广泛的样式选项来定制标记的高亮显示方式。\n官方支持的标签: HTML 和 JSX。其他风格 (XML、Vue、Angular、PHP) 也可以。\n\n\nHTML CSS 支持插件名：HTML CSS Support\n补充了 VSCode 中缺少的 CSS 支持。类属性补全、ID 属性补全和全文件搜索 CSS 和 SCSS 提示等。\n\n\n小程序支持插件名：minapp-vscode\n微信小程序标签、属性的智能补全（同时支持原生小程序、mpvue 和 wepy 框架，并提供 snippets）\n\n\nVue 支持插件名：Vetur\n开发 Vue 的童鞋必装插件之一。支持标签、属性的智能补全等等。\n\n经常用 Vue 开发的童鞋，我这个里另外推荐一个插件给你们。就是Vue 2 Snippets，这个插件加入了 Vue2 的代码块，让我们开发的过程中可以快速生成 Vue2 的代模版。\n\n\nReact 支持插件名：ES7 React/Redux/GraphQL/React-Native snippets\n这个扩展为你提供了 JavaScript 和 ES7 中的 React&#x2F;Redux 代码片段，以及 VSCode 的 Babel 插件特性。编写 React 的童鞋，这个插件是必备之一。\n\nNPM 支持插件名：npm\n这个扩展支持运行包中定义的 npm 脚本。并根据包中定义的依赖项验证已安装的模块。最喜欢这个插件的功能就是可以自动检测依赖是否安装，还可以提示依赖的版本和具体项目地址。使用 npm 的童鞋必备插件之一。\n\n\nNPM 智能提示插件名：npm Intellisense\n加入此插件可以让我们在编写 JavaScript 的时候有 npm 依赖包的提示。特别是引用的过程中会有丰富的提示。\n\n\n强大的代码格式化插件名：Prettier - Code formatter\nPrettier 是一个代码格式化程序。它通过解析代码并使用它自己的规则重新打印代码来强制实现一致的样式，这些规则考虑到最大行长度，在必要时包装代码。\n在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧我们可以通过在settings.json中强制让一些特定语言用这个格式化工具。在settings.json中添加以下配置。\n&#123;\n  &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;,\n  &quot;[javascript]&quot;: &#123;\n    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧个人还建议设置编辑器在保存时自动格式化。在settings.json中添加以下配置。\n&#x2F;&#x2F; 全局配置\n&quot;editor.formatOnSave&quot;: false,\n&#x2F;&#x2F; 按语言配置\n&quot;[javascript]&quot;: &#123;\n    &quot;editor.formatOnSave&quot;: true\n&#125;\n\n\n编辑器中的实时预览插件名：Browser Preview\nVSCode 的浏览器预览插件让我们能够在编辑器中打开一个可以真正的浏览器预览。浏览器预览是由 Chrome Headless 提供的，它的工作原理是在一个新进程中启动一个 Headless Chrome 实例。提供了一种安全的方法在 VSCode 中呈现 web 内容，并支持一些有趣的特性，如编辑器内调试等! 再也不用在浏览器和编辑器中来回切换而觉得麻烦了！\n\n这个插件需要另外一个插件的支持Debugger for Chrome，安装了这个插件后只要按下面配置格式配置即可（配置要根据我们的项目而定，需要微小的修改一下）\n&#123;\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;configurations&quot;: [\n    &#123;\n      &quot;type&quot;: &quot;browser-preview&quot;,\n      &quot;request&quot;: &quot;attach&quot;,\n      &quot;name&quot;: &quot;Browser Preview: Attach&quot;\n    &#125;,\n    &#123;\n      &quot;type&quot;: &quot;browser-preview&quot;,\n      &quot;request&quot;: &quot;launch&quot;,\n      &quot;name&quot;: &quot;Browser Preview: Launch&quot;,\n      &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost:3000&quot; &#x2F;&#x2F; 把这里改为你本地项目的地址\n    &#125;\n  ]\n&#125;\n\n\n实时预览插件名：Live Server\n如果我们是在做一个静态页排版，这个插件可以提供给我们一个本地实时预览服务器，预览会在谷歌浏览器打开。相对于上面讲到的插件来说，这个比较轻量级。\n\n\n浏览器打开插件名：open in browser\n在开发本地文件的时候，可以安装这个插件，然后用默认浏览器打开。当然可以设置我们喜爱的浏览器打开哦。\n\n「六」PHP 开发插件VSCode 作为前端开发编辑器确实很强大了，但是这个编辑器不仅限于前端，作为一个后端编辑器也不差于其他 IDE 很多。\n我有很长一段时间一直使用 PHPStorm，但是发现用再高配置的电脑还是逃不过这些重量级 IDE 对电脑的 CPU 和内存的无限吞噬。\n随着几款轻量级编辑器的发展，包括SublimeText、Atom和VSCode。这些轻量级的编辑器加上活跃的插件开发社区，很多在 IDE 里面拥有的功能在轻量级的编辑器中都可以拥有了。所以最后我又回归到了轻量级编辑器中。\n最后我开始研究怎么用 VSCode 作为 PHP 开发的 IDE。这里分享一些非常实用的 PHP 开发用的 VSCode 必装插件集合：\n\nPHP 强化插件插件名：PHP Intelephense\nPHP Intelephense 是一个高性能的 PHP 语言服务器，它为高效的 PHP 开发提供了大量的基本特性。安装了这个插件基本拥有了 70-80%重量级 IDE 的辅助功能。\n它的功能包含以下：\n\n快速驼峰&#x2F;下划线大小写**代码完成(智能感知)**。提供文档、项目和内置符号和关键字的详细提示。自动添加使用声明。\n项目和内置的构造函数，方法和函数都有详细签名(参数)帮助辅助。\n快速项目中的跳转定义支持。\n项目内查找所有引用。\n项目内快速搜索“驼峰&#x2F;下划线”的符号\n完整文档符号搜索，也支持breadcrumb 和outline UI。\n通过一个容错解析器和强大的静态分析引擎诊断打开的文件。\n兼容 PSR-12文档&#x2F;范围格式。格式化也适用于 HTML&#x2F;PHP&#x2F;JS&#x2F;CSS 文件。\nHTML 请求转发到 HTML 语言服务器完成HTML&#x2F;JS&#x2F;CSS&#x2F;PHP 代码智能提示。\n鼠标悬停显示详细链接到官方 PHP 文档。\n智能高亮参考资料和关键字。\n读取PHPStorm metadata以获得更高级的类型分析和提示。\n智能重命名符号。在适当的时候，文件&#x2F;文件夹也会自动重命名。(高级版)(https://intelephense.com)\n能精确的折叠代码定义，块，使用声明，heredoc，注释，和自定义区域。(高级版)(https://intelephense.com)\n快速找到和跳转接口和抽象类以及相关方法。(高级版)(https://intelephense.com)\n快速转到类型定义的变量和参数。(高级版)(https://intelephense.com)\n快速去声明实现接口或抽象方法声明的方法。(高级版)(https://intelephense.com)\n可配置自动 phpdoc创建，推断返回类型并识别抛出的异常。(高级版)(https://intelephense.com)\n\n提到的高级版功能需要另外购买，可以到https://intelephense.com实用支付宝购买。一次性购买价格是 70 元人名币（个人觉得相比其他 IDE 是年费的，这个还是很划算的）。\n这个插件基本上所有其他 IDE 又的功能它都给你提供了，有了这个插件我们的 VSCode 瞬间编程了一个全能的 IDE 编辑器。重点它还是比较轻量级的。\n\n\nPHP 规范检测插件名：phpcs\n这个 linter 插件为 Visual Studio 代码提供了一个到 phpc 的接口。它将与具有“PHP”语言模式的文件一起使用。\n如果小伙伴们一直都有用 linter，那这个插件装上，可以配合我们项目中的 phpCS 设置的 linter 一起用，就可以自动格式化代码或者在 VSCode 中也会提示格式错误了。\n\n\n「七」Java 开发插件个人没有做过多的 JAVA 开发，所以也没有深入研究，但是 VSCode 也有很多 Java 开发者在使用。所以也有对应的支持。\n用来支持 Java 的插件有好几个，但是官方有做了一个 Java 插件全家桶，一键安装好所有 Java 支持的插件。\n插件名：Java Extension Pack\nJava Extension Pack (Java 插件全家桶) 是一组流行的插件，可以帮助在 Visual Studio Code 中编写、测试和调试 Java 应用程序。\n这个全家桶包含了以下插件：\n\n📦 Java 语言支持（Red Hat 提供）\n代码导航\n自动完成\n重构\n代码片段\n\n\n📦 Java 调试器\n📦 Java 测试运行器\n项目脚手架\n自定义目标\n\n\n📦 Java 依赖查看器\n查看 Java 项目、引用库、资源文件、包、类和类成员\n\n\nVisual Studio IntelliCode\n开发辅助\n完整的代码填充\n\n\n\n\n\n其他语言支持使用 VSCode 开发其他语言也是完全可以的，只要在插件搜索栏输入我们想用的语言，就可以找到那个语言的相关插件和支持。\n\n\n「待续」总结\n对于一个个性化的编辑器，一箱好用的插件是必备的，没有插件的 VSCode 就等于没有了灵魂。这文章介绍了一大箱不同分类的超级实用、好用和常用的插件。\n但是这么多插件，一个一个安装，是不是想想都想放弃？还有一部分童鞋会说“IDE 的插件基本上都是安装好的，这个太麻烦了”。说实话确实很麻烦，特别是公司一台电脑，家里又一台手提电脑，两台电脑都需要安装这些插件，想想都崩溃了。\n当然每一个问题都有解决办法，VSCode 也有插件专门解决这种问题。VSCode 的Setting Syn可以帮助我们同步自己的插件，编辑器配置和自定义快捷键。让我们在新的环境或者电脑上，马上拉取以往的所有配置，再也不需要一个一个重新配置。\n下一篇文章我会详细讲说怎么配置和怎么使用配置同步插件。敬请期待哦！\n","slug":"tools/vscode-plugins","date":"2020-04-25T17:55:05.000Z","categories_index":"Tools","tags_index":"VSCode,VSCode Plugins","author_index":"三钻"},{"id":"dc4e2e8dd5224ff3b1a1b269ea5930dc","title":"VSCode常用快捷键大全","content":"我之前也是用过很多代码编辑器，从NotePad++、SublimeText一直到PHPStorm，最后VSCode。这个过程每一个编辑器我都折腾了很多配置，插件和主题。开发者的编辑器就等同于一个刀客的随身佩刀，一个枪手的随身配枪。一个好的装备的配件可以大大提升我们的战斗力。\n所以对于一个好的程序员，一个好的代码编辑器可以起到很大的作用，在开发的过程中可以给我们带来很多便利、帮助、效率和影响。甚至一个好的编辑器可以给开发者日常编程中带来更高的喜悦感。\n枪手挑选一把枪会通过几个纬度来选择：重量，击倒力，子弹量和精准度等等。那对开发者来说也一样的，我们会考虑这个编辑器的插件，扩展性，兼容性，功能性，美观和快捷键等等。\n其中我们最在乎的就是：\n\n“有多少实用的插件给我们带来开发便利和效率”\n“能否兼容我们的编程语言”\n“有没有定义或者方法跳转，让我在复杂的代码中定位到方法、变量和函数”\n“代码要看的舒服，代码高亮要优美好看，养眼”\n“有常用的快捷键，提高开发效率（最好让我不需要用鼠标）”\n\n\n\n\n\n\n\n\n\n\n🌟 总结一下其实就是“让我们写代码更快速，更愉悦，更舒服”\n\n「始」前沿\n要全面教大家高效使用 VSCode，就要讲到 3 大板块：快捷键，插件和配置。因为内容非常之多，所以我拆分成了3篇文章提供给大家学习。（感兴趣的童鞋可以关注一下哦 😁）\n这篇文章主要详细讲解VSCode的常用快捷键，让大家在 VSCode 中编写代码时，更加的顺手，基本可以脱离鼠标。\n基本上记住这些常用的快捷键，我们就可以马上提高使用 VSCode 的效率，也会提升我们编写代码的速度！\n让我们一起成为 VSCode 的高级玩家！\n\n「一」编辑器使用先讲讲使用编辑器功能的快捷键，这些可以让我们更快捷和顺手的使用 VSCode 的一些常用功能。同时可以使用这些快捷键挖掘更多编辑器的隐藏功能哦。\n\n快捷键列表查看「View Shortcut」如果想查看所有快捷键的童鞋，可以使用一下快捷键：\n\n\n\n\n\n\n\n\n\nMac：Command + K，再按Command + S\nLinux&#x2F;Windows：Ctrl + K，再按Ctrl + S\n\n\n\n\n\n\n\n\n\n🌟 如果需要快速查看某一个特定的快捷键，只需要快捷键列表上方的搜索栏输入直接搜索即可\n\n快速打开文件「Quick open」可以用于快速搜索，然后打开项目中的文件，当你想在一个大型项目中打开某一个代码文件时，此方法非常实用。\n\n\n\n\n\n\n\n\n\nMac: Command + P\nLinux&#x2F;Windows：Ctrl + P\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧\n\n输入?可以查看帮助文档\n搜索中会优先列出最近打开过的文件\n如果想打开多个文件有两种方法：（会在背后打开新的文件，搜索不会被关闭）\n打开新文件 Mac: Option + → 或者 Linux&#x2F;Windows：Alt + →\n多窗口打开 Mac: Command + → 或者 Linux&#x2F;Windows：Ctrl + →\n\n\n\n\n编辑器命令「Command Palette」在搜索加上&gt;前缀就可以调用命令了。编辑器的命令可以做很多，可以快速搜索快捷键，还可以执行插件的一些命令，非常实用哦！\n\n\n\n\n\n\n\n\n\nMac: Command + P\nLinux&#x2F;Windows：Ctrl + P\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧\n想快速查看快捷键按钮也可以通过这种方式搜索。\n\n拆分编辑器「Split Editor」在开发的过程中，我们会经常打开几个文件同时编辑，特别是高度封装的代码就会同时在更改多个文件。\n前端就更不用说的，很多时候我们都在同时编辑 HTML，CSS 和 JavaScript 文件。\n编写 Vue 的时候就更难受了，HTML 和 CSS 和脚本都是在一个文件中，代码会非常的长，把当前文件在同一个编辑器拆分开，然后分别滑动到 HTML，CSS 和脚本部分就可以同时更改了。​\n\n\n\n\n\n\n\n\n\nMac: Command +\\ 或者 2,3,4\nWindows: Shift + Alt + \\ 或者 2,3,4\nLinux: Shift + Alt + \\ 或者 2,3,4\n\n\n编辑器网格布局「Editor Grid Layout」默认情况下，编辑器组是垂直列布局的（例如，当您拆分一个编辑器，默认会横向拆分到右手边的）。但是很多时候拆分了多几个编辑器就会发现每个编辑器的宽度会越来越窄，可视度就会大大下降。这个时候我们希望可以使用网格布局。所以我们可以用编辑器的2x2 网格布局。\n\n首先我们需要创建空的编辑器组：打开方式查看 &gt; 编辑器布局 &gt; 2x2 网格：\n\n默认情况下，关闭编辑器组的最后一个编辑器也将关闭整个编辑组，下次要使用的时候需要重新开启网格布局，但是我们可以在setting.json的配置里改变workbench.editor.closeEmptyGroups: false。\n\n快速打开和关闭侧边栏「Opening and Closing the Sidebar」在我们专注于编程的时候，左边的侧边栏会占用我们一定的宽度，特别是使用双屏（尤其是竖向的屏幕）或者是使用拆分编辑器模式。​ 收起侧边栏可以帮我们节省很多空间。\n\n\n\n\n\n\n\n\n\nMac: Command + B\nWindows&#x2F;Linux: Ctrl + B\n\n\n快速打开集成终端「Open new Terminal」在开发的过程中，我们经常需要用到终端来执行命令。快速打开终端会给我们带来很多便捷。\n\n\n\n\n\n\n\n\n\nMac: Control + &#96;\nWindows&#x2F;Linux: Ctrl + &#96;\n\n\n「二」辅助代码编写接下来我们来讲讲在编程中常用的辅助快捷键。这些快捷键可以辅助我们提升编写代码的速度和效率，让我们的双手更集中 ​ 在键盘上，减少消耗在键盘和鼠标切换过程的时间。\n合并行「Join Line」\n\n\n\n\n\n\n\n\nMac：Control + J\nLinux&#x2F;Windows：使用上面说到的快捷键打开快捷键查询列表，搜索”合并行”（editor.action.joinLines），鼠标放在合并行的快捷键上，然后点击编辑图标，这里可以设置一个你喜欢的快捷键。\n\n\n代码格式化「Code Formatting」这个快捷键帮我们快速调整代码缩减，不过我更加推荐使用Prettier插件，这边文章后面会讲到。\n\n\n\n\n\n\n\n\n\nMac: Shift + Option + F\nWindows：Shift + Alt + F\nLinux：Ctrl + Shift + I\n\n\n清楚多余空格「Trim Trailing White Space」这个命令帮助我们清楚代码前后的多余空格，如果我们项目有设置严格的 Lint 规范，这个会帮我们减少多余空格的报错。\n\n\n\n\n\n\n\n\n\nMac: Command + K Command + X\nWindows&#x2F;Linux：Ctrl + K Ctrl + X\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧\n这个功能是可以自动执行的，不需要我们一个个选择去清除，我们可以在 VSCode 的配置里面设置自动清除。下面教大家两种配置方式。\n使用 settings.json\n\n打开编辑器命令（Mac：Command+P&#x2F;Windows：Ctrl+P）\n在搜索框输入&gt; Open Settings，然后选择首选项：打开设置(json)\n然后 settings.confg 中加入&quot;files.trimTrailingWhitespace&quot;: true，如果已存在这个配置，确保值是true。\n保存文件即可生效（如果没有马上生效，可以重启 VSCode）\n\n使用可视化（UI）设置\n\n打开编辑器命令（Mac：Command+P&#x2F;Windows：Ctrl+P）\n在搜索框输入&gt; Open Settings，然后选择首选项：打开设置(ui)\n在文本编辑器&gt;文件中找到Trim Trailling Whitespace并且勾上（我们也可以在搜索框直接输入Trim Trailling Whitespace快速找到这个配置的位置），可参考下面的截图。\n\n\n\n代码折叠「Code Folding」在开发项目中，很多时候前端的代码在单个文件下都会越写越多，当我们想专注看一部分或者寻找某段代码时就颇有困难了 ​。一般这个时候我们都会把一些不重要的代码段折叠起来。但是手动用鼠标一个一个点击效率是很低的。代码折叠快捷键在这种情况就非常实用了。\n折叠代码快捷键\n\n\n\n\n\n\n\n\nMac: Command + Option + [\nWindows&#x2F;linux: Ctrl + Shift + [\n展开代码快捷键\n\n\n\n\n\n\n\n\nMac: Command + Option + ]\nWindows&#x2F;linux: Ctrl + Shift + ]\n\n\n往上&#x2F;下复制行「Copy Line Up&#x2F;Down」在写代码的时候，我们经常会编写一些非常相似的代码连续几遍或者是先复制然后稍微更改一下。​ 特别是在 JS 中的require或者import这种引入包的时候。如果我们需要选中一行然后复制，回车然后粘贴，这波操作确实不够快呀，有没有更快速的复制方式呢？有的！\n\n\n\n\n\n\n\n\n\nMac: Shift + Option + ⬆️ / ⬇️\nWindows: Shift + Alt + ⬆️ / ⬇️\nLinux: Ctrl + Shift + Alt + ⬆️ / ⬇️\n\n当然，如果你不喜欢这个默认的快捷键，可以在快捷键列表中修改。\n\n选择单词「Select Word」很多时候在开发过程中，我们都会需要多个相同单词（多个变量名）同时修改，可能是局部方法中的单词，也可能是这个文件中的同名单词的修改。比较古老的方法就是用全局搜索然后替换。\n在 VSCode 中有一个更加快速和简便的方法，并且可以让你局部选择或者是快速全部选择。选中后就可以同时修改选中的单词了。\n\n局部选择首先选中你需要的单词然后按下面的快捷键即可：\n\n\n\n\n\n\n\n\n\nMac: Command + D\nWindows&#x2F;Linux: Ctrl + D\n如果我们多次按下快捷键，编辑器会继续往下找到相同的单词，然后自动选中。\n全局选中一样首先选中你需要的单词，然后按下快捷键即可：\n\n\n\n\n\n\n\n\n\nMac: Command + Shift + L\nWindows&#x2F;Linux: Ctrl + Shift + L\n这个唯一不一样的就是，这个会找到当前文件下的所有相同的单词，并且选中。\n\n跳转到特定行数「Navigate to a Specific Line」在排查错误的时候经常会用到的一个快捷键，我们需要找到当前文件下特定行的代码。\n\n\n\n\n\n\n\n\n\nMac: Command + G\nWindows&#x2F;Linux: Ctrl + G\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧结合我们上面学习到的，我们也可以先使用快捷键（Mac：Command + P）打开编辑器命令 然后输入: 再输入行数即可。\n\n文件中跳转特定符号「Go to Symbol in File」这里我讲解一下符号指的是什么，它就是在代码中的方法、类或者是属性。\n所以在一个比较大的代码文件中，这个快捷键会非常实用。能让我们快速找到想要编辑的方法、属性或者类！\n\n\n\n\n\n\n\n\n\nMac: Command + Shift + O\nWindows&#x2F;Linux: Ctrl + Shift + O\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧\n如果文件中的符号过多，我们可以在@后面加上:，就可以为所有符号分类让，我们更好找到需要的符号和位置。\n\n\n项目中跳转特定符号 「Go to Symbol in Workspace」这个快捷键与文件中跳转的雷同，唯一区别就是这个可以搜索出整个项目中的方法、类和属性，并且快速跳转到这些符号的位置。\n\n\n\n\n\n\n\n\n\nMac: Command + T\nWindows&#x2F;Linux: Ctrl + T\n\n\n删除整个单词「Delete Previous Word」在我们打错一个单词的时候，我们经常都会连续按删除键直到我们想要重新开始的地方。其实对我们程序员来说，打字都是飞快的，重新打过远远比一个一个字母删除来的快的多。（有些童鞋可能还会用鼠标来选中要删除的，其实在写代码的时候，可以不用鼠标尽量不用鼠标，这样速度会更快哦）只要按下这个快捷键就可以整个单词删除掉。\n\n\n\n\n\n\n\n\n\nMac: Command + Delete\nWindows&#x2F;Linux: Ctrl + Backspace\n\n\n按单词选择「Select by words」为了在编程中脱离使用鼠标，我们经常需要选中一行代码中的几个单词，这个快捷键可以让我们快速做到这样的操作。\n\n\n\n\n\n\n\n\n\nMac: Command + Shift + ← / →\nWindows&#x2F;Linux: Ctrl + Shift + ← / →\n\n\n快速复制当前行「Duplicate Line」用过 IDE 的基本都很熟悉这个操作，就是快速往下复制当前行的代码。这个在编程过程中也是非常实用。​\n\n\n\n\n\n\n\n\n\n其实我们可以选中一段代码，按下这个快捷键也可以 ​ 往下复制整个内容哦。\n\n\n\n\n\n\n\n\n\nMac: Command + Shift + D\nWindows&#x2F;Linux: Ctrl + Shift + D\n\n\n删除一行「Deleting a Line」用于快速删除一整行的代码。\n\n\n\n\n\n\n\n\n\nMac: Command + X\nWindows&#x2F;Linux: Ctrl + X\n\n\n往上&#x2F;下添加同时编辑「Add Cursor Above&#x2F;Below」用过SublimeText的同学应该都很熟悉这个功能。我们可以在多个位置添加鼠标编辑点，然后同时编辑。VSCode 也有这样的快捷键。\n\n\n\n\n\n\n\n\n\nMac: Command + Option + ↑ / ↓\nWindows&#x2F;Linux: Ctrl + Alt + ↑ / ↓\n\n\n\n\n\n\n\n\n\n\n🌟 小技巧\n如果想和上图一样，在属性的单词前添加好同时编辑鼠标点后，一下子即跳到所有属性名的最后面，我们只需要先在所有名字前面加入同时编辑鼠标然后用一下快捷键即可：\n\nMac: Command + →\nWindows&#x2F;Linux: Ctrl + →\n\n多行选中同时编辑 「Column Selection」这个快捷键需要配合鼠标一起使用。我们经常会在编写代码的时候选中一大串代码进行编辑，这个时候这个快捷键就非常使用。\n我们还可以按住这个快捷键，然后选择我们需要同时修改的位置，然后多个鼠标位置同时编辑哦！\n\n\n\n\n\n\n\n\n\nMac: Shift + Option\nWindows&#x2F;Linux: Shift + Alt\n\n\n修改“符号” 「Rename Symbol」VSCode 默认支持 JavaScript 和 TypeScript 的方法名、类名和属性名等符号修改。在修改后，文件下引用到这些符号的地方都会被自动的同时修改。其他语言的支持需要插件。\n\n\n\n\n\n\n\n\n\nMac: F2\nWindows&#x2F;Linux: F2\n\n\n「待续」总结这里我已介绍完所有常用的快捷键和编辑器中的使用小技巧。很多需要学习快捷键的小伙伴们不可能一下子就会使用和记住。温馨提示：​所以可以先收藏本文章，当需要的时候就可以马上搜索找到并使用。当我们用多了，也就自然而然熟能生巧了。\n当我们习惯于使用这些快捷键，我们就会发现我们代码编写速度都会有所提升的。\n下一篇 VSCode 高级玩家宝典，我会讲解 VSCode 中的所有常用插件（包括前端&#x2F;后端），敬请期待！\n","slug":"tools/vscode-shortcuts","date":"2020-04-19T12:18:46.000Z","categories_index":"Tools","tags_index":"VSCode,VSCode Shortcuts","author_index":"三钻"},{"id":"c6cc4f245503271cd2de19bf74610947","title":"写给想学和在学编程的你们，学习编程的7个好处","content":"你们有没有这种经历？亲戚或者爱人甚至是不做技术的朋友，看到我们屏幕上的小括号&#123;&#125;，大括号[]，还有一大堆的技术英文单词private，public，function等等，都会惊叹一句“你写的是什么呀？太可怕了，全是英文看不懂。”或者“做个程序员是不是需要英语很好的呀？太难了！” 其实当真正学习编程和做起程序员来一切并没有那么的可怕，也并不需要英语有多厉害。不信的小伙伴可以问问身边大多数的程序员，问问他们刚开始学编程的时候英语是不是很好，估计得到的大部分答案都是：“没有哈，不是的哈”。\n当然，如果你英语比较好，在编程的路上确实是会给你带来一定的优势。我们可以这么去想，会英语的看代码就等同于会是在看一本书一样，函数名，方法名其实都在描述这个代码是在做什么的。自然理解起来的时候就不需要很费劲了。加上学习新的技术和原汁原味的技术时，都会需要看国外的文章和文档，这些基本都是英文。但是不会英语也一样可以学好编程，也一样可以成为一名优秀的程序员。甚至在学编程的路上，你的英语也会有所提升。\n&#x3D;&#x3D;其实选择学编程是能改变人生的&#x3D;&#x3D;。可能起初很多人学编程，报了一个编程培训班，为了就是能拿到更高的工资或者有更好的工作环境。最后坚持着坚持着，最后会发现编程还会给我们带来很多个人能力和技能上的提升。\n\n「一」什么是编程？\n想开始学习编程或者坚持学习编程，我们首先要知道什么是编程？做编程的开发者是做什么的？这个行业是否合适自己？— 做为程序员，开发者和编程工程师，对外行人来说我们跟 TA 们说我们这些职称，基本 TA 们脑海里都会出现一个在修电脑或者修手机的我们。还会来一句“噢噢，做 IT 的呀？改天过来帮我看看我的电脑，开不了机了。”\n在 TA 们的脑海里就出现了这么一个画面 🤔：\n\n\n程序员是什么？我们用一个能让大家都懂的方式解说程序员做的编程工作到底是什么：\n\n\n\n\n\n\n\n\n\n如果现在我们需要一把剑，那我们就会找造剑的工匠。 同等现在我们要做一个手机 APP，一个网页系统，一个软件或者一个电脑工具，打造这些的工匠就是程序员。\n\n🌟简单的说“程序员和开发者就是打造软件或者互联网产品的工匠，我们的材料就是全英文的代码，我们的工具就是代码编辑器（IDE）”。\n这样说外行人应该就懂程序员，开发者，软件工程师是个什么鬼玩意了。\n\n前端和后端又是什么？好奇的人还会问，”听说开发还分后端和前端，那后端和前端又有区别呢？” — 好问题呀童鞋，这个真的让人难以解说了。不过不用怕，给大家两例子让 0 技术基础的 TA 们都能听的明明白白。\n后端解说例子：\n\n\n\n\n\n\n\n\n\n后端写的程序就是一个货物仓库中工作人员的指挥部。来仓库找材料的人需要 10 万个“外科口罩”。这个时候指挥部先找到这个口罩在仓库的具体坐标，然后会发出指令告诉仓库工作人员去到某一个地区的货架，第二排找到这口罩，最后搬过来给到需求方。\n\n转化为技术专业名词：\n\n找货物的人 — 就是调用后端接口拿数据的一方\n仓库指挥部 — 后端编写的程序\n仓库 — 就是保存资料信息的数据库\n仓库的货物 — 就是数据库里面的数据\n\n前端解说例子：\n\n\n\n\n\n\n\n\n\n如果后端操控存放货物的仓库，那前端就是建筑师，前端主要的工作是建立店铺和装修店铺，然后从仓库获取货物到店铺中展示。一个店铺中货物必须分类摆放，有条理，好看才会有人买。所以前端还会规整货物，让货物分类摆放，同时让客户容易找到还好看的舒服感，自然就会有更多的客人来店购物。\n\n转化为技术专业名词：\n\n店铺 — 就是前端打造的页面\n建立店铺和装修的材料 — 就是前端页面排版\n店铺中的货物 — 就是后端给予前端的数据\n取货 — 就是前端请求后端获取数据\n\n\n还有比较常见的两个方向，前端和后端。当然编程还有很多方向，比如“算法工程师”，“运维工程师”，“测试工程师” 等等。这里我就不一一细说了。有需要了解其他的可以在评论区给我留言。\n我们需要了解清楚什么是编程，开发者们做的是什么。程序员用编程打造软件产品的工匠，给人类带来更便捷的工具与平台。让我们可以通过手机，电脑加互联网来自动化，系统化，智能化的完成我们的工作或者沟通。甚至可以高效提高很多行业中工作的效率，解决很多繁杂的操作和任务。还可以给我们带来信息快速传播和展示的作用。每个程序员都有一个梦想：“用代码改变生活，用代码改变世界！”\n\n「二」学编程的好处学习编程其实没有想象中那么难，但是也并非一条容易的道路。在学习编程的过程中最困难的就是动力和坚持。一开始学习的时候我们会很感兴趣，每做出一个小功能后会感到非常有成就感。可是当我们越学越多，越学越难之后我们会开始觉得枯燥无味。一个问题或者一个难题可能都要好几个小时，甚至是一天两天才得以解决。所以不论是我们在学习之前还是在学习中工作中，我们都要有发自内心的热爱和动力。\n所以我们需要找到我们学习编程的好处，我们能得到什么，能改变什么。这样我们的毅力和动力才能得以持续维持。我希望通过接下来的分析，能给到感兴趣但是也不是很有动力的童鞋开始学习编程，在学习编程中有点迷茫的童鞋更能坚持下来，更加热爱这一条道路！\n\n1. 拥有把想法转化成应用的魔法做为一个程序员，最有成就感的一件事情就是能把一些想法，一些有趣的点子通过编程把它们转化为应用。一个可以操作、可以体验和可以帮助很多人的应用。但是如果我们不懂编程，我们就只能找技术来帮助你实现。但是开发成本太昂贵了，最终就选择放弃。\n估计大家在这个互联网时代中，每天日复一日的生活中，都会有那么一瞬间觉得 “有那么一个 APP，那么一个平台，我们做某一件事就会方便多少，就会简单多少” 。但是我们不懂编程，不懂技术，无法去实现，所以到了最后我们就会与这个很好的想法擦肩而过了。也许当过了几个月后，就会发现有人做出了这么个应用，和你当时想的是一摸一样的，就会开始觉得，“诶，如果我能自己做，现在看到的这个应用就是写上了我的签名，在改变大家生活和人生的人就是我了”。\n在现实中，如果要一个想法落实到生产出应用也绝非易事。人在大脑构思出来的想法，要表达出来给到产品经理整理逻辑，转化成原型。然后通过原型还需要 UI 设计师转化成设计稿，最终到开发者手上再理解一才能真正开始研发。但是多少想法在这个过程中被人与人之间的沟通，传达，理解所被丢失的细节呢？所以最终做出来的产品往往不是完完全全和一开始构思的一摸一样。\n其实很多开发者都是在这个研发流水线中的一员，研发部没有了产品，没有 UI 设计，前端就无法排版，后端就无法研发。不知道大家有没有留意大厂或者是国外的开发者。很多前端都是懂 UI，懂设计理念，甚至是两者兼备的。然后后端都是懂前端，起码有前端知识的基础。为什么呢？因为一个想法经过越少的人，就会丢失越少的信息。这样做出来的产品才能与当初想的越贴切。当然，如果研发中心的每个部门的人都是牛人，必然能打造很好的产品的。但是中小型的公司的人员能力参差不齐，在我以前待过的中小型公司的老板都是天天跟着产品，设计和开发的屁股盯着。就怕最终产品走了样。\n俗话说的好“如果你想心想事成，最好的方法是自力更生”。也是因为这样我也走上了全栈开发之路。产品，设计，前端，后端和运维都专研了一遍。\n当然做为专研一个技术领域的开发人员也能做出很好的产品。比如说博客，个人网站，excel 处理程序，春节抢票工具等等。多少这些提高我们工作和生活的产品都是开发者自己在日常生活或者工作中，想避免一些繁杂的事情做出来的工具或者应用。\n但是如果我们不懂编程，就只能依赖于别人。**“因为懂编程，我们的想象力可以是我们的创造力”**\n\n2. 拥有强大的学习能力编程的世界是一个高速发展和变化的环境，也与星空一样知识是无边无际的。今日的编程实现方式与 5 年前的来相比，已经是截然不同了。每天每个编程的语言与 TA 们的框架都在升级迭代中。\n我们无法学会所有编程语言或者技术栈，不过我们是可以在某几个编程领域中发光发亮。只要我们坚持，专研，深度学习一门技术，我们必定会变成这一方面的专家。\n在编程的世界里，我们会找到很多可以学习和成长的空间。无边无际的知识海洋，就算一门语言我们学到了 TA 的巅峰境界，我们还可以去突破 TA，或者选择再学习多一门语言来提升我们自己的研发能力。所以在这种高速发展的技术领域中，我们的大脑的会被各种技术的知识开阔我们的很多思维。\n给大家讲一个我的经历：\n我入行编程事业的时候没有现在的前后端分离，后端是需要和前端混编的，而且一开始在中小型企业也没有完善的产品部，设计部，研发部。所以对于前端的知识还是需要懂的。我进入的第一家公司，没有产品经理，没有 UI 设计师，没有前端工程师，研发部就我一个人。一进入公司项目老大就跟我说，要我一个月做一个物流管理系统（ERP），并且要实现：商品管理，订单管理，进销存管理。然后商品和订单，需要与淘宝，天猫和京东对接上，可以实时同步。从产品的需求整理，沟通到设计和研发都是我一个人在弄。\n年少轻狂的我，毕竟是交代下来的工作，那就是一个字“干”！从不懂什么叫 ERP，到了解商品管理，多规格 SKU，订单状态流，入库出库单到学会对接第三方平台订单。一路过来有无数个不眠夜，无数个在写着写着代码就昏睡过去几分钟的经历。不止需要学懂业务，还需要自己排版，自己提升自己前端的能力。这个过程说长不长，说短不短，一个月我独立完成了商品体系，订单体系，进销存体系，订单同步完成了 80%左右。（后面公司招到了更多的开发，最后与 4 个开发者一起完成了这个系统。随后还做了客户管理系统 — CRM）\n说实话这个过程我有无数遍想过放弃和辞职，但是我出去又有什么本事去更好的公司呢？我当时的技术能力一文不值，去一个好的公司根本就是妄想。咬咬牙齿就继续坚持下来了。\n一点都不夸张的说，当时基本每天上班 18-20 个小时，眯眼就大概 2-4 个小时。但是事后，我发现自己学习能力，适应能力，抗压能力各方面都得到了飞跃性的提升。在我往后的技术生涯中有了很多帮助。当然我并不建议大家都进入这种玩命的公司来快速学习和成长。毕竟当时的我是被逼无奈。\n在我的这段经历出来后，我感觉自己脱胎换骨，对于技术的热爱半点不减，反而发现不停的学习和成长非常重要。过了那么多年后还在学习和成长的路上。\n不知不觉在编程的领域中，会发现我们的学习能力会得到不断的提升，因为我们每天都在学习和成长。而我们的未来还有无边无际的知识海洋在等着我们。\n\n3. 编程提升逻辑思维和分析的能力编程就是用逻辑思考能力把问题分解成一个个小问题，逐个突破。也是用分析能力把功能和任务分解成一个个小任务，然后小步快跑的去快速完成。\n逻辑思维能力在编程中我们会遇到很多问题，并且需要我们一个个的去解决。解决困难，解决问题是做为一个开发者必备的技能。大到技术架构，解决业务场景带来的难度和逻辑复杂度，小到解决系统中的问题和缺陷，使用逻辑思维去排查和修复漏洞。\n在每天的工作中开发者都是会面对各种各样的问题和困难，长年累月每一个开发者都会养成解决问题的能手。渐渐的我们会有各式各样解决问题的办法。一个我们经常用的口诀“先思考，后百度，再求助”。（个人推荐用 Google，更容易找到精准的答案）\n也是因为日常的不断锻炼和思考，让我养成一种逻辑思维来解决问题。每一个问题都会建立一套一套的逻辑思维方式和方法来解决。比如系统中的一个问题出现了，一个资深的开发者，瞬间就可以定位到问题并且给出解决方案。其中最重要的一个点是因为资深开发者长年累月的经验，还有就是熟悉解决问题的排查方法，一套高效快速的方法。\n分析能力作为一名开发者，每天都需要分析需求，功能，难题等等。分析、整理和思考都是每日的家常便饭。\n当一个需求到手的时候，开发者需要去分析里面的功能，把功能分解成一个个小块来进行设计，给出对应的实现方案。同时也需要我们去分析里面新增，修改，优化的功能对现有架构，功能和体系存在的影响和难度。最后定制出解决方案或者实现方案。\n除了需要分析需求，我们还需要去分析每个功能或者业务的流程和逻辑。比如一个系统中的登陆流程大概就是：经过编程的长期锻炼，我们的思维会发生改变，遇到每一件事情或者事物，我们都会解刨分析。比如讲到车，我们首先会把车分解成一块块来分析，引擎，轮轴，车胎和油箱等等，然后深度分析每一部分的作用和逻辑，从而明白整体车是怎么运作和构建的。\n编程的过程中，会培养我们的逻辑思考能力和分析能力。渐渐的会让我们成为一名先通过深度分析，然后用逻辑思维解决问题的大师。\n\n4. 用自动化程序为我们干活日常生活中，我们有很多重复的工作，极度的枯燥乏味。但是我们幻想一下，如果编写一个程序可以帮我们自动化的处理掉这些工作，是不是很舒服？这样我们就会有更多的时间思考，或者做更多有意义的事情。\n自动化，智能化都是现在科技高速发展时代经常听到的热搜词。目前给我们带来很多生活中方便的应用、系统和工具都是怎么来的呢？其实都是程序员用代码编写出来的。\n支付宝、微信、钉钉等这些应用大家都很熟悉吧，基本每天都会用到。其实里面帮我们做了很多繁琐的事情，比如说支付宝帮我们记账，分析出每月我们的支出。微信的语音功能可以自动帮我们转换成文字，让我们不方便打字，或者懒得打字的时候，录一段语音，点个按钮就转换成文字，还自动给我们加上标点符号。钉钉为我们引入了自动蓝牙打卡，不需要天天排队打卡，每个月还会自动生成考勤异常情况，分析出某个人某天缺了打卡或者某天有缺勤需要补一个调休。\n这些都是编程为我们日常生活中带来的方便和便捷。让一些需要我们坐下来花时间处理的繁杂事情变得更自动化、简单化和智能化。如果没有支付宝，每天我们还需要带着现金出门，不够现金了，还需要去一趟银行取钱。如果没有微信，我们可能还需要写信，然后出去邮寄才能与远方的朋友联系聊天。如果没有钉钉，每个月考勤情况，还需要我们去人工计算核对时间和缺勤情况。\n学会编程不止可以编写改变世界的代码，还能为我们自己日常工作或者生活中编写工具来节省时间。如果我们学会了 Python 编写 Excel 脚本来处理表格，自动填充和获取信息。根据我们每天在电脑的工作行为用脚捕捉写成日报表，甚至自动帮我们提交。自然就可以多出很多的时间来学习和做其他有意义的事情。\n\n5. 拥有高薪的职业技术行业的薪资相对比其他行业的平均薪资都会高一些。其实每一行都可以到达很高的薪资，每一行都有每一行的辛苦。但是一个永恒不变的定律，一分付出就有多一分收获。编程也是因为有难度，每天都是辛苦的脑力活，所以才会薪资高。\n其实程序员工资高也是因为当前是互联网和科技高速发展的时代，所以编程岗位也还处于非常短缺的状态。加上技术一直在发展，技术和互联网相对比其他行业还是属于一个成长期。很多新型的技术和语言每日每夜都在更新迭代。技术行业的岗位也是每年都在增加。从几年前的前端后端，到现在的人工智能开发，甚至到未来的机器人开发。\n技术行业的薪资体系，目前来看，我是觉得不是很标准的。这几年来面试的过程中，很多应聘者对自己能力的评估和价值都是有偏差的。但是我觉得相对其他行业，技术活都是凭能力说话，凭能力换来对等的报酬的。只要自己的能力强，技术的知识深度够，实战能力够硬。月入过万都不是梦。\n如果你们热爱高效的工作和无限的自我提升空间，大概你们会很喜欢和技术开发人员一起工作。我们是一群为了产出更有的程序而坚持提升自己，为了产出更好的产品而马不停蹄的提升自己的程序和代码。在这个领域中，会让你们大开眼界，扩大自己的思维瓶颈。每日都会发现各式各样的新鲜事物。能力的提升都会给我们带来对等的薪资提升，是一个越努力越赚钱的行业！\n\n6. 可以是一个有趣的业余爱好学习编程成为一名开发者，不一定是要作为你朝九晚五的一份工作。可以把编程当成一个我们热爱的爱好，甚至是一份副业。\n在我读大学的时候，我并不是一名读计算机专业的学生，当时的我特别热爱玩游戏，也特别喜欢写攻略。有一个公会里面的老大就跟我说，为什么不自己做一个攻略网站或者博客，还可以顺便赚一下广告费。就是这样我开始了自学编程，手把手搭建起自己的网站和博客，从此爱上了编程。\n大学期间我还接过很多做网站的外包，做过无数个网站和博客的主题开发。也赚了一些游戏经费和学习经费。到了后面我开始研究开游戏私服，自学了一些游戏开发，开启了游戏私服。\n这个过程中，我把编程当成了自己的一个业余爱好，也没有想过今天的我居然成为一名朝九晚五的程序员。回过头想想，编程给我带来了无比的快乐与成就感。作为一名开发者，可以让我们的想象力自由飞翔，实现我们所想，唯一需要的就是我们懂得编写代码， 代码，就能打造出我们心中所想的东西。无论你现在是想写一个网站介绍你自己，写一个博客记录你学习路上的种种，还是写一个无比有趣的小游戏。编程都可以如你所愿！\n编程对于任何人都可以是一个有趣的业余爱好，没有门槛。任何人只要有一台电脑，能上网，就可以开始学编程。编程是不受任何的限制。只要你愿意学，有兴趣，有毅力，你都能学会。\n\n7. 充满活力及友善的社区程序员是我见过最有趣，最可爱，相处起来最轻松舒服的一群人。程序员之间没有过多的勾心斗角，像其他行业团队里面那么多的宫斗剧上演。在我待过的团队中，比较多的都是热爱学习，热爱生活，热爱代码的一群热血青年。\n当然，凡事无绝对，都是有好有坏，也会有有一些比较让人恶心的程序员就希望自己每天工作中舒舒服服、一问三不知和一叫三不做的人。好在这些人还是占少数的，相对一二线的城市和有些规模的公司工作，普遍团队中的程序员都是比较好相处，并且在工作中会让我们非常开心有趣。\n每一个语言或者框架，都有一群充满热情和活力的社区等着你的到来。比如 CSDN，掘金，Segmentfault，Stackoverflow，GitHub 等等这些大型的技术社区有很多的热心和热爱技术的开发在维护着这个充满热情的编程世界。如果我们需要帮助，有无数的手会伸出来援助于我们。\n在学习编程和技术开发工作中，作为一名程序员，我们并不孤单。我们都是一个团体在一起努力，一起奋斗，一起并肩作战。还有网上的各路英雄好汉在江湖中奔跑着，随时可以认识到其他的开发者与你共同进步，一起终生学习，热爱编程，热爱生活！\n\n「终」总结这周我又写了一篇上万字的博文，给想学和在学编程的童鞋们打打气，也把我自己在编程事业中的感触分享给大家。最后我想大声的跟大家说：“对！无论我们当前是多大岁数，不懂英文也好，不懂电脑也好，编程都值得我们花时间和精力去学”。\n在这个技术和科技高速发展的时代，不懂编程就像古代中的文盲一样。你永远不知道你是否喜欢一样东西，直到你尝试它。所以对编程有兴趣的，想学编程的，现在就打开你们的电脑，开始投身到技术的海洋吧！在学习编程的你们，坚持再坚持，只要你努力，你坚持，就必定会成功！所有的付出都会得到收获，所有的艰辛都会换来未来的幸福，越努力越幸运，越努力越赚钱。\n在编程的路上，有无限的可能，也有无限的空间，只要你热爱它，它也会相应的回报努力的我们！让我们一起终生学习，用代码改变生活，改变世界！\n","slug":"notes/benefits-for-learning-programming","date":"2020-03-29T19:20:41.000Z","categories_index":"NOTES","tags_index":"Programmer,Better Programming","author_index":"三钻"},{"id":"bd0a0f50b0efbfb1fcedb431773e71b8","title":"用“易于改编”原则, 提升编程水平, 写出更好的代码","content":"无论新手还是资深开发者都会经常问一个问题，“怎么写好的代码？”，要知道怎么写好代码，首先我们要知道怎么样才是好的代码。要有明确的目标，才能知道如何达成目标。在《程序员修炼之道》中提到的“ETC Principle” -- 易于改编原则。这个原则看似简单，但是我们越是深入思考越是觉得“简约而不简单”。\n这篇文章里会详细解刨在实际产品研发中“易于改编”的原因和怎么做到“易于改编”， 从而让我们编写出更好的代码。\n\n「一」程序为何需要“易于改编”？\n为何代码必须要易于改编？因为一个系统是会随着一个产品的发展，每日有用户增长就会有一直做不完的需求。只要公司一直在运营着这个产品，需求就会随着公司的发展而改变。只要我们开发者一直与时并进专研新技术，我们就需要一直升级优化。\n只有了解清楚一个系统在一个生命周期中，具体什么会推动我们程序改变，从中我们才会更深刻明白为什么我们的代码需要”易于改编“。\n需求会变无论我们是研发任何系统，产品需求都是会一直变的。这个是永恒不变的命运。为什么呢？\n\n产品方向 — 随着产品的营销，运营，发展会推动产品需求一直新增，修改，优化。\n使用量 — 随着产品的用户量级，数据量级，并发量级也会推动程序的架构和策略上的变动。\n技术升级优化 — 甚至是我们使用的语言，框架，依赖包等升级也会引起我们的代码需要适应。\n技术债 — 可能是因为时间的限制，之前的代码重于实现而质量不佳。\n\n所以我们的代码会随着岁月的流逝一直在迭代升级优化。\n“可快速更变”是一个软件的核心近几年很多技术团队启用了敏捷迭代开发模式。什么是敏捷迭代呢？\n\n\n\n\n\n\n\n\n\n敏捷迭代就是把开发周期缩短到 1-4 周。小步快跑的迅速迭代交付功能上线。敏捷迭代的流程分别如下：\n\n确定需求 - 与老板和市场确认需求和流程\n需求评审 - 与开发同频需求里面的功能点和业务流程\n技术反讲 - 开发与产品同频需求，保证双方理解无误区，开发也需要评估开发难度和开发时间\n研发周期 - 开发人员开始投入研发直接到功能和需求开发完毕，转交给测试，在测试环境提测\n测试周期 - 测试和开发人员开始排除缺陷，修复所有在开发过程产生的 bug\n验收&#x2F;预发布周期 - 当测试在测试环境把所有 bug 排除掉后，当前迭代版本就会发布到预发布环境让市场和产品验收功能\n发布正式 - 当验收通过后，当前迭代版本就可以部署上线到正式环境\n正式回归测试 - 发布上线后，就会有正式回归测试，最后一道防线，保证系统加入的所有新功能都无问题\n迭代总结 - 每一期迭代结束后都总结这次迭代遇到的问题，持续优化，提高效率\n\n你想想如果一个 APP 或者系统，几个月甚至一年才更新一次功能和升级。我们用起来其实很枯燥的，甚至我们会发现很多问题，还有很多功能可以便捷或者提升我们的使用体验。但是这么久才更新一次，我们还会对这个产品抱有希望吗？（除了微信这种已经很成熟的应用，但是就算是微信也是有持续更新的）。\n所以一个好的产品，是需要快速迭代，小步快跑的迅速迭代交付功能上线的。也是因为这样，功能就需要持续更新、升级和优化。自然我们研发的代码就需要一直随着产品的变化而改编。而且还是每 1-4 周就会升级优化一次。\n\n\n\n\n\n\n\n\n\n🏆小总结一下：\n\n一个系统会随着产品的发展和迭代，一直走在改变和更新的道路上。\n因为系统一直在变，代码就需要响应系统的变化，持续的快速迭代升级优化。\n既然代码需要快速的更变和升级，那程序的“易于改编”性就必须要高。\n\n\n「二」如何做到“易于改编”？\n我们深刻懂得为什么系统会一直在改变，那我们就要知道怎么写代码才能让一个程序“易于改编”，然而在敏捷迭代中才能快速的响应需求的变化。如果想让我们编写的程序更容易的响应需求改变、业务改变和逻辑改变等，我们就要充分的给我们的程序解刨逻辑。\n说到逻辑与业务的分解，首先要根据需求和功能深入思考分析，然后对其进行一个架构的设计。最常用的方式就是把系统模块化，组件化等的系统架构设计。\n模块设计 —「Modular Design」\n\n\n\n\n\n\n\n\n模块设计，就是以功能块为单位进行程序设计，实现其求解算法的方法称为模块化。模块化的目的是为了降低程序复杂度，使程序设计、调试和维护等操作简单化。\n不论是前端开发还是后端开发，我们都有模块化和组件设计模式。使用模块设计来分解我们的功能和逻辑，目的是为了降低程序的复杂度、利于调试、维护、修改和新增功能。\n比如现在我们要做个 CMS（内容管理系统），我们一起来尝试使用模块设计来分解这个系统的功能。\n\n设计思路首先我们要理解一个内容管理系统有哪些功能，然后把每个功能划入各个模块里。但是很多童鞋一开始接触一个系统，然后开始瓜分模块会觉得无从入手，可能花了半天坐在电脑前思考 🤔，但是半天都吐不出一个所以然来。接下来让我们一起来学习一套逻辑思维，让我们以后更轻松架构一套模块设计吧！\n\n一开始先思考这个系统的目的和使用场景，这个系统是用来做什么的？\n一个内容管理系统，一般来说都是用来发发文章，新闻，或者是一个官方网站的内容管理。那必定就有文章。那管理文章内容，需要什么功能呢？\n\n\n\n\n\n\n\n\n\n文章模块 「Article 模块」\n\n增删查改文章\n文章草稿\n文章置顶\n\n\n文章子模块 — 分类 「Article Category 模块」\n\n增删查改分类\n文章图片\n\n那这些与文章相关的功能是不是可以统一放在“Article”模块中统一管理，然后文章的模块中还有一个文章分类的子模块叫做“Category”。\n\n有文章了必定就需要有作者，那作者在系统中其实是一个用户。那我们就需要有用户模块了。 加上一个管理系统，必定就有管理员，作者，甚至是会员。走一波这个逻辑我们就发现应该要有以下的功能点。\n\n\n\n\n\n\n\n\n\n用户模块 「User 模块」\n\n用户增删查改\n用户身份管理\n用户权限管理\n会员等级管理\n\n这么一来我们就可以建立一个单独的User模块。这个模块主要是管理用户相关的信息和功能。\n\n看到这里我们应该对一个系统的模块构思有一点的概念了。这个时候产品经理过来给我们提了一个需求，“我们现在要在这个系统添加一个标签体系，专门用来管理文章标签的。”。\n那童鞋们，你们觉得这个需求应该放入那个模块呢？🤔….\n你们答对了！🎉 这个是属于文章的一个子模块，Tag模块 — 专门管理文章的标签，然后和每一篇文章有多对多关系的。所以标签模块归纳入文章模块中。如果我们的内容管理系统做的很大，里面有视频内容，图文文章等等。我们可以在一开始就把这些统一归纳入“内容模块”，也就是Content模块中。\n\n前端模块设计\n说到了这里前端的童鞋估计要举手咯 🙋‍♂️，前端的我们求关注呀！“前端是以页面和交互为单位，不可能和后端一样按功能逻辑来分解模块吧？” — 这个童鞋说的在理哈。其实前端和后端的设计上是有稍微的不一样的。\n后端会以业务逻辑来分解模块，但是前端有页面和数据逻辑两块的代码。所以前端相对比后端就要分开两种模块分解思路了。\n页 (排) 面 (版) 的模块设计\n\n前端的页面模块与产品定义的系统模块会更加贴切一些。前端分解的模块会跟用户所看到的操作功能分组。\n简单的模块分解，可以利用产品童鞋给到我们的导航来分解，这样会更合理的规整我们的页面模块。\n如果在页面功能上再想细分，那就可以用组件设计来分解了。\n\n前端逻辑模块设计\n\n几年前的前端就是个“切图仔”，基本不用考虑什么业务逻辑，数据逻辑，数据交互这些技术领域。但是因为前后端分离现在已经变成大多数公司的研发策略。慢慢前后端都各自分摊了业务逻辑和数据交互等处理。\n\n因为前端也有大量的业务逻辑和交互逻辑，所以在我们封装和解耦的时候，也会遇到需要分解模块来处理。现在最典型的例子就是在使用Vue的状态管理Vuex的时候，需要用到模块管理来分解逻辑，使后面维护和修改更容易。\n\n其实前端也是用后端同一套思维模式来分解业务就可以了，以功能为单位来分解你们的模块就可以了。\n\n\n\n解耦 - 「Decoupling」\n\n\n\n\n\n\n\n\n解耦，就是把复杂繁琐的逻辑拆分成更小的逻辑块。从而让复杂的逻辑分解成小的逻辑处理，使得逻辑变得更简化，更易于调试和维护。\n在一个功能众多、业务复杂和系统模块繁多的系统中，每一个模块里面的代码也会开始变得臃肿，越来越难调试、维护和管理。其实模块化和解耦是一致的。模块化也是为了解耦你的程序。这里我们重点讲的是模块之间和逻辑之间的解耦（Decouping）。\n\n\n\n\n\n\n\n\n\n我分享一个经历让大家深刻认知到解耦的重要性。我遇到过最夸张的有一段逻辑处理写了上 5000 行代码的童鞋，然而更可怕的是，在相同功能的地方那 5000 行代码被复制粘贴过来了。😱 我滴乖乖，这位童鞋在研发小组中有个花名叫“复制兄”。不过得到大家的帮忙和提点下，后面他也成为了这个小组中的一名优秀的程序员。\n\n如果我们不懂得解耦代码，编写的代码会给我们后面带来很重的“技术债”。假设一下，你的 5000 行处理逻辑，在上数十个地方使用了。我们要改一下这段逻辑就难过登天了。就算是这段逻辑没有复用性，但当你需要回头去修改这段逻辑也是会让你头皮发麻，无从入手。修改一点这个逻辑都可能会导致出现 10 个 bug 的后果。\n我们深刻知道解耦的重要性，那么我们应该怎么去高效解耦代码呢？\n在《程序员修炼之道》中的 Design by Contract 里提到我们编写“害羞”的代码是很有益处的。“害羞”有两个含义：“不要把自己暴露给别人”和“不要与过多的人相互影响”。 这个是什么意思？我们用书中的例子来理解一下。\n在一个庞大的间谍组织中，特工们会分到各个小组，每个小组内部的特工基本都互相认识，但是各个小组之间的特工就都互不相识。假设某个特工被俘虏了，一个小组可能会被摧毁，但是其他小组的特工是不会被暴露被影响的。因为各个小组之间的关系都是绝对隔离的。但是在任务中，各个小组之间都是会有合作和互相帮助，但是都互不相识。所以这么庞大的间谍组织才能长期安全存活下来。\n这个种隔离模式用在编程中是非常好的。把我们的代码解耦到相对独立的模块和方法中，让它们之间的关联性和影响性降到最低。如果一个模块或者逻辑方法出了问题，我们可以独立重构或者修复，而不会给其他模块带来巨大的影响。只要最终的结果是一致的，就可以完美优化升级或者修复了。\n在程序中，我们需要一个Service (服务)给我们处理一个Object（对象），或者请求一个服务获得一个Object，我们希望这个服务给到我们需要的结果，但是不需要我们去操心它是怎么处理与获得这个Object的。这个服务或者方法是独立运行的，里面的逻辑和代码是与我们写的代码绝对隔离的。我们只需要在获得结果的时候验证这个结果的可用性就可以了，如果结果与我们需要的不一致，那我们就可以抛出错误。只要这个服务做对应的修正，就可以继续运行了。\n理论我们解说的差不多了，现在我们来个实战例子吧：\n案例：假设现在我们需要写一个获取天气预报数据的类，获取天气预报数据首先你需要提供Geolocation 定位信息参数。Geolocation对象中含有一个地址对象。里面有经纬度，省市区等数据。我们需要获取到地址中的经纬度才能得到精准定点的天气预告信息。我们的代码会这么写：\n&#x2F;**\n* 获取天气方法\n*&#x2F;\npublic function getWeather(Geolocation $geolocation) &#123;\n\t&#x2F;&#x2F; 假设我们已经封装了一个获取定位的天气的方法叫getWeatherByGeo()\n\treturn $this-&gt;getWeatherByGeo($geolocation-&gt;getLocation()-&gt;getLat());\n&#125;\n\n\n我们通过getLocation方法获取到定位对象里面的地址对象\n然后通过getLat()方法获取到定位地址的经纬度信息\n\n以上例子中，因为我们需要在geolocation对象中取到经纬度，所以我们需要先经过获取地址对象，然后再通过这个对象获取到经纬度。其实这里面有不需要的关联关系。无论是写服务，还是写对象方法，我们都不要让使用这个服务&#x2F;对象的开发者去过度的理解和使用你关联性很强的内部方法。这样会导致如果我们那天改变了这个关联性，多处都需要修改代码。\n如果那天刘某改了Geolocation对象，里面不再含有Location对象，而且也没有了getLocation()方法，经纬度可以直接在Geolocation对象中直接取得。这个时候所有之前运用这个对象的其他人都需要修改代码了。很多时候开发者很难修改代码，或者一改动就会伤筋动骨的，其实就是因为这种过多过度的关联性关系导致而为的。\n所以作为Geolocation对象的封装者，我们应该直接给到一个方法getLat()，让调用这个对象的开发者直接能拿到所需要的信息：\n&#x2F;**\n* 获取天气方法\n*&#x2F;\npublic function getWeather(Geolocation $geolocation) &#123;\n\t&#x2F;&#x2F; 假设我们已经封装了一个获取定位的天气的方法叫getWeatherByGeo()\n\treturn $this-&gt;getWeatherByGeo($geolocation-&gt;getLat());\n&#125;\n\n这样就剪断了刚刚对象中的强关联关系的缺陷。\n\n服务化 — 「Service」服务定义：\n\n\n\n\n\n\n\n\n\n角色：服务是系统架构里面的业务处理层。作用：主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。\n理解服务\n假设人是一个控制器，现在拿到了一个衣服对象的参数，然后人拥有一个洗衣服的方法\n现在人需要洗衣服，但是手洗效率太低了，所以我们写了一个多功能的洗衣机服务给到人去使用\n洗衣机这个服务里面有很多不同洗衣服的方法，但是其实具体洗衣机里面的每一个清洗方法人是不知道怎么实现的，人都是直接按照提供的功能直接使用。\n所以服务里面的所有方法都是解耦在服务里面，服务要提供的方法是可以方便人使用的。\n\n\n这样说是不是很好理解了？所以最简单的理解就是：\n\n\n\n\n\n\n\n\n\n服务是用来封装业务逻辑代码，是一个独立的逻辑层，高度封装解耦后提供给控制器或者其他需要用到这个服务的地方使用的。\n\n编写思路❌ 错误例子\n\n\n\n\n\n\n\n\n\n把所有洗衣机的方法提供给人使用，那就等同于让人来决定所有洗衣机的参数和清洗步骤。当人放衣服到洗衣机后，要选择先加水，加多少水，然后清洗开始，清洗多久，再甩干等等。\n光想想，洗个衣服还那么多的选项，还要想怎么样的洗衣顺序才是正确的！ 我太难了！洗个鸡腿哦！(ﾉ｀ □ ´)ﾉ ⌒┻━┻\n⭕️ 正确例子\n\n\n\n\n\n\n\n\n\n洗衣机服务实现了很多不同的常用洗衣服的模式, 比如快速清洗，毛衣清洗，地毯清洗，风干，甩干等等。都是一些常用的功能。每个功能方法里面其实调用了很多洗衣机封装好的流程和方法。所以当人使用洗衣机时，根本就不需要知道这些功能是怎么实现的，只要知道自己要干嘛，洗衣机刚好也有这个模式，直接用就完事儿了。\n(✧ᗜ✧)👍 哇！ 介么人性化的么！这种洗衣机给我来一打谢谢！\n我写过一篇详细关于编写服务的文章《你真的懂怎么写服务层吗？》，有兴趣的童鞋可以前往查看哦。这里我就不详细解说了。\n\n总结\n这篇文章已经到达尾声了，到了这里我们已经深刻知道何为易于改编原则，更懂得如何编写易于改编的代码。其实在开发的过程中，我们还是需要先思考，后设计，再编写。根据所拿到的的功能需求，做好程序的架构设计，从而写出易于改编的程序。只有这样我们编写的代码才能越来越好，走上技术巅峰！\n\n\n","slug":"notes/easy-to-change-principle","date":"2020-03-22T23:19:00.000Z","categories_index":"NOTES","tags_index":"Programmer,Better Programming","author_index":"三钻"},{"id":"4c45a5d6250916c34f3f63c144ebcf77","title":"5大法则助你 成为更出色的开发者","content":"在现在这个技术高速发展的时代，无论你是在校学生，还是技术职场中的精英，都会面临需要持续提升。但是如果只知道提升技术能力，忽略了一些技巧和技术素养的培养和习惯。你会发现你再有能力，也变得无用武之地。因为真正的强者是不会只依赖 TA 的装备。更多的是技巧，经验，应变能力还有思想。\n这篇文章会教 5 大法则助我们成为更出色的开发者，在众多开发者中脱颖而出的诀窍，也会在我们的技术职业生涯中给我们很多的帮助。\n\n一、先思考，后设计，再下手\n多数拿到新功能需求，大致有思路就直接下手开始写代码，半天下来发现这个需求或者功能越想越复杂。前进的路开始迷茫，内心越来越烦躁（甚至开始埋冤产品，这个需求怎么搞那么复杂，太坑了！），秃头的噩梦开始了。(╯ಠ_ ಠ）╯\n其实开始写代码之前，思路就没有整理清楚或者目标不明确，想着想着就偏离了初衷。越深入考虑就越复杂，考虑到解耦代码，封装服务，设计数据库，扩展性，通用型等等这些因素。想想都已经迈入了从 0 到放弃的节奏了。甚至遇到过“杞人忧天”的程序猿小哥哥，小姐姐。TA 们问我说：“如果那一天服务器在我处理的时候停电了怎么办呀，如果服务器爆炸了呢？！”（这种绝对不夸张，还真的有哈）\n其实就是因为前期没有充分的思考和设计所以才会导致后面的手慌脚乱。\n深度思考投入代码的海洋之前，我们需要先深度思考这个功能需求，整理清楚它的目的，场景，难点。\n\n明确目的 — 明确功能需求的目的，了解清楚它是用来做什么，为了达到什么目的。好比如现在是要开发一个文章搜索。一听到这个，你会想到什么呢？文章标题搜索？全文搜索？拆词搜索？标签化搜索？还能想到更多各式各样的搜索功能可以在这个功能需求中实现。如果不明确目的是什么，可能一开始就想复杂了。最终可能只是需要一个简单的标题搜索而已。而我们花了半天在想一大堆的可能性，系统要承载这个功能需要如何设计。\n\n使用场景 — 场景因素决定了这个功能的技术架构，也决定它的难度等级。那场景到底是什么？其实就是这个功能规模的影响因素，举个例子：后端来说场景可以是这个文章搜索涉及的数据量级，还有使用的用户量级和并发量级。这些都是会直接关系到后端架构的设计，和代码的编写策略。那如果是前端呢？前端要考虑的因素有：这个搜索是否有重复使用性（是否需要封装成组件），是否需要加强的交互（比如，实时联想历史搜索或者关键词），是否涉及前端需要数据与交互结合处理数据来达到一些特殊交互。这些都是直接和前端的实现方式息息相关的。\n\n分析难点 — 明确目的，锁定场景后，就可以开始解刨功能需求找到技术难点。注意一个误区，这个思考过程不是决定技术架构和策略，这里只是单纯通过已有的关联性系统功能，技术能力范围，数据量级，用户量级，开发时效等因素排查出这个功能需求开发的难点。如果在这里就开始考虑到设计和策略，我们就会过多的花时间在一两个难点上，甚至过度设计。我们的重点是分析出某些部分的存在难度，先解刨出来，后面开始架构设计和策略的时候会特别注意到这些难点。\n\n\n\n\n\n\n\n\n\n\n\n小结一下： &gt; 在设计和开发一个功能需求前，有一个系统化的思考模式可以让我们快速的明白一个功能需求和整理思路！ 习惯先深度思考，可以大大提高自身技术的成长。慢慢我们会发现你分析一个功能需求会看的更加透彻，开发效率也会随之上升。\n设计与策略开发任何一个功能，特别是大型系统，我们都是需要有一个架构设计的过程。系统架构设计会包括：\n\n后端 — 数据库，设计模式，编写策略（例如：服务层封装）等。\n前端 — 组件封装，底层工具类，代码接受，模块化等。\n\n设计这个功能也是有一套方式方法可以提高这方面的效果和能力。\n\n画图 — 使用 UML&#x2F;思维导图&#x2F;逻辑图等工具整理自己的功能逻辑流程， 这个可以强化功能的背后的思路。通过画图可以完整的，可视化的整理了一遍你大脑中的功能逻辑思路。大大强化了这个逻辑在你脑海里的影响。在画图的过程中，你还会挖掘出一些细微的问题和缺陷，通过这个过程，你的逻辑思路会得到优化和强化。\n探讨 — “集思广益”，集合大家的力量必定比你一个人想强，所以设计出你的架构和逻辑图后，可以与你的伙伴一起探讨和分享。你会发想 TA 们可以看到你看不多的角度和观点。从而可以更加优化你的设计和逻辑。如果你有看过我写的《如果高效学习编程》，应该知道“小黄鸭教学法”，在你讲解你的设计和逻辑思路的过程，从思想转化为语言的过程，你已经在重新整理了一片你的设计思路和逻辑。你可能会在过程中发现一些你预想不到的全新观点。\nETC 原则 — “Easy to change” 易于改编原则来源于一本书叫《程序员修炼之道》，意思就是代码可以更容易被改遍的才是最好的代码 — “Good code is easy to change”。设计和编程中最重要的一个点就是，保持代码灵活和易于改编重用的架构技术。（这里我先透露一下，近期我也又在准备写一篇专门讲解有关此原则的文章，感兴趣的童鞋，敬请期待，可先关注本博主哦）。在设计架构的时候如果遇到两个或者多个选择，那就遵循 ETC 原则，选择扩展性高，易于改编更好的方案。\n\n\n\n\n\n\n\n\n\n\n小结一下：做好功能需求整理和设计模式的建立，对于功能需求的了解已经可以达到一定的深度和理解的相对透彻。这个时候就可以开始一头扎进去代码的海洋了。你会发现自己的代码会写的很顺畅，一种乘风破浪的感觉，恍惚敲代码都带风。\n\n二、把功能需求分解成小任务\n接到一个功能需求时，众多开发者都会觉得，这个需求含有多个功能点，感觉无从入手。还会有一种莫名的复杂感。这个是因为一个功能需求里面很多时候对开发来说都是参合了多个小功能。\n这个时候最好的解决办法就是尽量的分解需求为多个小任务。在《如果高效学习编程》中也有提到一个观点 — “化繁为简，小步快跑”，把复杂的功能拆分成多个小的点，也能让自己会迅速的开展工作。同时也会更有冲劲，每个任务如果太过复杂，实现时间太过长，会慢慢觉得枯燥无味，效率就会大大下降。\n如何分解需求？我团队的很多小伙伴一开始自己拆解功能需求的时候，经常会问我，“不知道需求怎么拆解，感觉拆的太细又不实际，但是如果不拆细，又觉得没有拆的必要“。这里我来给大家一些方法来拆解功能需求：\n\n按流程 — 每个功能需求都有一定有一个或多个的业务流，逻辑流，数据流。可以使用这个流程分解。 + 业务流 — 可以按照业务的流程拆可，比如注册账号，短信通知，推荐联系人。这个系统的注册到通知到推荐联系人。其实都是注册流程中的，但是我们可以按照流程拆开 3 个独立任务进行开发。 + 逻辑流 — 按照不同的业务逻辑拆分你的任务，使用相同注册账号的例子，可以拆分为：检测用户名重复，添加用户的逻辑，推送短信逻辑，建立短信发送服务等等。 + 数据流 — 也可以理解为按照查询数据的逻辑来分割你的功能需求。比如建立账户体系仓库，建立短信发送记录查询仓库等等。\n按功能模块&#x2F;体系 — 如果你接到的是一个大的功能需求，这个功能可能就含有多个功能模块在其中。比如我们要做一个财务模块，我们可以首先根据功能模块或者体系拆分：对账体系，提现体系，资金流水，银行账户管理，资金管理等等。\n\n\n\n\n\n\n\n\n\n\n小结一下：当我们接到的功能需求较大的时候，我们一定要把需求“化繁为简，小步快跑”的方式进行分解。这个会大大有利于我们提高效率。毕竟在技术开发中长跑是会精疲力尽的，小步快跑才能让我们高效使用脑力。分解需求还能让我们注意到更细微的功能点，那样我们不会在复杂的功能需求中遗漏一下微小的功能点。\n\n三、结队开发，代码评审\n在开发的过程中，开发者们往往会沈醉于自己的完美代码之中。我一开始也是如此，自己写了一个服务，无论是命名，写法，封装，逻辑设计，架构设计等等，我都觉得是完美无暇了，甚至觉得都被自己的代码美到了。但是越是这个时候，我们就越是无法发现美中不足。我们要接受一个现实就是没有最好，只有更好。\n首先要明白，自身的问题大部分人大概率都会是看不清自己的。内心的想法是：自己一直都是这么做的，所以不会觉得自己是有可以改善的点，也会总以为自己是对的。所以我们需要人来提点和指出我们的不足和缺点。人生如果有一面好的镜子是可以照出自己的不足，推动自己改变，成长，提升。不然人会深醉在自己的迷惑中无法找到自身的缺点，最终就是走入无法突破的瓶颈。\n在开发中也是，找一个或多个开发小伙伴审查自己的代码。因为每个开发者都拥有不同的经验。一个优秀的团队，每一个成员都有自身特别专研的领域和技术能力。或多或少都是一种互补的状态下组成的团队。所以互相审查代码可以达到互相学习，互相吸收彼此的特长和优点，然而达到最大化的互补，共同写出最好的代码。\n\n结队开发 — 其实结对开发，就是每次开发一个功能，你会分配一个伙伴，或者建立一个小组。待开发的过程中，可以彼此讨论架构和设计方案，实现方案等等，互补也互相学习利于成长，“两人搭配干活不累”。结队开发也能有效避免很多功能中的细微细节被忽略，还是那句话“两个脑袋必定比一个脑袋强”！\n坦诚的审查 — 在开发完一个功能后，找到你的队员互相阅读并且审查彼此的代码，从而互相提出宝贵的意见。 但是其实很多时候，因为彼此是同事也是开发小组中的战友，在“审查”对方的优秀“作品”的时候给最真实的反馈意见，往往我们和对方心里会觉得这是一种“批判”，一种“批评”。然而因为这种顾虑和心态，让我们在审查的过程中有一种莫名的压力和负担。所以给出的意见不能一针见血。“真实坦诚的话大多数人都不爱听，赞美的谎言都很中听”，也可以说是“忠言逆耳”。但是往往就是最真实的反馈意见是对彼此最有价值。也是这样才能在技术的道路上，让自己看到与明白自身的不足并且更好的去改进，从而在这条道路上彼此都能越发的走的更快更远。所以如果都想让自己和队员有快速成长，那就更需要我们对彼此的知识成果予以尊重，予以坦诚相待的态度，给予队员代码中不足之处的反馈，也谦虚诚恳的接受别人的意见。这是代码审查重中之重！在我的团队中提出使用结队开发，代码审查制的时候，我收到很多反馈：“我们本来就是敏捷迭代开发，时间很紧凑，不够时间去审查”，“每个人的技术能力参差不齐，有些人无法读懂彼此的代码”，“功能里面掺合着业务和功能需求的业务流程，对方没有做我的功能业务，看不懂呀”等等等等。一开始大家勇于提出了很多问题。\n\n那我们怎么搞？不用慌让我们来分析一下，提出解决方案：\n\n时间问题 — 敏捷迭代中，都是小步快跑，迭代周期根据项目而定，但是大致都是 1-4 周的范围之内。时间确实是比较紧迫的。但是互相审查代码这个好处实在是很多，所以就算要在敏捷迭代中耗费一点时间也是非常值得的。\n\n\n方案： 每个人在每天早上就花 1 小时，审查前一天小伙伴们提交审核的代码，然后在Gitlab这种代码管理平台中直接在代码中填写反馈意见。这样时间是可控的，也不会让开发者浪费太多时间在审查中。\n\n\n能力参差不弃 — 这个是审查中的问题，也是为什么更需要审查的原因。不触动互相审查，在团队中给彼此意见让团队的总体能力拉平，能力中的参差不弃的问题就永无法解决。\n\n\n方案： 首先开个群，或者开个会议，互相提出自己的优缺点，还有提出自己今年想提升的方面。找到团队成员各自的强项其实问题就好解决了。把强项和有这方面想提升的人结队开发，这样就可以发挥有强项人的能力，同时帮助了有这块短板的战友。而且，别人的强项也可能是你的短板，很少有开发者是方方面面都很强的。别人身上肯定有你可以学到的东西。所以彼此都有良好的学习文化和心态。\n\n\n业务不熟悉 — 其实代码审核不是去测试对方的功能和业务，我们是写代码的开发者，不是测试工程师。代码审查的主要目的是为了，提高研发质量，把控代码规范，提高编写能力，提高技术知识。\n\n\n方案： 所以我们让开发者互相审查的是，代码质量，实现方式，架构设计，代码规范，编写策略等方面，这种是不需要知道业务的，如果这些有涉及业务的需要才那么实现的，可以询问对方计算难点在哪里：是查询？数据的处理？审查的重点放在技术本事不是业务代码的层面上。\n\n\n\n\n\n\n\n\n\n\n小结一下：\n\n开发者基本上都是抱团工作的，这种环境下都是很适合互补互相学习的环境。如果想彼此有快速的成长，那就需要我们互相去给彼此提出坦诚又宝贵的意见，从中吸取彼此的优点和强项。这样每个人在这个团队中都会得到高速的提升。\n\n如果你所在的公司领导没有推行这种模式，可以提议一下，如果因为公司的情况不合适，可以自己组队互相分享代码探讨，这样还是能达到互相学习和提升的！\n\n\n\n四、在安静的环境中开发\n开发者在日常工作中，都是要高度集中，脑力全开的状态下工作的。所以环境造成的干扰对开发者而言是很影响效率的。一个难题，一段代码的思路，都是需要高度集中，在大脑中 1000QPS 的输出速度来思考问题和逻辑。所以如果在过程中被声音，交谈，或者其它环境的干扰，就会被打断思路，然后陷入一个不停的思路重组的过程，大量的时间都被消耗掉了。\n当年我刚刚当上了研发主管，开发于管理并行。发现自己每天都处于高并发状态，同时几件事情在处理，沟通，回答问题，协调工作，分析需求，与产品经理互怼，功能设计，功能规划，任务分解，然后就是研发。这一堆的事情都是日常必须要做的事情。我发现在研发的过程中，总会有那么一两个人来打断我的思路，当我大脑在全速前进的时候，突然在高速公路上出现了一个“程咬金”。解决了 TA 的疑问之后，重新投入研发，需要花至少 10 分钟重新整理思路和投入状态，大脑回归原来的速度。但是万万没想到，第二个人又来了。当时的我就感叹了一句，“做一个小小开发真的是太幸福了”。\n其实不只是技术管理岗会遇到这种问题，做一个研发组的开发者也会遇到，会有产品经理，测试，其他同事来请教你，给你指 bug 等等的事情需要和你沟通。所以这种干扰是无法在岗位或者职责上避免的。\n那我们怎么才能做一个静静的小开发呀？(ლ &#96;Д ́ )ლ，我来告诉你一些小秘诀吧：\n\n番茄工作法 — 给自己定好 20-60 分钟的高度集中的工作时间，这个时间内谁都不要过来打扰你，如果这个时间段有人来找你，你问一句“不好意思，我现在有点忙，事情紧急吗？不紧急我过 xx 分钟过来找你“。如果对方的事情是不紧急的，你就可以继续投入开发。到了一个 25 分钟阶段结束的时候，你再起来跟对方沟通。时间是很宝贵的，为了可以让大家高效沟通，也高效率开展研发工作。我们要高效运用时间。\n\n带上耳机 — 如果音乐会打扰你思路的话，就开一点轻音乐，或者一些大自然环境的声音。这样可以帮助你高度集中，不让自己听到一些能打扰你的声音。这种也是有效的管理好自己的耳门，让自己高度集中在研发中。我一般不会告诉别人，别人看到你带着耳机，高度集中的样子，莫名的会给到 TA 人心理压力和心理负担，会想这一刻过去找你，会不会打扰到你的。\n\n免打扰模式 — 在你高度集中的时候，开启手机的免打扰模式，关闭你电脑里面一些与你现在工作无关的应用和网页。只要不是工作的群都可以开启消息免打扰。在你番茄工作法的休息时间段，再去看一看消息，加加水，走动一下放松一下。（但是记得一定要控制自己的休息时间，休息过长会导致完全脱离工作状态，要重新进入状态耗费的时间就会变长）\n\n\n\n\n\n\n\n\n\n\n\n小结一下：技术研发是一个需要高度集中的脑力活，大脑的 QPS 需要保持在较高的速度和状态才能达到高效。所以要学会自控，更要把控好自己所在的环境与人。时间是宝贵的，只有珍惜时间才会在最短时间内达到最大量度的产出。如果你能做到，你会发现你加班会变少，工作效率会提高。\n\n总结看完这边文章我们发现做为一个开发者，不只是需要提升自己的技术能力，技术素养也是重中之重。只有技术能力，在职场中会有很多压力，职场中是不会给我们全世界的时间来开发，也不会给我们一个舒适的环境让我们集中。所以作为一个更出色的程序员，我们身上必须拥有更多的防身技能，才能在我们面对各式各样的情况和问题出现时，我们能处于泰然，游刃有余。往往也是这些能耐才能让我们与众多的开发者有明显的区别。\n希望这 5 大法则可以助你在技术行业里成为更出色的开发者，在众多的开发者中脱颖而出，升级加薪，走上技术和人生的巅峰。\n\n\n\n\n\n\n\n\n\n最后感谢大家的阅读和支持，你们的点赞和关注都是给予我继续写作最大的动力。 &gt; 让我们一起终身学习，在代码的海洋中找到快乐与自我。\n","slug":"notes/5-principles-to-be-a-better-programmer","date":"2020-03-17T14:34:58.000Z","categories_index":"NOTES","tags_index":"Programmer,Better Programming","author_index":"三钻"},{"id":"3d6151b8bdfcae4be7bfdc3647f80109","title":"带你体验Vue2和Vue3开发组件有什么区别","content":"我们一直都有关注和阅读很多关于 Vue3 的新特性和功能即将到来。但是我们没有一个具体的概念在开发中会有如何的改变和不一样的体验。还有一些童鞋已经开始又慌又抓狂了 – “又要开始学新的写法了 (ノ ToT )ノ ~┻┻”。\n所以这里我使用 Vue2 和 Vue3 开发一个简单的表格组件来展示一下 Vue2 和 Vue3 开发组件的区别。看完这片文章后，你将会有一个概念 Vue2 和 Vue3 开发组件时的区别，并且为 Vue3 的开发之路做好准备。ღ(◔ڼ◔ღ)ミ\n废话少说，让我们开始吧～ (๑ •̀ㅂ•́)و✧\n\n创建一个 template组件来说，大多代码在 Vue2 和 Vue3 都非常相似。Vue3 支持碎片(Fragments)，就是说在组件可以拥有多个根节点。\n这种新特性可以减少很多组件之间的div包裹元素。在开发 vue 的时候，我们会发现每一个组件都会有个div元素包裹着。就会出现很多层多余的div元素。碎片(Fragments)解决了这个问题。对于有完美强迫症的童鞋“真的时太棒了”。我们这里的例子里就不展示了，用简单的单根节点的组件。\nVue2 表格 template\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;form-element&quot;&gt;\n    &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;username&quot; placeholder&#x3D;&quot;Username&quot; &#x2F;&gt;\n\n    &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;password&quot; placeholder&#x3D;&quot;Password&quot; &#x2F;&gt;\n\n    &lt;button @click&#x3D;&quot;login&quot;&gt;Submit&lt;&#x2F;button&gt;\n    &lt;p&gt;Values: &#123;&#123; username + &#39; &#39; + password &#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n在 Vue3 的唯一真正的不同在于数据获取。Vue3 中的反应数据（Reactive Data）是包含在一个反应状态（Reactive State）变量中。— 所以我们需要访问这个反应状态来获取数据值。\n&lt;template&gt;\n  &lt;div class&#x3D;&quot;form-element&quot;&gt;\n    &lt;h2&gt;&#123;&#123; state.title &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;state.username&quot; placeholder&#x3D;&quot;Username&quot; &#x2F;&gt;\n\n    &lt;input type&#x3D;&quot;password&quot; v-model&#x3D;&quot;state.password&quot; placeholder&#x3D;&quot;Password&quot; &#x2F;&gt;\n\n    &lt;button @click&#x3D;&quot;login&quot;&gt;Submit&lt;&#x2F;button&gt;\n    &lt;p&gt;Values: &#123;&#123; state.username + &#39; &#39; + state.password &#125;&#125;&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n\n建立数据 data这里就是 Vue2 与 Vue3 最大的区别 — Vue2 使用选项类型API（Options API）对比 Vue3合成型API（Composition API）\n旧的选项型 API 在代码里分割了不同的属性（properties）：data，computed 属性，methods，等等。新的合成型 API 能让我们用方法（function）来分割，相比于旧的 API 使用属性来分组，这样代码会更加简便和整洁。\n\n\n\n\n\n\n\n\n\n现在我们来对比一下 Vue2 写法和 Vue3 写法在代码里面的区别。\nVue2 - 这里把两个数据放入 data 属性中\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  data() &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;\n  &#125;,\n&#125;\n\n在Vue3.0，我们就需要使用一个新的setup()方法，此方法在组件初始化构造的时候触发。\n为了可以让开发者对反应型数据有更多的控制，我们可以直接使用到 Vue3 的反应API（reactivity API）。\n使用以下三步来建立反应性数据:\n\n从 vue 引入reactive\n使用reactive()方法来声名我们的数据为反应性数据\n使用setup()方法来返回我们的反应性数据，从而我们的 template 可以获取这些反应性数据\n\n上一波代码，让大家更容易理解是怎么实现的。\nimport &#123; reactive &#125; from &#39;vue&#39;\n\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;)\n\n    return &#123; state &#125;\n  &#125;,\n&#125;\n\n这里构造的反应性数据就可以被template使用，可以通过state.username和state.password获得数据的值。\n\nVue2 对比 Vue3 的 methods 编写Vue2 的选项型 API 是把 methods 分割到独立的属性区域的。我们可以直接在这个属性里面添加方法来处理各种前端逻辑。\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  data() &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;\n  &#125;,\n  methods: &#123;\n    login() &#123;\n      &#x2F;&#x2F; 登陆方法\n    &#125;,\n  &#125;,\n&#125;\n\nVue3 的合成型 API 里面的setup()方法也是可以用来操控 methods 的。创建声名方法其实和声名数据状态是一样的。— 我们需要先声名一个方法然后在setup()方法中返回(return)， 这样我们的组件内就可以调用这个方法了。\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  setup() &#123;\n    const state &#x3D; reactive(&#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;)\n\n    const login &#x3D; () &#x3D;&gt; &#123;\n      &#x2F;&#x2F; 登陆方法\n    &#125;\n    return &#123;\n      login,\n      state,\n    &#125;\n  &#125;,\n&#125;\n\n\n生命周期钩子 — Lifecyle Hooks在 Vue2，我们可以直接在组件属性中调用 Vue 的生命周期的钩子。以下使用一个组件已挂载（mounted）生命周期触发钩子。\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  data() &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n    &#125;\n  &#125;,\n  mounted() &#123;\n    console.log(&#39;组件已挂载&#39;)\n  &#125;,\n  methods: &#123;\n    login() &#123;\n      &#x2F;&#x2F; login method\n    &#125;,\n  &#125;,\n&#125;\n\n现在 Vue3 的合成型 API 里面的setup()方法可以包含了基本所有东西。生命周期的钩子就是其中之一！\n但是在 Vue3 生周期钩子不是全局可调用的了，需要另外从 vue 中引入。和刚刚引入reactive一样，生命周期的挂载钩子叫onMounted。\n引入后我们就可以在setup()方法里面使用onMounted挂载的钩子了。\nimport &#123; reactive, onMounted &#125; from &#39;vue&#39;\n\nexport default &#123;\n  props: &#123;\n    title: String,\n  &#125;,\n  setup() &#123;\n    &#x2F;&#x2F; ..\n\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;组件已挂载&#39;)\n    &#125;)\n\n    &#x2F;&#x2F; ...\n  &#125;,\n&#125;\n\n\n计算属性 - Computed Properties我们一起试试添加一个计算属性来转换username成小写字母。\n在 Vue2 中实现，我们只需要在组件内的选项属性中添加即可\nexport default &#123;\n  &#x2F;&#x2F; ..\n  computed: &#123;\n    lowerCaseUsername() &#123;\n      return this.username.toLowerCase()\n    &#125;,\n  &#125;,\n&#125;\n\nVue3 的设计模式给予开发者们按需引入需要使用的依赖包。这样一来就不需要多余的引用导致性能或者打包后太大的问题。Vue2 就是有这个一直存在的问题。\n所以在 Vue3 使用计算属性，我们先需要在组件内引入computed。\n使用方式就和反应性数据（reactive data）一样，在state中加入一个计算属性:\nimport &#123; reactive, onMounted, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  props: &#123;\n    title: String\n  &#125;,\n  setup () &#123;\n    const state &#x3D; reactive(&#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n      lowerCaseUsername: computed(() &#x3D;&gt; state.username.toLowerCase())\n    &#125;)\n\n    &#x2F;&#x2F; ...\n  &#125;\n\n\n接收 Props接收组件props参数传递这一块为我们带来了 Vue2 和 Vue3 之间最大的区别。—this在 vue3 中与 vue2 代表着完全不一样的东西。\n在 Vue2，this代表的是当前组件，不是某一个特定的属性。所以我们可以直接使用this访问 prop 属性值。就比如下面的例子在挂载完成后打印处当前传入组件的参数title。\nmounted () &#123;\n    console.log(&#39;title: &#39; + this.title)\n&#125;\n\n但是在 Vue3 中，this无法直接拿到 props 属性，emit events（触发事件）和组件内的其他属性。不过全新的setup()方法可以接收两个参数：\n\nprops - 不可变的组件参数\ncontext - Vue3 暴露出来的属性（emit，slots，attrs）\n\n所以在 Vue3 接收与使用 props 就会变成这样：\nsetup (props) &#123;\n    &#x2F;&#x2F; ...\n\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;title: &#39; + props.title)\n    &#125;)\n\n    &#x2F;&#x2F; ...\n&#125;\n\n\n事件 - Emitting Events在 Vue2 中自定义事件是非常直接的，但是在 Vue3 的话，我们会有更多的控制的自由度。\n举例，现在我们想在点击提交按钮时触发一个login的事件。\n在 Vue2 中我们会调用到this.$emit然后传入事件名和参数对象。\nlogin () &#123;\n      this.$emit(&#39;login&#39;, &#123;\n        username: this.username,\n        password: this.password\n      &#125;)\n &#125;\n\n但是在 Vue3中，我们刚刚说过this已经不是和 vue2 代表着这个组件了，所以我们需要不一样的自定义事件的方式。\n那怎么办呀？! ლಠ 益 ಠ)ლ\n不用慌，在setup()中的第二个参数content对象中就有emit，这个是和this.$emit是一样的。那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在 setup 方法中随意使用了。\n然后我们在login方法中编写登陆事件：\nsetup (props, &#123; emit &#125;) &#123;\n    &#x2F;&#x2F; ...\n\n    const login &#x3D; () &#x3D;&gt; &#123;\n      emit(&#39;login&#39;, &#123;\n        username: state.username,\n        password: state.password\n      &#125;)\n    &#125;\n\n    &#x2F;&#x2F; ...\n&#125;\n\n\n最终的 vue2 对比 vue3 代码\n真的是太棒了，能看到这里的童鞋们，你们现在基本都看到 vue2 与 vue3 其实概念与理念都是一样的。只是有一些属性获取方式和声名和定义方式稍微变了。一直在鬼哭狼嚎的小小前端开发猿人们，你们可以松一口气了吧。\n总结一下，我觉得 Vue3 给我们前端开发者带来了全新的开发体验，更好的使用弹性，可控度也得到了大大的提升。如果你是一个学过或者接触过 React 然后现在想使用 Vue 的话，应该特别兴奋，因为很多使用方式都和 React 非常相近了 🎉！\n全新的合成式API（Composition API）可以提升代码的解耦程度 —— 特别是大型的前端应用，效果会更加明显。还有就是按需引用的有了更细微的可控性，让项目的性能和打包大小有更好的控制。\n最后我把完成的 Vue2 和 Vue3 的组件代码发出来给大家：\nVue2\n&lt;template&gt;\n  &lt;div class&#x3D;&#39;form-element&#39;&gt;\n    &lt;h2&gt; &#123;&#123; title &#125;&#125; &lt;&#x2F;h2&gt;\n    &lt;input type&#x3D;&#39;text&#39; v-model&#x3D;&#39;username&#39; placeholder&#x3D;&#39;Username&#39; &#x2F;&gt;\n\n    &lt;input type&#x3D;&#39;password&#39; v-model&#x3D;&#39;password&#39; placeholder&#x3D;&#39;Password&#39; &#x2F;&gt;\n\n    &lt;button @click&#x3D;&#39;login&#39;&gt;\n      Submit\n    &lt;&#x2F;button&gt;\n    &lt;p&gt;\n      Values: &#123;&#123; username + &#39; &#39; + password &#125;&#125;\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default &#123;\n  props: &#123;\n    title: String\n  &#125;,\n  data () &#123;\n    return &#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;\n    &#125;\n  &#125;,\n  mounted () &#123;\n    console.log(&#39;title: &#39; + this.title)\n  &#125;,\n  computed: &#123;\n    lowerCaseUsername () &#123;\n      return this.username.toLowerCase()\n    &#125;\n  &#125;,\n  methods: &#123;\n    login () &#123;\n      this.$emit(&#39;login&#39;, &#123;\n        username: this.username,\n        password: this.password\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\nVue3\n&lt;template&gt;\n  &lt;div class&#x3D;&#39;form-element&#39;&gt;\n    &lt;h2&gt; &#123;&#123; state.title &#125;&#125; &lt;&#x2F;h2&gt;\n    &lt;input type&#x3D;&#39;text&#39; v-model&#x3D;&#39;state.username&#39; placeholder&#x3D;&#39;Username&#39; &#x2F;&gt;\n\n    &lt;input type&#x3D;&#39;password&#39; v-model&#x3D;&#39;state.password&#39; placeholder&#x3D;&#39;Password&#39; &#x2F;&gt;\n\n    &lt;button @click&#x3D;&#39;login&#39;&gt;\n      Submit\n    &lt;&#x2F;button&gt;\n    &lt;p&gt;\n      Values: &#123;&#123; state.username + &#39; &#39; + state.password &#125;&#125;\n    &lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nimport &#123; reactive, onMounted, computed &#125; from &#39;vue&#39;\n\nexport default &#123;\n  props: &#123;\n    title: String\n  &#125;,\n  setup (props, &#123; emit &#125;) &#123;\n    const state &#x3D; reactive(&#123;\n      username: &#39;&#39;,\n      password: &#39;&#39;,\n      lowerCaseUsername: computed(() &#x3D;&gt; state.username.toLowerCase())\n    &#125;)\n\n    onMounted(() &#x3D;&gt; &#123;\n      console.log(&#39;title: &#39; + props.title)\n    &#125;)\n\n    const login &#x3D; () &#x3D;&gt; &#123;\n      emit(&#39;login&#39;, &#123;\n        username: state.username,\n        password: state.password\n      &#125;)\n    &#125;\n\n    return &#123;\n      login,\n      state\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n希望这篇文章能让大家体验到一个比较全面的 Vue2 与 Vue3 的开发区别。如果大家还有什么问题，可以在评论中提问哦！\n开发愉快！～\n\n","slug":"frontend/difference-between-vue-and-vue3","date":"2020-03-08T21:59:18.000Z","categories_index":"FrontEnd,Vue","tags_index":"Vue,Vue3","author_index":"三钻"},{"id":"413bd1d64b9fce9f3204cf3770091122","title":"JavaScript中更简便的数组处理函数.map()，.reduce()，.filter()","content":"如果你刚接触 JavaScript 可能你还没有听说过.map()，.reduce()，.filter()。或者听说过，看过别人用过但是自己在实际项目中没有用过。在国内很多开发项目都是需要考虑 IE8 的兼容，为了兼容很多 JavaScript 好用的方法和技巧都被埋没了。但是我发现近几年开始，很多开发项目已经完全抛弃了 IE 这个魔鬼了。如果你不需要兼容古老的 IE 浏览器了，那就要开始熟悉一下这几个方法来处理数组。\n\n\n\n\n\n\n\n\n\n注意这遍文章说的的 3 个方法其实在很多其他语言都可以使用到，因为这几个方法和使用概念在很多其他语言都是存在的。\n\n.map()让我用一个简单的例子告诉你如何使用这个方法。假如你现在有多对象的数组数据 - 每一个对象代表着一个员工的信息。现在你想要的最终结果就是取出所有员工的唯一 ID 值。\n&#x2F;&#x2F; 员工数据\nvar employees &#x3D; [\n  &#123; id: 20, name: &#39;Captain Piett&#39; &#125;,\n  &#123; id: 24, name: &#39;General Veers&#39; &#125;,\n  &#123; id: 56, name: &#39;Admiral Ozzel&#39; &#125;,\n  &#123; id: 88, name: &#39;Commander Jerjerrod&#39; &#125;,\n]\n&#x2F;&#x2F; 你想要的结果\n;[20, 24, 56, 88]\n\n其实要实现这个结果有很多数组处理方式。传统的处理方法就是先定义一个空数组，然后使用.forEach()，.for(...of)，或者是最简单的.for()来组装 ID 到你定义的数组里面。\n我们来对比一下传统的处理方式和.map()的区别。\n使用.forEach()：\nvar employeeIds &#x3D; []\nemployees.forEach(function (employee) &#123;\n  employeeIds.push(officer.id)\n&#125;)\n\n注意使用传统的方式，我们必须有一个预定义的空数组变量才行。但是如果是.map()就会更简单了。\nvar employeeIds &#x3D; employees.map(function (employee) &#123;\n  return employee.id\n&#125;)\n\n甚至我们可以用更简洁的方式，使用箭头方法（但是需要 ES6 支持，Babel，或者 TypeScript）。\nconst employeeIds &#x3D; employees.map((employee) &#x3D;&gt; employee.id)\n\n所以.map()到底是怎么运作的呢？这个方法有两个参数，第一是回调方法，第二是可选内容（会在回调方法中做为this）。数组里的每个数值/对象会被循环进入到回调方法里面，然后返回新的数值/对象到结果数组里面。\n注意的是结果数组的长度永远都会和被循环的数组的长度一致。\n\n.reduce()与.map()相识，.reduce()也是循环一个回调方法，数组里面的每一个元素对回进入回调方法。区别是回调方法返回的值会被传递到下一个回调方法，如此类推（等同于一个累加器）。\n.reduce()里的累加值可以是任何属性的值，包括integer，string，object等等。这个累加值会被实力化或者传递到下一个回调方法。\n来上代码，做个简单的例子！假如你有一个飞机师的数组，数组里面有每个飞机师的工龄。\nvar pilots &#x3D; [\n  &#123;\n    id: 10,\n    name: &#39;Poe Dameron&#39;,\n    years: 14,\n  &#125;,\n  &#123;\n    id: 2,\n    name: &quot;Temmin &#39;Snap&#39; Wexley&quot;,\n    years: 30,\n  &#125;,\n  &#123;\n    id: 41,\n    name: &#39;Tallissan Lintra&#39;,\n    years: 16,\n  &#125;,\n  &#123;\n    id: 99,\n    name: &#39;Ello Asty&#39;,\n    years: 22,\n  &#125;,\n]\n\n现在我们需要知道所有飞机师累计的总工龄。使用.reduce()就是比吃饭还简单的事情。\nvar totalYears &#x3D; pilots.reduce(function (accumulator, pilot) &#123;\n  return accumulator + pilot.years\n&#125;, 0)\n\n注意我这里第二个参数我传了 0。第二个参数是一个累加值的初始值。当然如果场景需要这个初始值也可以传入一个变量或者你需要的值。循环了数组里的每一个元素后，reduce 方法会返回最终累加后的值（在我们这个例子中就是82）。\n\n\n\n\n\n\n\n\n\n例子里面的acc和accumulator就是累加值变量\n如果是使用 ES6 箭头写法，我们可以写的更加优雅简洁。一行就可以搞掂的事情！\nconst totalYears &#x3D; pilots.reduce((acc, pilot) &#x3D;&gt; acc + pilot.years, 0)\n\n现在如果我们需要找到哪一位是最有经验的飞机师。这种情况我们一样可以使用.reduce()。\nvar mostExpPilot &#x3D; pilots.reduce(function (oldest, pilot) &#123;\n  return (oldest.years || 0) &gt; pilot.years ? oldest : pilot\n&#125;, &#123;&#125;)\n\n这里我把accumulator变量改为oldest代表飞机师里面的老司机。这时候 reduce 里面的回调方法对比每一个飞机师，每一次飞机师的值进入这个回调方法，工龄更高的就会覆盖oldest变量。最终循环后得到的oldest就是工龄最高的飞机师。\n通过这几个例子，你可以看到使用.reduce()可以简单又优雅的在一个数组里面获取到单个最终值或者对象。\n\n.filter()如果你现在的场景是需要在一个数组里面过滤一部分的数据，这个时候.filter()就是你的最好的朋友了。\n我们用回飞机师的数据，并且加入了所属航空公司的值：\nvar pilots &#x3D; [\n  &#123;\n    id: 2,\n    name: &#39;Wedge Antilles&#39;,\n    faction: &#39;Rebels&#39;,\n  &#125;,\n  &#123;\n    id: 8,\n    name: &#39;Ciena Ree&#39;,\n    faction: &#39;Empire&#39;,\n  &#125;,\n  &#123;\n    id: 40,\n    name: &#39;Iden Versio&#39;,\n    faction: &#39;Empire&#39;,\n  &#125;,\n  &#123;\n    id: 66,\n    name: &#39;Thane Kyrell&#39;,\n    faction: &#39;Rebels&#39;,\n  &#125;,\n]\n\n加入现在我们想分别筛选出Rebels和Empire两个航空公司的飞机师，使用.filter()就是轻而易举的事情！\nvar rebels &#x3D; pilots.filter(function (pilot) &#123;\n  return pilot.faction &#x3D;&#x3D;&#x3D; &#39;Rebels&#39;\n&#125;)\nvar empire &#x3D; pilots.filter(function (pilot) &#123;\n  return pilot.faction &#x3D;&#x3D;&#x3D; &#39;Empire&#39;\n&#125;)\n\n就这么简单，如果使用箭头方法（ES6）就更加优雅了：\nconst rebels &#x3D; pilots.filter((pilot) &#x3D;&gt; pilot.faction &#x3D;&#x3D;&#x3D; &#39;Rebels&#39;)\nconst empire &#x3D; pilots.filter((pilot) &#x3D;&gt; pilot.faction &#x3D;&#x3D;&#x3D; &#39;Empire&#39;)\n\n其实原理很简单，只要你的回调方法返回的是true，这个值或者对象就会在新的数组里面了。如果返回的是false就会被过滤掉了。\n\n结合使用 .map()，.reduce()，.filter()既然我们刚刚学到的三个函数都是可以用于数组的，并且.map()和.filter()都是返回数组的。那我们就可以串联起来使用。不说多了上代码试试！\n我们用一个有趣一点的数据试验一下，假如现在我们有一个星球大战里面的人物的数组。每个字段的定义如下：\n\n\n\n\n\n\n\n\n\n\nId: 人物唯一 ID\nname: 人物名字\npilotingScore: 飞行能力指数\nshootingScore: 射击能力指数\nisForceUser: 是否拥有隔空操控能力\n\n我们的目标：获取拥有隔空操控能力的飞行员的总飞行能力指数。我们先分开一步一步实现这个目标！\n\n首先我们需要先获取到拥有隔空操控能力的飞行员。\n\nvar jediPersonnel &#x3D; personnel.filter(function (person) &#123;\n  return person.isForceUser\n&#125;)\n&#x2F;&#x2F; 结果集: [&#123;...&#125;, &#123;...&#125;, &#123;...&#125;] (Luke, Ezra and Caleb)\n\n\n这段代码我们获得了 3 个飞行员对象，分别都是拥有隔空操控能力的飞行员。使用这个对象我们来获取每个飞行员的飞行能力指数值。\n\nvar jediScores &#x3D; jediPersonnel.map(function (jedi) &#123;\n  return jedi.pilotingScore + jedi.shootingScore\n&#125;)\n&#x2F;&#x2F; 结果: [154, 110, 156]\n\n\n获取到每个飞行员的飞行能力指数值后，我们就可以用累加器（.reduce()）获取总飞行能力指数了。\n\nvar totalJediScore &#x3D; jediScores.reduce(function (acc, score) &#123;\n  return acc + score\n&#125;, 0)\n&#x2F;&#x2F; 结果: 420\n\n这里分开实现方式可以达到我们的目标，但是其实我们可以串联起来，可以写的更加简洁又优雅！我们来玩玩更好玩的吧！\nvar totalJediScore &#x3D; personnel\n  .filter(function (person) &#123;\n    return person.isForceUser\n  &#125;)\n  .map(function (jedi) &#123;\n    return jedi.pilotingScore + jedi.shootingScore\n  &#125;)\n  .reduce(function (acc, score) &#123;\n    return acc + score\n  &#125;, 0)\n\n这样写是不是很优雅！都被这段代码给美到了！❤️\n如果我们使用箭头写法 ES6，就更加优雅了！\nconst totalJediScore &#x3D; personnel\n  .filter((person) &#x3D;&gt; person.isForceUser)\n  .map((jedi) &#x3D;&gt; jedi.pilotingScore + jedi.shootingScore)\n  .reduce((acc, score) &#x3D;&gt; acc + score, 0)\n\n哇！代码原来可以写的那么优雅的么？！想不到吧？\n\n\n\n\n\n\n\n\n\n其实我们只需要使用.reduce()就可以得到我们的目标结果了，以上例子做为教学例子，所以使用了 3 个我们学到的函数。\n我们来看看只用.reduce()怎么实现的，来我们一起来刷新一下三观吧！\nconst totalJediScore &#x3D; personnel.reduce(\n  (acc, person) &#x3D;&gt;\n    person.isForceUser\n      ? acc + person.pilotingScore + person.shootingScore\n      : acc,\n  0\n)\n\n不敢想象吧？一行就搞定一个功能不是梦！\n为什么抛弃 .forEach()?其实我一开始写前端的时候也是一顿撸，来个数组都是撸个 for 循环，解决一切数组处理问题。但是近几年我开始步入前后端开发，API 接口对接。发现数据处理越来越多，如果还是像以前那样什么都用 for 循环来处理数据，那其实数据处理的代码就会越来越臃肿越来越复杂凌乱。所以我开始抛弃了.forEach()。开始做一个优雅的程序员！\n为什么使用.map()，.filter()，.reduce()写代码更优雅，更美观呢？我们用一个实战例子来对比一下吧。\n假设现在我们对接一个接口，返回的数组里面有两个字段name：人的名称和title：对应的职位。\nvar data &#x3D; [\n  &#123;\n    name: &#39;Jan Dodonna&#39;,\n    title: &#39;General&#39;,\n  &#125;,\n  &#123;\n    name: &#39;Gial Ackbar&#39;,\n    title: &#39;Admiral&#39;,\n  &#125;,\n]\n\n产品经理给到你的需求是只需要展示这些人的职位称呼。\n\n\n\n\n\n\n\n\n\n当然这个时候有一些前端就会说“我只是个小小的前端，后端给我处理吧”。但是，这个接口其实是一个通用的接口，就是获取这些员工的资料的，是在多个地方使用的。如果每一个页面因为需要展示的不一样而要写多一个接口给你，你觉得这样好吗？做为一个优秀的前端工程师 🦁️，这种小 case 你自己就可以很优雅的处理好了。而且，在一个优秀的团队，后端确实是要考虑接口通用性的，这种为了你的方便而给他们带来更臃肿的接口是不可接受的。所以前端这个时候就是要重组数据了。\n假设现在产品给你的需求是员工列表展示，要支持只展示员工职称和员工左右信息的两种显示项。这个时候我们就要编写一个数据组装方法来跟进展示要求来改变数据格式。\n因为这个“神马“的需求，我们使用.forEach()来重组数据就相对比较麻烦了，而且代码也会变得臃肿。\n我们忽略了组装数据的方法，直接就当作我们已经写好了一个组装数据的方法为formatElement。如果我们用forEach首先我们就需要定义一个空数组来接收结果。\nvar results &#x3D; []\ndata.forEach(function (element) &#123;\n  var formatted &#x3D; formatElement(element)\n  results.push(formatted)\n&#125;)\n\n所以我们需要两个方法才能实现这个数据结果，但是为什么要写的那么臃肿呢？因为forEach并没有返回值，单单就给你跑个循环，还需要自己push值到预定义的变量里面。其实一个方法就可以完成了，而且重点是一行代码就完事了。\n来使用我们新学的技巧，用.map()来实现就非常简单优雅了。\nvar results &#x3D; data.map(formatElement)\n\n总结你学会了吗？学会了就去尝试用.map()，.reduce()，.filter()来替换你传统的for循环吧！我保证你的代码会越来越简洁，可读性更高。\n如果你喜欢我的这遍文章，记得继续关注我的博客，下一遍文章我们开学习怎么在 JavaScript 中使用.some()和.find()。\n坚持做一个优雅的程序员，坚持每天敲代码！\n","slug":"frontend/simplify-your-javascript-with","date":"2019-11-02T09:18:18.000Z","categories_index":"FrontEnd,Tips","tags_index":"JavaScript,ES6","author_index":"三钻"},{"id":"84a74e4a5473540e455e5775f4e38ad4","title":"如何高效学习编程","content":"编程确实不是一件容易的事情，除了要有较强的逻辑思维，还需要花大量的时间和集中力来提升和维持一定的高度。\n与其他的领域不一样的是，技术每日都在变，所以对于编程初学者是很难一直与时并进的。就算是技术大神和老司机们也是追赶的比较吃力的。在技术领域打滚的这些年里，通过经历和经验总结出一些高效的学习方式和方法，在这篇文章里与大家分享。让我们现在就在技术领域的学习之路上奔跑吧！\n锁定目标，风雨兼程在刚刚接触技术的时候，很多人都会比较迷茫。技术领域有前端后端并且各自有多种编程语言。选定前端后端后又发现越过一山还有一山高，面临更多的选择。甚至在技术领域打滚了多年后的技术人员也会迷茫，会开始质疑自己的前景，是否要换一门语言或者多学几门语言。所以锁定目标是高效学习的第一门课。\n选择目标如果你的目标是前端开发，前期的学习道路是比较明确的，HTML5+CSS3 起步。但是如果你的目标是后端开发，还没有开始就已经有多扇门在你前面，让你瞬间选择困难了。所以这里我们就用后端语言选择作为一个例子讲解学习目标选择方法。\n\n\n\n\n\n\n\n\n\n陷入学习目标选择困难症是因为技术每日每夜都在变，方向和未来都在摇摆。但是我们首先要有一个对技术有很好的判定能力。\n大家应该很多时候都听过”JAVA 才是世界上做好的语言”，”PHP 才是世界上最好的语言”等等，这些在自己领域崇拜着自己所爱的语言技术爱好者。TA 们并没有错，因为每个开发语言都在特定领域或者项目条件里是最好的语言。不过并没有世界上最好的语言，只有在某一个场景和条件下最适合使用的语言。每一种开发语言都有他擅长最合适的使用场景。\n\nPHP - 更适合小型到中型网页端应用（大型应用就需要其他语言配合使用）\nJAVA - 更适合大型应用，企业级应用（中小型应用用 JAVA 就是大材小用，浪费资源）\nPYTHON - 更适合用于爬虫，人工智能，脚本类应用\n\n\n\n\n\n\n\n\n\n\n\n📖 目标寻找法：\n所以在选择学习目标的时候，我们要有对技术的判定能力，不要轻易听取一些偏面的评价和定论而下决定。\n\n选择学习目标时重要的决定因素:\n在目前最实用的 - 学能用到的更容易上手，也更有价值\n难度跨度不要太高 - 难度跨越太大时间成本会越高\n感兴趣的 - 感兴趣才更能坚持，更有动力\n社区更大的 - 社区越大遇到问题时找答案的途径越多\n开源项目优先 - 开源的项目的技术更有未来\n\n\n\n🎯 一旦锁定一个目标就要能懂，能用，能变，再扩张你的学习领域到其他的技术。\n\n能懂 - 能懂的技术或者知识的理论和原理；\n能用 - 能把技术或者知识投入使用，投入实战项目；\n能变 - 能举一反三学到的技术或者知识，能变通，延伸拓展。\n\n\n不要蜻蜓点水这一点是很多初学者都会犯的错误。\n\n\n\n\n\n\n\n\n\n不要浅入浅出，得不偿失，得不到技能还失去了时间。\n学习要一步一个脚印，很多一开始学习编程往往会同时学习多个技术，其实这种学习方式不但没有效果反而还浪费时间浪费生命。锁定一个学习目标就要专注一个点上学习，重点学习。\n举个例子，如果你想成为一个 Java 开发工程师，你是不需要从 C 学起，然后 C++，最后才开始学习 Java。我看到很多开发者刚开始都是这样学习，其实根本不需要从底层技术开始学习。既然你的学习目标是 Java，那就直奔重点不浪费时间。稳固了基础开发语言后，选择一个框架开始深入专业实战知识。当你稳固了更专业的实战知识后，就可以开始学习这个技术的周边工具（比如 IDE）让开发更加高效便捷。\n\n\n\n\n\n\n\n\n\n📖 专研秘诀：\n\n学习每一个知识或者技术，一定要深入浅出，深入学习和挖掘，吸取重要知识和技术。\n专心，专注，专研是一个技术人才的基本素养！\n\n\n先专注于会用而不是能用很多开发者习惯性会过于专注于工具使用，写法，性能，可扩展性等等。初学者一般都会掉入工具使用和写法的坑，而资深的开发者会过于专注于性能和可扩展性。这时候往往会过度消耗学习时间，甚至忘记最初的学习目标。\n用一个简单易懂的例子，”一个机械工程师不会浪费时间想怎么更好的使用 TA 的扳手，而是怎么可以组装好一个机器的部件” - 很多人会想，学会用更好的工具不是可以更快地安装好吗？但是现实是，你都还没有弄懂怎么安装，再好再有效的工具对你来说都是无用武之地。所以还没有学会前行，就不要先想着怎么跑。\n再举例，如果你是正在学习使用 Vue 框架，不要太过于执着怎么使用 Vue 的周边工具，高级写法，性能隐患问题等等。你的目标应该是创建你的第一个首页然后直接投入开发一个小项目小应用。这样你的产出才是最高的，因为这样做更加专注于学会怎么使用 Vue 来实现功能，而不是更好的使用 Vue 框架。\n\n\n\n\n\n\n\n\n\n在学习的时候要专注于会使用新的技术，而不是怎么用各种花式技巧来提高使用能力。\n还有很多童鞋开始学一门技术时，会先开始看一大堆的知识和书籍，或者去看一些大型的项目用这个技术是怎么实现的。其实更有效的学习方式是小步快跑，学习的过程中开发一个小项目会让你更加有动力也更有趣。\n约定自己在限定时间内完成小目标，如能完成就给自己一点小奖励。例如，你对你自己说“如果我下周五完成这个功能，我就让自己去看个电影”。记住奖励不需要很大，小步快跑，小奖小利，这样才能维持发自内心的动力和驱动力。不过就算没有达成小目标也不用气馁，失败时成功之母，所有成功的人都是通过在失败中总结成长壮大。\n\n采用学习策略每一个人都会有一种最合适自己的学习方式方法，适合我的不一定对你就有效 - 所以找到一种对你有效的学习方法很重要。\n经历学习方式方法是通过你日复一日，年复一年不停地尝试和总结得来的一种技巧。我也尝试过很多种方式来学习技术，自从我开始进入技术行业到现在，我换了无数种学习方式才找到最适合自己的一种技巧。\n在一开始刚刚入门的时候，我尝试看很多“从入门到精通”，“XXX 语言 101”等等，最终的结果都是“从入门到放弃”。后面开始走视频学习之路，发现视频里面的老师说话好像是机器人一样，本来有点失眠症的，没想到一看视频秒睡着，被治好了！我以为我的技术生涯就要结束在这里了～ ¯\\_(⊙︿⊙)_/¯\n建立策略前方无绝路 · 希望在转角 ～ 我迅速改变了策略，学习技术和其他领域不一样除了看书，撸视频还需要动手去敲代码。学习任何一门技术，可以遵循以下学习策略，可以让学习的技术和知识更加稳固。\n\n\n\n\n\n\n\n\n\n📖 学习策略：\n还是遵循我们之前说到的规则，能懂，能用，能变。\n\n深入了解技术的原理 - 了解清楚才能更好的在不同场景下运用自如（可以通过看书，看文档）\n通过代码理解运用方式 - 看懂基本原理，就可以看看别人是怎么在项目中使用的（在 github 找开源项目，看教学视屏等等）\n实战，做一个小项目 - 能懂，能会了就要能用，用新学的技术实现一个功能，做一个小项目，把知识投入实战。\n发挥你的想象力 - 能用后如果想进阶更高层次，就要发挥你的想象力，能举一反三，在你的小项目里面加功能。\n\n其实上面的策略无非就是学习的过程中必须有的理论，运用和变通。这三个学习维度要保持一个良好的平衡。这个平衡是非常重要的，只有理论那就是“纸上谈兵”，只有理论和运用那只是个“代码搬运工”，如果三个维度你都才是就是“大师”。\n当然所说的平衡不是说 1:1:1，完全平衡是很难的。对于一个初学者的话可以先 3:2:1，中级就可以开始维持 2:3:1，到了高级就可以维持 2:2:2 了。\n\n时间管理，提高效率番茄工作法估计很多人都听说过，但是真正用上可能就很少了，能坚持使用的就更少了。\n很多时候在学习中，或者工作中，我们都是被时间追着跑，这里看一下哪里看一下，不经意就已经过了几个小时，一天就过去了。其实真正有效的产出不大，那是因为你没有合理的管理时间。用番茄工作法就是可以让我们可以追着时间跑，让自己时刻有着时间感，急迫感。自然时间运用上就更加有效了。我现在工作中和学习中都已经在使用番茄工作法，有效管理时间效率。突然发现使用了之后，每个小时我的工作效率提高了很多。\n\n\n\n\n\n\n\n\n\n使用方式其实很简单，把学习或者工作时间拆分为25分钟一个小阶段，每25分钟休息5分钟，每4次小阶段休息15到20分钟。\n使用这个时间管理法后，你会觉得在 25 分钟的小阶段里面，你的时间很紧迫的，每一分钟你都觉得很宝贵。你会发现你没有时间去浪费，自然而然的在 25 分钟内提高了效率。无形中你的学习和工作的集中力就会提升。除了提高了你的效率以外，你会发现一天几个小时的学习或者工作都不觉得很疲惫。因为在 25 分钟的高度集中后，你合理的调整了休息，让自己非常平衡的控制好疲惫度。所以你会发现一天里面的学习和工作都变得轻松了。\n\n\n\n\n\n\n\n\n\n使用番茄工作法提高了学习效率和疲惫度，自然你的学习成果就会更高。如果你觉得我说的这个方法太虚幻了，不妨试一下体验一下，实战说明一切！\n\n多思考，多教学通常我们学习都用的是吸 🌟 大法 🌟ԅ( ͒ ۝ ͒ )，然后实战运用，其实还有很多细节和理论我们并没有理解透测。所以运用就不够自由，无法延伸一些创新的用法，或者举一反三。\n在我事业发展的过程中，从一个小开发，做到一个小组长，到现在技术总监。在我开始带领一个小组，到带领整个技术团队；很多问题和新知识都要通过讲解或者教学来带培养你的组员和队员。这个过程中会遇到各种不同思维程度和学习能力的人，每一个人的理解能力或者理解方式都不一样，甚至看待每一件事情或者知识的角度都不一。你会发现你教学或者讲解某一个知识的时候需要使用各种不同的方式和方法。往往就是这样触发了你自己去换角度思考和理解这个知识，而启发了你自己对这个知识新的认知。\n\n\n\n\n\n\n\n\n\n通过教学和讲解来把你的知识传承给另外一个人，需要重新整理思路，逻辑，切换 N 中方式和说法。这个过程中你会挖掘出新的知识，新的观点，新的思维方式，新的理解角度和深度。这就是自我思维切换而达到的知识深度挖掘和提升的过程。这种就是我们经常说的小黄鸭教学法。\n不知道大家有没有听说过，当你思路不清晰，或者有问题无法解决的时候。你可以找一只小黄鸭，你就开始讲解你的思路，逻辑或者问题。这个过程中你开始重新整理自己的思路。如果你把一只啥都不懂的小黄鸭也能让它听懂。那这个时候你的思路，逻辑，理解都更加清晰了，问题起码都解决了 50%以上了。我给这个方法取了个名字叫小黄鸭教学法！初级学习的时候要用吸星大法，进阶到高级的时候就要用小黄鸭教学法。能教会一只小黄鸭技术，你就是大神了！\n\n记录，总结除非你是过目不忘，要不看完一本书能记下所有是不可能的。就算记住了但是不可能完全明白透彻。一个程序员经常面对着反复又反复的任务，记录学习进度和总结学习知识很重要。往往你学到一个知识的时候，你会使用这个知识投入实战中。你沉迷在代码海洋之中无法自拔之后，你会发现你已经不记得你入海前学到哪里了。所以记录学习进度很重要。\n\n\n\n\n\n\n\n\n\n记录学习方式：\n\n把学习后的只是写成文档\n把知识写成博客\n总结重点，记录重点\n编写学习规划，就是所谓的todo规划表\n\n在学习中，如果要把知识记录，当你要使用它的时候能快速找到。那你就要有总结知识的习惯。把你学过的知识，技术，技巧都写成文档，写成总结。这样加强你的印象，同时也整理出了属于你自己的开发手册。当你遇到了某些问题的时候就可以通过你自己的开发手册找到答案。\n\n改掉以下习惯\n完美主义： 初学者经常会陷入的一个坑，从一开始就追求完美，完美的写法，完美的实现方式，完美的设计模式。其实有时候这些都不是最重要的，反而导致有延迟和延后的严重情况，导致进度一直无法推进。最求完美往往把简单事情变得复杂。不要总是为了完美而无限徘徊，为了最好的解决办法而纠结，为了对的方式而浪费时间。往往在开发中，时间是有限的，需求是无限的，连完成都无法保证，就更没有时间追求完美\n对比心态：很多行业内的新人或者准备入行的，都会去和行业内顶尖的人做对比。有一句很火的话“没有对比就没有伤害”，很多人用来对比好与坏，美与丑。其实另外层意思就是如果对比会对你自身造成打击又何必常常带着对比之心来对待自己和事情呢？对比不一定会有伤害，但是对比的心态才是真正造成伤害的源头。应该先认可自己的优点，接受自己的缺点，然后去找到别人的优点，发现别人的缺点。在别人的优点和缺点给自己带来成长。吸收别人优点，避免自己养成了同等的缺点。优秀的人不是天生比你优秀，而是TA们更懂的不自我透支，更懂得养成在无形之中让自己成长的习惯。\n复杂化：学会把复杂的问题和事情拆分成多个小问题小事情。复杂的问题和事情就会变得更加简单。因为问题和事情往往有多个点需要突破，把每个点拆开逐个突破就会更加简单轻松。从简到繁，如果太复杂，就拆开一个一个更简单的小点，逐个突破。\n悲观心态： 很多人遇到巨大难题时都会来一句“没有办法，做不到”。如果做不到，无论何事，都是自己还没有真正想做！没有做不到的事，只有自己不想做的！失败究其必有原因！成功必有方法！\n过度透支：学习累了就躺穿上休息，吃饱喝足了就坚决不吃了。养好一种自律的习惯，不过度透支自己的时间和生命，这样才能有更好的精神和态度面对问题和困难。近年来有很多给程序员打上的标签，”加班狗”，“无日无夜写代码”，“生活邋遢”，“衣服全是同款黑色”等等。确实，做为一个程序员，我们花了大部分时间都在想问题，编写者神乎奇幻代码和程序。但是我们都往往忘记了自己的身体已经在一点一点透支。到了那一天你停下来了，你会发现，身体不行了，除了写代码其他个方面的能力都没有时间去提升。也没有劲学习成长了，整个人好像很颓废，生无可恋一样。所以学会不透支自己，才有更好的状态和精力学习和突破自己。\n\n总结无论你是在学习技术还是在学士任何其他领域的知识。在学习这条路上都会有坑坑洼洼，各种颠簸。所以我们学习要有技巧，要有方法才能在有效时间内收获最大化！\n\n\n\n\n\n\n\n\n\n学习法门：\n\n锁定目标 - 选择有用的，对你现在阶段有价值的目标\n采用学习策略 - 深入学习，投入实战，总结经验\n管理好时间 - 把控好时间，提高效率\n多思考，多总结 - 多思考问题，多总结和记录知识\n改掉不好的习惯和心态 - 有好的习惯才能更轻松的学习和成长\n\n一个人一生是有学不完的知识和技能，然而人一生的时间是有限的。所以要把我们的时间和收益最大化才能比同年龄的人跑的更快，学的更多，能力更强！大家一起在学习的道路上继续加油吧！\n","slug":"notes/learn-programming-more-effectively","date":"2019-11-01T10:26:02.000Z","categories_index":"Notes","tags_index":"Learning,Programming,Notes","author_index":"三钻"},{"id":"a39070ddc42fa1b74b93b830b684f61e","title":"真正的`服务层`是怎么写的?","content":"其实很多系统架构里面都有服务层，但是服务对很多开发人员来说都有很多不同的定义和写法。甚至在我待过的公司里都有不同的写法和编写模式。每个人每个团队每个项目都有对服务不同的理解。那到底什么是服务，怎么理解才是对的呢？\n你们有没有过无数个夜晚里严重怀疑人生，琢磨着到底哪一种服务才是对的？哪一种才是最好的写法，哪一种才能达到服务的真正意义？因为这种执着，我开始在国外的各种网站，大神们写过的开源大项目里面和文章里面总结出一个大多数研发伙伴们认可的理解方式和编写方式。\n要理解什么是服务，我们先来给服务一个定义，在系统架构里面处于什么角色，作用是什么。\n\n服务定义\n\n\n\n\n\n\n\n\n角色：服务是系统架构里面的业务处理层。作用：主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。\n这个定义没毛病吧？赞同的童鞋在评论里举个手哈 👋。好，有了一个优雅高尚的服务定义，我们来用一个通俗易懂的例子来理解服务。\n\n理解服务\n假设人是一个控制器，现在拿到了一个衣服对象的参数，然后人拥有一个洗衣服的方法\n现在人需要洗衣服，但是手洗效率太低了，所以我们写了一个多功能的洗衣机服务给到人去使用\n洗衣机这个服务里面有很多不同洗衣服的方法，但是其实具体洗衣机里面的每一个清洗方法人是不知道怎么实现的，人都是直接按照提供的功能直接使用。\n所以所有服务里面的方法都是解耦在服务里面，服务要提供的方法是可以方便人使用的。\n\n\n这样说是不是很好理解了？所以最简单的理解就是：\n\n\n\n\n\n\n\n\n\n服务是用来封装业务逻辑代码，是一个独立的逻辑层，高度封装解耦后提供给控制器或者其他需要用到这个服务的地方使用的。\n\n编写思路❌ 错误例子\n\n\n\n\n\n\n\n\n\n把所有洗衣机的方法提供给人使用，那就等同于让人来决定所有洗衣机的参数和清洗步骤。那人放衣服到洗衣机后，要选择先加水，加多少水，然后清洗开始，清洗多久，再甩干等等。\n就想想这个洗衣机就不想用了，洗个衣服那么多选项，还要想那个设置顺序才是对的！ 我太难了！洗个鸡腿哦！(ﾉ｀ □ ´)ﾉ ⌒┻━┻\n⭕️ 正确例子\n\n\n\n\n\n\n\n\n\n洗衣机服务实现了很多不同的常用洗衣服的模式, 比如快速清洗，毛衣清洗，地毯清洗，风干，甩干等等。都是一些常用的功能。每个功能方法里面其实调用了很多洗衣机封装好的流程和方法。这样人使用洗衣机根本不需要知道这些功能是怎么实现的，只要知道自己要干嘛，洗衣机有这个模式，直接用就好了。\n(✧ᗜ✧)👍 哇！ 介么人性化的么！这种洗衣机给我来一打谢谢！思路我们整理清楚了，那么可以开始看看用这种思维模式写成代码是怎么样的。来上机械键盘，开始快乐滴敲代码了！\n服务写法Controller 控制器首先我们写一个人控制器PersonController.php，作为一个优秀的人类，我们天生就会洗衣服，但是人嘛天生就是懒惰的。所以我们买了一台洗衣机（实现洗衣机服务）并且我们学会了使用洗衣机来洗衣服。（实现wash方法）٩(◦&#96;꒳´◦)۶\n\n\n\n\n\n\n\n\n\n一个人PersonController，有一个洗衣服方法wash，需要洗衣服的时候实例洗衣服务new WashingMachineServer()，然后只要把衣服传入洗衣机服务的快洗方法，洗衣机服务就会开始快速quickWash($cloth)清洗了。\n&#x2F;&#x2F; 人控制器\nclass PersonController\n&#123;\n    &#x2F;**\n    * 洗衣服方法\n    *\n    * @param object $cloth 衣服对象\n    *&#x2F;\n    public function wash($cloth)\n    &#123;\n        $washingMachine &#x3D; new WashingMachineService();\n        $washingMachine-&gt;quickWash($cloth); &#x2F;&#x2F; 调用洗衣机的快速清洗功能\n    &#125;\n&#125;\n\n我们好奇的童鞋们，肯定会好奇，那这个洗衣机（WashingMachineService.php服务) 到底是怎么实现的呢？它的快洗功能是怎么做的呢？那我们就来自己建一部洗衣机，自然就懂了。\nService 服务动手之前我们要先思考，先分析，养成这样的好习惯，代码再也不难写了。\n\n\n\n\n\n\n\n\n\n分析的重点分为服务的运作和流程, 可变动的属性，最后就是有那些可以提供的模式。\n\n洗衣机应该怎么运作和流程的：\n把衣服放入洗衣机 addCloth()\n注入水到洗衣机里 addWater()\n开始洗衣服（开始旋转和各种累活）wash()\n把水排除洗衣机 flushWater()\n把衣服取出 fetchClouth()\n\n\n洗衣机可变动的属性：\n要把衣服放入洗衣机，我们就需要有个东西来装着，然后才能清洗，所以我们应该有一个洗衣桶 $bucket\n根据衣服的量，使用的水量是应该可以调节的。（对我们要节约用水嘛）$washDuration\n\n\n洗衣机最常用的模式：\n快速洗 quickWash()\n\n\n\n\n\n\n\n\n\n\n\n\n\n⚠️ 需要注意：\n\n所有洗衣机的内部方法都是 private 私有方法，因为都是给洗衣机使用的，外部的人是不能使用的；\n快速清洗和取衣服这两个方法是 public 共有方法，因为是洗衣机提供出去给人使用的方法；\n所有属性都是 protected 保护属性，是洗衣机独有的属性。\n\n现在我们就要使用程序员的魔法，把以上的逻辑和属性转换成代码。\nclass WashingMachineService\n&#123;\n    &#x2F;**\n    * 清洗时长 (分钟)\n    * @var integer\n    *&#x2F;\n    protected $washDuration &#x3D; 60;\n\n    &#x2F;**\n    * 洗衣机的洗衣桶\n    * @var array\n    *&#x2F;\n    protected $bucket;\n\n    &#x2F;**\n    * 改变默认洗衣机的清洗时长\n    * @param integer $duration\n    *&#x2F;\n    public function changeWashDuration($duration)\n    &#123;\n        $this-&gt;washDuration &#x3D; intval($duration);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 往洗衣机的桶加入水\n    *&#x2F;\n    private function addWater()\n    &#123;\n        array_merge($this-&gt;bucket, [&#39;water&#39; &#x3D;&gt; &#39;cold water&#39;]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 把衣服加入洗衣机桶内\n    *&#x2F;\n    private function addCloth($cloth)\n    &#123;\n        array_merge($this-&gt;bucket, [&#39;cloths&#39; &#x3D;&gt; $cloth]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 旋转桶把开始洗衣服\n    *&#x2F;\n    private function wash()\n    &#123;\n        &#x2F;&#x2F; 使用洗衣机的清洗时长来全换清洗衣服\n        for ($duration &#x3D; $this-&gt;washDuration; $duration &gt; 0; $duration--) &#123;\n            array_rand($this-&gt;bucket, 3);\n        &#125;\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 把桶里面的水清除掉\n    *&#x2F;\n    private function flushWater()\n    &#123;\n        unset($this-&gt;bucket[&#39;water&#39;]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 从洗衣桶里面把衣服拿回出来\n    *&#x2F;\n    private function fetchCloths()\n    &#123;\n        return $this-&gt;bucket[&#39;cloths&#39;]\n    &#125;\n\n    &#x2F;**\n    * 快速清洗衣服方法\n    *&#x2F;\n    public function quickWash($cloth)\n    &#123;\n        return $this-&gt;changeWashDuration(10) &#x2F;&#x2F; 重新设置洗衣服的时长\n                    -&gt;addCloth($cloth) &#x2F;&#x2F; 加入衣服\n                    -&gt;addWater() &#x2F;&#x2F; 加入水\n                    -&gt;wash() &#x2F;&#x2F; 开始清洗\n                    -&gt;flushWater() &#x2F;&#x2F; 清除水\n                    -&gt;fetchCloths(); &#x2F;&#x2F; 最后取出衣服返回\n    &#125;\n&#125;\n\n以上就是一个最基础的服务，有独立的内部方法可以让服务运作起来，也有提供出去的服务模式方法。\n\n\n\n\n\n\n\n\n\n⚠️ 需要注意:服务的重点特性在最后这个 quickWash 快速清洗方法。实现快速清洗是通过使用特定顺序和组合方式调用洗衣机内部方法。这种服务的实现方式，可以把一个服务里面的业务逻辑拆分成多个逻辑块，然后通过不同的顺序和组合来实现某种模式或者功能。这样的服务就非常有弹性，而且所有逻辑块复用性极高。这个也是设计模式里面的模版方法模式（Template Method）。\n上面的例子只是写了一个洗衣机 10%不到的功能，一个完整的洗衣机还会有很多的逻辑方法。那问题就来了，方法多了这个服务就会开始臃肿。这个时候我们就要想一套解耦封装服务的方式方法。接下来我们来讲解一下怎么更深度的服务封装。\n\n服务封装在日常开发过程中，我们有各种各样的封装和解耦方式。包括内部Trait, 内部服务，工厂设计模式。这几种都是可以用来深度封装服务的方式方法。找到了方法，下一步就是要找到怎么封装才是最优解耦思路。解耦的原理就是找到共通点和公用点。然后把这些方法封装起来，解耦出去。\n封装思路\n\n\n\n\n\n\n\n\n在上面写的洗衣机服务，里面的洗衣桶是很通用的和独立的业务逻辑。所以它是可以解耦封装在一起的。\n\n洗衣机的bucket洗衣桶属性的方法其实可以封装起来。单独做为一个洗衣桶的服务。\n所有涉及洗衣桶操作的功能和流程都封装到洗衣桶服务里面给洗衣机调用。\n\n使用上面的逻辑，我们可以把洗衣机服务和洗衣桶服务拆分成两块。来吧上机械键盘！\n\n封装编写\n洗衣机服务 WashingMachineService.php\n\nclass WashingMachineService\n&#123;\n    &#x2F;**\n    * 清洗时长 (分钟)\n    * @var integer\n    *&#x2F;\n    protected $washDuration &#x3D; 60;\n\n    &#x2F;**\n    * 改变默认洗衣机的清洗时长\n    * @param integer $duration\n    *&#x2F;\n    public function changeWashDuration($duration)\n    &#123;\n        $this-&gt;washDuration &#x3D; intval($duration);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 快速清洗衣服方法\n    *&#x2F;\n    public function quickWash($cloth)\n    &#123;\n        $washingBucket &#x3D; new WashingBucketService();\n\n        $this-&gt;changeWashDuration(10) &#x2F;&#x2F; 重新设置洗衣服的时长\n\n        &#x2F;&#x2F; 调用洗衣机的桶去清洗衣服\n        return $washingBucket-&gt;addCloth($cloth) &#x2F;&#x2F; 加入衣服\n                    -&gt;addWater() &#x2F;&#x2F; 加入水\n                    -&gt;wash($this-&gt;washDuration) &#x2F;&#x2F; 开始清洗\n                    -&gt;flushWater() &#x2F;&#x2F; 清除水\n                    -&gt;fetchCloths(); &#x2F;&#x2F; 最后取出衣服返回\n    &#125;\n&#125;\n\n\n洗衣桶服务 - WashingBucketService.php\n\nclass WashingBucketService\n&#123;\n    &#x2F;**\n    * 洗衣机的洗衣桶\n    * @var array\n    *&#x2F;\n    protected $bucket;\n\n    &#x2F;**\n    * 往洗衣机的桶加入水\n    *&#x2F;\n    public function addWater()\n    &#123;\n        array_merge($this-&gt;bucket, [&#39;water&#39; &#x3D;&gt; &#39;cold water&#39;]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 把衣服加入洗衣机桶内\n    *&#x2F;\n    public function addCloth($cloth)\n    &#123;\n        array_merge($this-&gt;bucket, [&#39;cloths&#39; &#x3D;&gt; $cloth]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 旋转桶把开始洗衣服\n    *&#x2F;\n    public function wash($washDuration)\n    &#123;\n        &#x2F;&#x2F; 使用洗衣机的清洗时长来全换清洗衣服\n        for ($duration &#x3D; $washDuration; $duration &gt; 0; $duration--) &#123;\n            array_rand($this-&gt;bucket, 3);\n        &#125;\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 把桶里面的水清除掉\n    *&#x2F;\n    public function flushWater()\n    &#123;\n        unset($this-&gt;bucket[&#39;water&#39;]);\n\n        return $this;\n    &#125;\n\n    &#x2F;**\n    * 从洗衣桶里面把衣服拿回出来\n    *&#x2F;\n    public function fetchCloths()\n    &#123;\n        return $this-&gt;bucket[&#39;cloths&#39;]\n    &#125;\n&#125;\n\n\n提供和调用模块与模块或者系统与系统直接都会使用到服务来互相打通业务。这个时候服务就要有一个方式提供出去让外部的模块或者系统调用。\n\n\n\n\n\n\n\n\n\n⚠️ 需要注意：这里说的是外部模块或者系统调用，这个是要考虑到如果是微服务的话，每个模块都会在不同的服务器和域名下，这个时候就需要异步调用。这种情况下如果还是用类实例的方式来提供和调用服务后面要改就很麻烦了。\n这种情况下目前最优的方式就是服务提供者用Trait给到服务使用者来注入到业务代码里面。\n\n洗衣机服务 Trait - WashingMachineProvider.php\n\ntrait WashingMachineProvider\n&#123;\n    &#x2F;**\n    * 提供洗衣机服务类\n    *&#x2F;\n    public washingMachine()\n    &#123;\n        return new \\WashingMachineService();\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n⚠️ 需要注意：这里是使用了命名空间来实例洗衣机服务类的。但是如果改成了微服务，那我们只需要改掉所有这些服务提供 Trait，把服务类实例改为服务发现，或者异步服务调用就可以了。再也不用花钱去买霸王洗发水了。\n\n总结经历了千辛万苦，无数个失眠的夜晚。终于知道服务到底是什么，应该怎么写，怎么写才是对的。写好服务可以提高代码的维护性，编写的代码也会有更强的逻辑和条理。好的服务也会有更好的弹性和扩张性。下面我们来总结一下编写服务的重点。\n\n\n\n\n\n\n\n\n\n角色: 服务是系统架构里面的业务处理层。作用: 主要是为了高度解耦和封装不同场景的业务和功能到对应的服务，然而达到高度中心化的业务代码。思路: 逻辑要独立，分解成逻辑块，保持复用性高，尽量不要限定逻辑使用的顺序和高弹性的组合性。编写: 高度封装，高内聚的原理来编写服务，细化分解通用性，公用性的业务，然后封装成一个服务。\n\n\n\n\n\n\n\n\n\n\n#通过技术悟出人生道理# 💭“大千世界每一件事都有千百万种做法，吸收，打磨，专研，总结，进步，才会找到最适合的做法。”  ～ 三·钻 TriDiamond\n","slug":"backend/how-to-write-a-service","date":"2019-10-19T00:01:58.000Z","categories_index":"BackEnd","tags_index":"PHP,Service,Architecture","author_index":"三钻"},{"id":"8c6e317d34a70d85c4a6b275416b9854","title":"使用Console技巧提高JS调试技能","content":"其实 JavaScript 给到我们很多调试工具来调试代码，那问问你自己，你又知道多少呢？用到多少呢？\n大部分前端开发在 JavaScript 调试代码的常规用法都是直接console.log，直接输出某一个变量或者返回数据里面的对象数据。当然毋庸置疑这样输出来调试是没有问题的。但是不是最优雅的方式来调试代码，其实还有更好的办法。作为一个有追求的技术人才，有更好的调试方式为什么不去使用呢？\n\n我们先来了解清楚浏览器的console。浏览器的console对象有提供自带的调试控制台。console对象只能在浏览器的 JavaScript 中使用，也就是说客户端应用可用而服务端应用不可用。它的作用或者效果会根据不同的浏览器而不同，但是基础使用方式和功能是基本一致的。不过console是可以在任何前端语言或者框架中使用。\n\nconsole.log最常用的使用方式就是console.log，对前端开发工程师来说就是家常便饭了。以下是一个简单的使用例子。\nfunction sayHello(name) &#123;\n  console.log(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\n\n\n\n\n\n\n\n\n\n\n以上sayHello方法接收一个名字，然后在控制台输出出来。\n\n现在我们开始玩以下更有趣的调试方法。加入我们现在想知道sayHello这个方法被调用了多少次，这样我们应该怎么调试呢？其实有一个很简单的办法就是使用console.count().\n\nconsole.countcount()方法会输出某一个标示被调用了几次。如果没有穿任何参数，count()默认为使用默认标示defaut。\nfunction sayHello(name) &#123;\n  console.count()\n  console.log(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\nsayHello(&#39;William&#39;)\nsayHello(&#39;Kelly&#39;)\n\n\n\n\n\n\n\n\n\n\n以上代码就会在控制台输出以下结果：\n\n上面的例子实现了统计某一个方法被调用的次数，那如果我们想统计每个同名字(name)的在这个方法里面被调用了多少次呢？要调试这种其实也很简单，只要直接吧name直接传入count就可以了。\nfunction sayHello(name) &#123;\n  console.count(name)\n&#125;\n\nsayHello(&#39;Indrek&#39;)\nsayHello(&#39;William&#39;)\nsayHello(&#39;Kelly&#39;)\nsayHello(&#39;Indrek&#39;)\n\n‍(∩｀-´)⊃━☆ﾟ.*・｡ﾟ 巴拉巴拉！就是那么简单，我们就可以跟踪同名的参数在sayHello方法里面被调用的次数了！\n\n\nconsole.warn这个控台答应方法会输出一个警告信息。在你开发 APIs 或者开发工具的时候使用。console.warn这个方法在你需要警告用户的时候特别实用，例如漏掉了某个参数或者是让开发者知道你的 API&#x2F;插件包的版本已经失效的时候使用。\nfunction sayHello(name) &#123;\n  if (!name) &#123;\n    console.warn(&#39;No name given&#39;)\n  &#125;\n&#125;\n\nsayHello()\n\n\n\n\n\n\n\n\n\n\n上面的代码检测了sayHello方法的参数是否漏传。如果name参数没有传，一个警告消息就会被打印到控制台中。让开发者可以思考问题出在哪里。\n\n\nconsole.table如果是我们在调试数组或者对象时，console.table是一个非常实用的调试方法来在控制台打印数据。数组里面的每一个元素都会在表格的行里面展示。以下是的水果名数组作为一个例子，如果我们把这个数组传入console.table，我们会看到一个含有这个水果名数据以表格的方式在控制台被打印出来。\nconst fruits &#x3D; [&#39;kiwi&#39;, &#39;banana&#39;, &#39;strawberry&#39;]\n\nconsole.table(fruits)\n\n\n\n\n\n\n\n\n\n\n我们一起来围观以下在控制台里面的展示效果\n\n看到了这个，你会不会灵光一闪想到 mmp，如果是一个很大的数组这种表格化的展示方式是多么的实用啊！对的！例如一个上百个数据的数组，我们使用这种调试方法来打印就很方便了。为了可以让我们用双眼见证这个说法的真实性，我们用代码说话吧！\nconst fruits &#x3D; [\n  &#39;Apple&#39;,\n  &#39;Watermelon&#39;,\n  &#39;Orange&#39;,\n  &#39;Pear&#39;,\n  &#39;Cherry&#39;,\n  &#39;Strawberry&#39;,\n  &#39;Nectarine&#39;,\n  &#39;Grape&#39;,\n  &#39;Mango&#39;,\n  &#39;Blueberry&#39;,\n  &#39;Pomegranate&#39;,\n  &#39;Carambola&#39;,\n  &#39;Plum&#39;,\n  &#39;Banana&#39;,\n  &#39;Raspberry&#39;,\n  &#39;Mandarin&#39;,\n  &#39;Jackfruit&#39;,\n  &#39;Papaya&#39;,\n  &#39;Kiwi&#39;,\n  &#39;Pineapple&#39;,\n  &#39;Lime&#39;,\n  &#39;Lemon&#39;,\n  &#39;Apricot&#39;,\n  &#39;Grapefruit&#39;,\n  &#39;Melon&#39;,\n  &#39;Coconut&#39;,\n  &#39;Avocado&#39;,\n  &#39;Peach&#39;,\n]\n\nconsole.table(fruits)\n\n我们使用console.table来打印一下上面这个大数组试试看吧。\n\n\n\n\n\n\n\n\n\n\n这种展示方式简直就是一目了然！这样妈妈再也不用担心我们调试数据的时候蒙圈了！՞༘✡ (๑ •̀ㅂ•́)و✧\n但是问题少年们，我们可是有梦想的工程师，如果是用来调试对象会是怎么样呢？来吧亲自动手丰衣足食，上代码！\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconsole.table(pets)\n\n注意了兄弟姐妹们，现在我们打印的是对象不是数组。在控制台的表格现在有两个键值name和type。之前是 0，1，2，3，4…\n\n这种方式可以替代普遍使用的直接用 log 打印对象数据，表格化的展示相对还是更加清晰的。问题少年再次发问，如果我们想多个对象一起打印呢？\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconst person &#x3D; &#123;\n  firstName: &#39;Indrek&#39;,\n  lastName: &#39;Lasn&#39;,\n&#125;\n\nconsole.table(pets, person)\n\n与预想一致，两个不同键值的对象被才分成两个表格在控制台打印出来了。\n\n如果我们不想分开两个表格打印，可否在一个表格显示呢？可以的！只要把两个对象放入一个数组就 ok 了。\nconst pets &#x3D; &#123;\n  name: &#39;Simon&#39;,\n  type: &#39;cat&#39;,\n&#125;\n\nconst person &#x3D; &#123;\n  firstName: &#39;Indrek&#39;,\n  lastName: &#39;Lasn&#39;,\n&#125;\n\nconsole.table([pets, person])\n\n现在我们看到两个对象在一个表格里面展示了，键值被放在表格的头部了，因为键值在两个对象里面是不一样的。\n\n\nconsole.group当我们是在调试集合（sets）或者是关联数据（linked-data），可以使用嵌套组来优化你的控制台输出。使用console.group()来创建一个嵌套的组。\nconsole.log(&#39;This is the first level&#39;)\nconsole.group()\nconsole.log(&#39;Level 2&#39;)\nconsole.group()\nconsole.log(&#39;Level 3&#39;)\nconsole.warn(&#39;More of level 3&#39;)\nconsole.groupEnd()\nconsole.log(&#39;Back to level 2&#39;)\nconsole.groupEnd()\nconsole.log(&#39;Back to the first level&#39;)\n\n以下是一个嵌套的层级提示输出，在调试关联或者层级数据的时候特别实用。\n\n\n\n\n\n\n\n\n\n\n使用console.groupCollapsed()可以把所有嵌套的层级收起来，使用鼠标点击时可以展开查看。\n\n总结作为一名优秀的程序员，我们应该尽量在合适的场景或者合适的情况下运用在提供到给我的调试工具。所以这一篇文章提到的调试方式，我们应该在开发调试的过程中多合理运用，习惯后我们会发现调试起来会更加敏捷和高效。\n\n\n\n\n\n\n\n\n\n\n#通过技术悟出人生道理# 💭“人生无常，写的了一行是一行Code now or never”  ～ 三·钻 TriDiamond \n","slug":"frontend/debugging-skills-console","date":"2019-10-11T15:59:19.000Z","categories_index":"FrontEnd,Tips,Debugging","tags_index":"JavaScript,Console,Debugging","author_index":"三钻"},{"id":"0e4eed29bacbb07352028a3973ca9ed9","title":"GitLab Webhook 自动部署","content":"创建与填写部署公钥创建部署公钥sudo -Hu www ssh-keygen -t rsa\n\n\n\n\n\n\n\n\n\n\n如果创建失败首先需要创建&#x2F;home&#x2F;www&#x2F;.ssh 这个文件夹\n查看公钥cat &#x2F;home&#x2F;www&#x2F;.ssh&#x2F;id_rsa.pub\n&#96;&#96;&#96;··\n\n### 添加 Hook\n\n在阿里云 code.aliyun.com 上的 profile&gt;ssh_key 里面添加公钥\n\n## 初始化 git 项目文件夹\n\n&#96;&#96;&#96;bash\nsudo -Hu www git clone [git地址]\n\n\n\n\n\n\n\n\n\n\n这里注意, 一定要用 www 的身份状态要不后期无法自动 git pull\n自动部署脚本 (PHP)Shell_exec在使用这个 PHP 脚本的时候我们需要用到shell_execphp 的原生函数, php-fpm 是默认屏蔽这个函数的, 所有需要在 php.ini 里面修改一下配置\n\n\n\n\n\n\n\n\n\n找到disable_functions这个参数, 并且在里面去掉shell_exec\nPHP 脚本$token &#x3D; &#39;token&#39;;\n\nif (!isset($_GET[&#39;token&#39;]) &amp;&amp; $_GET[&#39;token&#39;] !&#x3D; $token) &#123;\n\tdie(&#39;access denied&#39;);\n&#125;\n\n$json &#x3D; json_decode(file_get_contents(&#39;php:&#x2F;&#x2F;input&#39;), true);\n$repo &#x3D; $json[&#39;repository&#39;][&#39;name&#39;];\n\n&#x2F;&#x2F; 只在主分支提交时且提交数大于0执行自动部署\nif ($json[&#39;ref&#39;]&#x3D;&#x3D;&#39;refs&#x2F;heads&#x2F;master&#39; &amp;&amp; $json[&#39;total_commits_count&#39;]&gt;0) &#123;\n\t$pull_result &#x3D; shell_exec(&#39;cd &#x2F;to&#x2F;project&#x2F;path&#x2F; &amp;&amp; git pull&#39;);\n\n\tif ($pull_result) &#123;\n\t\t$res_log &#x3D; &#39;----------pull 成功---------------&#39;.PHP_EOL;\n\n\t\t$res_log .&#x3D; $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;\n\t\t$res_log .&#x3D; $pull_result.PHP_EOL;\n\n\t\tfile_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);&#x2F;&#x2F;追加写入\n\t&#125; else &#123;\n\t\t$res_log &#x3D; &#39;------------pull 失败-------------&#39;.PHP_EOL;\n\n\t\t$res_log .&#x3D; $json[&#39;user_name&#39;] . &#39; 在&#39; . date(&#39;Y-m-d H:i:s&#39;) . &#39;向&#39; . $json[&#39;repository&#39;][&#39;name&#39;] . &#39;项目的&#39; . $json[&#39;ref&#39;] . &#39;分支push了&#39; . $json[&#39;total_commits_count&#39;] . &#39;个commit：&#39; . PHP_EOL;\n\t\t$res_log .&#x3D; $pull_result.PHP_EOL;\n\n\t\tfile_put_contents(&quot;cityconcierge-webhook-log.txt&quot;, $res_log, FILE_APPEND);&#x2F;&#x2F;追加写入\n\t&#125;\n&#125;\n","slug":"server/aliyun-webhook-setup","date":"2019-09-10T01:51:23.000Z","categories_index":"运维","tags_index":"Gitlab,Webhook","author_index":"三钻"},{"id":"856e8266ee6e8a15c82abdb9b8c2a650","title":"Lumen 使用 laravel passport","content":"Lumen是laravel的简洁版, 把laravel里面深重的依赖都去掉了, 所以直接安装laravel的passport是无法正常使用的.所以如果要在lumen上使用laravel的passport就需要安装另外一个插件.\n安装要求\nPHP &gt;&#x3D; 5.6.3\nLumen &gt;&#x3D; 5.3\n\nComposer安装lumen-passport插件首先安装 Lumen Passport\n# 进入项目根目录\n$ cd lumen-app\n\n# 使用composer安装插件\n$ composer require dusterio&#x2F;lumen-passport\n\n修改 bootstrap (bootstrap&#x2F;app.php)需要引入Laravel Passport的provider和Lumen的一些provider\n&#x2F;&#x2F; 开启 Facades\n$app-&gt;withFacades();\n\n&#x2F;&#x2F; 开启 Eloquent\n$app-&gt;withEloquent();\n\n&#x2F;&#x2F; 开启 auth 中间件\n$app-&gt;routeMiddleware([\n    &#39;auth&#39; &#x3D;&gt; App\\Http\\Middleware\\Authenticate::class,\n]);\n\n&#x2F;&#x2F; 注册laravel passport的provider和lumen passport的provider\n$app-&gt;register(Laravel\\Passport\\PassportServiceProvider::class);\n$app-&gt;register(Dusterio\\LumenPassport\\PassportServiceProvider::class);\n数据表移植和安装Laravel Passport# 移植passport的数据表\nphp artisan migrate\n\n# 安装passport需要的配置\nphp artisan passport:install\n\nLumen Passport自带的路由这个lumen-passport包已经引入了一下路由, 但是与web相关的路由因为lumen是没有web的路由的, 只有api的, 所以这个插件已经把web端的路由都去掉了.\n\n\n\nVerb\nPath\nNamedRoute\nController\nAction\nMiddleware\n\n\n\nPOST\n&#x2F;oauth&#x2F;token\n\n\\Laravel\\Passport\\Http\\Controllers\\AccessTokenController\nissueToken\n-\n\n\nGET\n&#x2F;oauth&#x2F;tokens\n\n\\Laravel\\Passport\\Http\\Controllers\\AuthorizedAccessTokenController\nforUser\nauth\n\n\nDELETE\n&#x2F;oauth&#x2F;tokens&#x2F;{token_id}\n\n\\Laravel\\Passport\\Http\\Controllers\\AuthorizedAccessTokenController\ndestroy\nauth\n\n\nPOST\n&#x2F;oauth&#x2F;token&#x2F;refresh\n\n\\Laravel\\Passport\\Http\\Controllers\\TransientTokenController\nrefresh\nauth\n\n\nGET\n&#x2F;oauth&#x2F;clients\n\n\\Laravel\\Passport\\Http\\Controllers\\ClientController\nforUser\nauth\n\n\nPOST\n&#x2F;oauth&#x2F;clients\n\n\\Laravel\\Passport\\Http\\Controllers\\ClientController\nstore\nauth\n\n\nPUT\n&#x2F;oauth&#x2F;clients&#x2F;{client_id}\n\n\\Laravel\\Passport\\Http\\Controllers\\ClientController\nupdate\nauth\n\n\nDELETE\n&#x2F;oauth&#x2F;clients&#x2F;{client_id}\n\n\\Laravel\\Passport\\Http\\Controllers\\ClientController\ndestroy\nauth\n\n\nGET\n&#x2F;oauth&#x2F;scopes\n\n\\Laravel\\Passport\\Http\\Controllers\\ScopeController\nall\nauth\n\n\nGET\n&#x2F;oauth&#x2F;personal-access-tokens\n\n\\Laravel\\Passport\\Http\\Controllers\\PersonalAccessTokenController\nforUser\nauth\n\n\nPOST\n&#x2F;oauth&#x2F;personal-access-tokens\n\n\\Laravel\\Passport\\Http\\Controllers\\PersonalAccessTokenController\nstore\nauth\n\n\nDELETE\n&#x2F;oauth&#x2F;personal-access-tokens&#x2F;{token_id}\n\n\\Laravel\\Passport\\Http\\Controllers\\PersonalAccessTokenController\ndestroy\nauth\n\n\n配置修改 config/auth.php 里面的配置, 按照项目需要修改. 下面是一个简单的例子\nreturn [\n    &#39;defaults&#39; &#x3D;&gt; [\n        &#39;guard&#39; &#x3D;&gt; &#39;api&#39;,\n        &#39;passwords&#39; &#x3D;&gt; &#39;users&#39;,\n    ],\n\n    &#39;guards&#39; &#x3D;&gt; [\n        &#39;api&#39; &#x3D;&gt; [\n            &#39;driver&#39; &#x3D;&gt; &#39;passport&#39;,\n            &#39;provider&#39; &#x3D;&gt; &#39;users&#39;,\n        ],\n    ],\n\n    &#39;providers&#39; &#x3D;&gt; [\n        &#39;users&#39; &#x3D;&gt; [\n            &#39;driver&#39; &#x3D;&gt; &#39;eloquent&#39;,\n            &#39;model&#39; &#x3D;&gt; \\App\\User::class\n        ]\n    ]\n];\n\n需要在 vendor\\laravel\\lumen-framework\\config\\auth.php 复制到项目根目录下的config文件夹里面, 如果没有config文件夹, 需要手动添加一个.\n然后在bootstrap/app.php最前面加入配置应用, 因为lumen是不自动引入config里面的配置的.\n$app-&gt;configure(&#39;auth&#39;);\n\n注册路由需要在Provider\\AuthServiceProviders.php里面的boot方法里面注册路由\n&#x2F;**\n* Boot the authentication services for the application.\n*\n* @return void\n*&#x2F;\npublic function boot()\n&#123;\n    &#x2F;&#x2F; Here you may define how you wish users to be authenticated for your Lumen\n    &#x2F;&#x2F; application. The callback which receives the incoming request instance\n    &#x2F;&#x2F; should return either a User instance or null. You&#39;re free to obtain\n    &#x2F;&#x2F; the User instance via an API token or any other method necessary.\n\n    LumenPassport::routes($this-&gt;app); &#x2F;&#x2F; 注册路由\n\n    LumenPassport::tokensExpireIn(Carbon::now()-&gt;addDays(7));\n\n    LumenPassport::refreshTokensExpireIn(Carbon::now()-&gt;addDays(30));\n&#125;\n\n简单路由注册\nDusterio\\LumenPassport\\LumenPassport::routes($this-&gt;app);\n\n通用版本控制的路由\nDusterio\\LumenPassport\\LumenPassport::routes($this-&gt;app, [&#39;prefix&#39; &#x3D;&gt; &#39;v1&#x2F;oauth&#39;]);\n\n用户模型需要在用户模型里面加入HasApiTokens的trait, 例子:\nclass User extends Model implements AuthenticatableContract, AuthorizableContract\n&#123;\n    use HasApiTokens, Authenticatable, Authorizable;\n\n    &#x2F;* rest of the model *&#x2F;\n&#125;\n\n其他其他的详细文档可以查看lumen-passport的插件github\n","slug":"laravel/lumen-passport-usage","date":"2019-01-10T01:51:23.000Z","categories_index":"Laravel","tags_index":"Laravel Passport,Lumen","author_index":"三钻"},{"id":"44e4c38c8d84ec4aadd2af71d96fa2b0","title":"Lumen passport实现多个用户体系下的oauth验证","content":"这个教程是基于, lumen里面已经安装好了lumen-passport的插件, 如果还没有的话可以先到lumen使用laravel passport教程先安装.\n改写Laravel Passport里面的UserRepository\n\n\n\n\n\n\n\n\n文件路径 vendor\\laravel\\passport\\src\\Bridge\\UserRepository.php\n\n首先需要改写userRepositroy里面的getUserEntityByUserCredentials方法\n\n复制userRepositroy里面的getUserEntityByUserCredentials方法, 改名为getEntityByUserCredentials\n\n在新建的方法里面找到一下代码\n\n\n$provider &#x3D; config(&#39;auth.guards.api.provider&#39;);\n\n改成一下样子\n$provider &#x3D; config(&#39;auth.guards.&#39;.$provider.&#39;.provider&#39;);\n\n\n然后在新的方法getEntityByUserCredentials的参数里面添加新的参数$provider\n\npublic function getEntityByUserCredentials($username, $password, $grantType, \n  ClientEntityInterface $clientEntity, $provider) &#123;\n      &#x2F;&#x2F;...\n&#125;\n\n修改oauth2-server里面的PasswordGrand\n\n\n\n\n\n\n\n\n文件路径 vendor\\league\\oauth2-server\\src\\Grant\\PasswordGrant.php\n\n修改validateUser方法里面的这一串代码:\n\n$user &#x3D; $this-&gt;userRepository-&gt;getEntityByUserCredentials(\n    $username,\n    $password,\n    $this-&gt;getIdentifier(),\n    $client,\n    $provider &#x2F;&#x2F; 新加的provider字段\n);\n\n\n在同一个方法里面加入新参数的获取\n\n$provider &#x3D; $this-&gt;getRequestParameter(&#39;provider&#39;, $request);\n\nif (is_null($provider)) &#123;\nthrow OAuthServerException::invalidRequest(&#39;provider&#39;);\n&#125;\n\n在auth.php配置里面加入新的guard首先需要加入新的guard配置\n&#39;guards&#39; &#x3D;&gt; [\n    &#x2F;&#x2F; 原有的api guard\n    &#39;api&#39; &#x3D;&gt; [\n        &#39;driver&#39; &#x3D;&gt; &#39;passport&#39;,\n        &#39;provider&#39; &#x3D;&gt; &#39;users&#39;,\n    ],\n    &#x2F;&#x2F; 新加的admin-api guard\n    &#39;admin-api&#39; &#x3D;&gt; [\n        &#39;driver&#39; &#x3D;&gt; &#39;passport&#39;,\n        &#39;provider&#39; &#x3D;&gt; &#39;admins&#39;,\n    ],\n],\n\n添加新admin-api guard的provider\n&#39;providers&#39; &#x3D;&gt; [\n    &#39;users&#39; &#x3D;&gt; [\n        &#39;driver&#39; &#x3D;&gt; &#39;eloquent&#39;,\n        &#39;model&#39; &#x3D;&gt; \\App\\Models\\General\\MemberLogin::class\n    ],\n    &#x2F;&#x2F; 新加的admins provider对应不用的用户模型\n    &#39;admins&#39; &#x3D;&gt; [\n        &#39;driver&#39; &#x3D;&gt; &#39;eloquent&#39;,\n        &#39;model&#39; &#x3D;&gt; \\App\\Models\\Backend\\Manager::class\n    ]\n],\n\n路由middleware使用区别在于middleware, 上文加入的新admin-apiguard, 在新的路由里面就可以使用auth:admin-api的权限验证中间件理实现权限控制了!\n&#x2F;*\n|--------------------------------------------------------------------------\n| Admin API版本 v1 路由\n|--------------------------------------------------------------------------.\n|\n| prefix admin&#x2F;api&#x2F;api版本号\n| namespace Api\\api版本号\n|\n*&#x2F;\n$app-&gt;group([&#39;prefix&#39; &#x3D;&gt; &#39;admin&#x2F;api&#x2F;v1&#39;, &#39;namespace&#39; &#x3D;&gt; &#39;AdminApi\\V1&#39;], function ($app) &#123;\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 不受登录权限控制的接口路由 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;\n    &#x2F;&#x2F;测试\n    $app-&gt;get(&#39;test&#39;, &#39;ExampleController@test&#39;);\n\n    &#x2F;&#x2F; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 受登录权限控制的接口路由 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#x2F;&#x2F;\n    $app-&gt;group([&#39;middleware&#39; &#x3D;&gt; &#39;auth:admin-api&#39;], function ($app) &#123;\n        &#x2F;&#x2F;测试\n        $app-&gt;get(&#39;test2&#39;, function()&#123;\n            return &#39;oauth test&#39;;\n        &#125;);\n        &#x2F;&#x2F;测试\n        $app-&gt;get(&#39;test3&#39;, &#39;ExampleController@test&#39;);\n    &#125;);\n\n&#125;);\n\n注意事项使用了多个guard的时候, 在使用laravel默认的$request-&gt;user(), 这个方法默认是使用apiguard的, 可以在auth.php配置里面看到默认guard的配置.\n&#x2F;*\n|--------------------------------------------------------------------------\n| Authentication Defaults\n|--------------------------------------------------------------------------\n|\n| This option controls the default authentication &quot;guard&quot; and password\n| reset options for your application. You may change these defaults\n| as required, but they&#39;re a perfect start for most applications.\n|\n*&#x2F;\n\n&#39;defaults&#39; &#x3D;&gt; [\n    &#39;guard&#39; &#x3D;&gt; env(&#39;AUTH_GUARD&#39;, &#39;api&#39;),\n    &#39;passwords&#39; &#x3D;&gt; &#39;users&#39;,\n],\n\n所以在使用新的admin-api guard的时候在使用$request-&gt;user()时需要加入对应的guard. 例子:\nnamespace App\\Http\\Controllers\\AdminApi\\V1;\n\nuse App\\Http\\Controllers\\Controller;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Cache;\n\nclass ExampleController extends Controller\n&#123;\n    public function test(Request $request)\n    &#123;\n        $request-&gt;user(&#39;admin-api&#39;)-&gt;toArray(); &#x2F;&#x2F; 获取到admin-api下的用户信息\n    &#125;\n&#125;\n\n","slug":"laravel/lumen-multi-oauth","date":"2019-01-10T01:40:41.000Z","categories_index":"Laravel","tags_index":"Laravel Passport,Lumen","author_index":"三钻"},{"id":"b9c619014fc7379786141900ce0e39ef","title":"IONIC 2 实现首页双击退出APP","content":"添加绑定值\n\n\n\n\n\n\n\n\n首先在app/app.html下加入#myNav, 这个是用于绑定当前页面的导航标签\n&lt;ion-nav #myNav [root]&#x3D;&quot;rootPage&quot;&gt;&lt;&#x2F;ion-nav&gt;\n\n代码实现\n\n\n\n\n\n\n\n\n然后在app.component.ts做相对的改动\nimport &#123; Component, ViewChild &#125; from &#39;@angular&#x2F;core&#39;;\nimport &#123; Platform, ToastController, Nav, App &#125; from &#39;ionic-angular&#39;;\nimport &#123; StatusBar &#125; from &#39;@ionic-native&#x2F;status-bar&#39;;\nimport &#123; SplashScreen &#125; from &#39;@ionic-native&#x2F;splash-screen&#39;;\n\n\n@Component(&#123;\n  templateUrl: &#39;app.html&#39;,\n  providers: [SplashScreen, StatusBar]\n&#125;)\nexport class MyApp &#123;\n  rootPage &#x3D; &#39;TabsPage&#39;;\n  backButtonPressed: boolean &#x3D; false;  &#x2F;&#x2F;用于判断返回键是否触发\n  @ViewChild(&#39;myNav&#39;) nav: Nav;\n\n  constructor(public platform: Platform, private splashScreen: SplashScreen, private statusBar: StatusBar, public app: App, public toastCtrl: ToastController) &#123;\n    platform.ready().then(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F; Okay, so the platform is ready and our plugins are available.\n      &#x2F;&#x2F; Here you can do any higher level native things you might need.\n      this.statusBar.styleDefault();\n      this.statusBar.backgroundColorByHexString(&#39;#661F22&#39;);\n      this.splashScreen.hide();\n      this.registerBackButtonAction(); &#x2F;&#x2F;运行这个方法绑定返回按钮\n    &#125;);\n  &#125;\n\n  registerBackButtonAction() &#123;\n    this.platform.registerBackButtonAction(() &#x3D;&gt; &#123;\n      &#x2F;&#x2F;如果想点击返回按钮隐藏toast或loading或Overlay就把下面加上\n      &#x2F;&#x2F; this.ionicApp._toastPortal.getActive() || this.ionicApp._loadingPortal.getActive() || this.ionicApp._overlayPortal.getActive();\n      let nav &#x3D; this.app.getActiveNav();\n      if (nav.canGoBack())&#123; &#x2F;&#x2F;是否已经到了首页\n        nav.pop();\n      &#125;else&#123;\n        this.showExit()\n      &#125;\n    &#125;, 1);\n  &#125;\n\n  &#x2F;&#x2F;双击退出提示框\n  showExit() &#123;\n    if (this.backButtonPressed) &#123; &#x2F;&#x2F;当触发标志为true时，即2秒内双击返回按键则退出APP\n      this.platform.exitApp();\n    &#125; else &#123;\n     this.toastCtrl.create(&#123;\n      message: &#39;再按一次退出应用&#39;,\n      duration: 2000,\n      position: &#39;middle&#39;\n     &#125;).present();\n     this.backButtonPressed &#x3D; true;\n     setTimeout(() &#x3D;&gt; this.backButtonPressed &#x3D; false, 2000);&#x2F;&#x2F;2秒内没有再次点击返回则将触发标志标记为false\n    &#125;\n  &#125;\n&#125;\n\n\n","slug":"ionic/listen-to-back-button","date":"2017-04-24T00:00:00.000Z","categories_index":"Ionic","tags_index":"Ionic 2,Hybird App,Angular 4","author_index":"三钻"},{"id":"7f44014a2f442fb3c9579c3e2714cbfd","title":"IONIC 3 使用sliders轮播时拖动后autoplay失效解决方法","content":"我们先了解一下Ionic的Sliders\n\n\n\n\n\n\n\n\n首先Ionic里面的sliders是用Swiper.js的第三方插件实现的, Ionic官方Sliders的文档里面只描述了可以直接写入html标签内的属性, 有很多高级属性是没有写在文档里面的. \n要怎么改变sliders的其他属性呢?\n\n\n\n\n\n\n\n\n那如果我们要用到Swiper的其他属性怎么办呢? Ionic 2.x 的时候我们是可以在options里面传入的, 但是升级Ionic 3.x.x 后sliders的options属性被移除了. 现在要改变sliders的属性我们要用到sliders类. \n如何拖动轮播图后不让autoplay失效呢?\n\n\n\n\n\n\n\n\n首先我们要引入viewChild和Sliders\nimport &#123; ViewChild &#125; from &#39;@angular&#x2F;core&#39;;\nimport &#123; Slides &#125; from &#39;ionic-angular&#39;;\n\n\n\n\n\n\n\n\n\n\n\n然后使用ionViewWillEnter在进入页面前改变sliders的autoplayDisableOnInteraction属性\nimport &#123; ViewChild &#125; from &#39;@angular&#x2F;core&#39;;\nimport &#123; Slides &#125; from &#39;ionic-angular&#39;;\n\nclass MyPage &#123;\n  @ViewChild(Slides) slides: Slides;\n\n  ionViewWillEnter() &#123;\n    this.slides.autoplayDisableOnInteraction &#x3D; false; &#x2F;&#x2F;禁止slider拖动后autoPlay失效\n  &#125;\n&#125;\n","slug":"ionic/sliders-autoplay","date":"2017-04-20T00:00:00.000Z","categories_index":"Ionic","tags_index":"Hybird App,Ionic 3,Angular 4","author_index":"三钻"},{"id":"aa3962a24afd553a340b25c1704d59c4","title":"修复 Ionic 3.0.1 在IOS点击Tabs多次出现黑屏问题方法","content":"\n\n\n\n\n\n\n\n\nIonic 3.0.1 在IOS存在的一个严重的BUG，在IOS下多次重复点击TAB的时候页面会出现黑屏问题。\n\n\n\n\n\n\n\n\n\n好消息是目前有一个暂时的修复方法。但是这个方法涉及修改Ionic核心代码，所以如果你们正在使用Ionic3发布APP，可以暂时使用以下办法修复问题。\n\n\n\n\n\n\n\n\n\n在node_modules/ionic-angular/components/tabs/tabs.js找到一下代码 (468行)\ngetComponent(this._linker, tab.root).then(function (viewController) &#123;\n    if (viewController !&#x3D;&#x3D; active.component) &#123;\n        &#x2F;&#x2F; Otherwise, if the page we&#39;re on is not our real root\n        &#x2F;&#x2F; reset it to our default root type\n        return tab.setRoot(tab.root);\n    &#125;\n&#125;).catch(function () &#123;\n    (void 0) &#x2F;* console.debug *&#x2F;;\n&#125;);\n\n\n\n\n\n\n\n\n\n\n把以上代码改为\ngetComponent(this._linker, tab.root).then(function (viewController) &#123;\n    if (viewController.component !&#x3D;&#x3D; active.component) &#123;\n        &#x2F;&#x2F; Otherwise, if the page we&#39;re on is not our real root\n        &#x2F;&#x2F; reset it to our default root type\n        return tab.setRoot(tab.root);\n    &#125;\n&#125;).catch(function () &#123;\n    (void 0) &#x2F;* console.debug *&#x2F;;\n&#125;);\n\n\n\n\n\n\n\n\n\n\n以上解决办法来自于github上面的一个大神 https://github.com/driftyco/ionic/pull/11084\n","slug":"ionic/ios-blackscreen-fix","date":"2017-04-11T00:00:00.000Z","categories_index":"Ionic","tags_index":"Hybird App,Ionic 3,Angular 4","author_index":"三钻"},{"id":"4e215602f6b85cde51a96fad4b3567e1","title":"IONIC 2 升级 3 教程","content":"升级步骤\n\n\n\n\n\n\n\n\n这一次的升级Ionic 3 换成了使用最新的Angular 4.0, 最新的TypeScript, 添加了懒加载和修复了一些组件的bug.\n\n首先更新package.json, 按照以下的代码相应替换你package.json里面的代码, 并且把你项目根目录下的node_modules文件夹删除掉, 然后运行npm install (如果你是用淘宝镜像可以运行 cnpm install)\n\n&quot;dependencies&quot;: &#123;\n    &quot;@angular&#x2F;common&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;compiler&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;compiler-cli&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;core&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;forms&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;http&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;platform-browser&quot;: &quot;4.0.0&quot;,\n    &quot;@angular&#x2F;platform-browser-dynamic&quot;: &quot;4.0.0&quot;,\n    &quot;@ionic-native&#x2F;core&quot;: &quot;3.4.2&quot;,\n    &quot;@ionic-native&#x2F;splash-screen&quot;: &quot;3.4.2&quot;,\n    &quot;@ionic-native&#x2F;status-bar&quot;: &quot;3.4.2&quot;,\n    &quot;@ionic&#x2F;storage&quot;: &quot;2.0.1&quot;,\n    &quot;ionic-angular&quot;: &quot;3.0.1&quot;,\n    &quot;ionicons&quot;: &quot;3.0.0&quot;,\n    &quot;rxjs&quot;: &quot;5.1.1&quot;,\n    &quot;sw-toolbox&quot;: &quot;3.4.0&quot;,\n    &quot;zone.js&quot;: &quot;^0.8.4&quot;\n&#125;,\n&quot;devDependencies&quot;: &#123;\n  &quot;@ionic&#x2F;app-scripts&quot;: &quot;1.3.0&quot;,\n  &quot;typescript&quot;: &quot;~2.2.1&quot;\n&#125;\n\n\n第二步你需要在app/app.module.ts文件里面引入BrowserModule和HttpModule\n\n\n\n\n\n\n\n\n\n\n首先需要在头部引入这两个module (如果你的APP不使用HTTP可以不引入HttpModule)\nimport &#123; BrowserModule &#125; from &#39;@angular&#x2F;platform-browser&#39;;\nimport &#123; HttpModule &#125; from &#39;@angular&#x2F;http&#39;;\n\n\n\n\n\n\n\n\n\n\n在同一个文件里面找到imports并且加入BrowserModule和HttpModule\nimports: [\n  BrowserModule,\n  HttpModule,\n  IonicModule.forRoot(MyApp)\n],\n\n\n如果你升级到 Ionic Native 3.x, 就是CLI3. 使用 Ionic Native 3.x的话, APP打包出来会更小. 因为Ionic Native的原生插件都不自带有了, 你使用一个就要安装一个. 如果你原有的Ionic 2 项目有引入原生插件, 你就要做以下操作.\n\n\n\n\n\n\n\n\n\n\n这里用Camera和Geolocation这个两个原生插件作为例子, 你其他的插件都需要使用相同的方式做修改\n\n\n\n\n\n\n\n\n\n注意您使用的所有插件都必须要在app/app.module.ts里面先引用了, 而且要在app/app.modules.ts里面的providers里面声明, 如果没有这样配置就会出现No provider for XXXXX这样的报错了!\nCamera插件&#x2F;&#x2F; 在app&#x2F;app.module.ts文件里面\nimport &#123; Camera &#125; from &#39;@ionic-native&#x2F;camera&#39;;\n\n...\n\n@NgModule(&#123;\n  ...\n\n  providers: [\n    ...\n    Camera\n    ...\n  ]\n  ...\n&#125;)\nexport class AppModule &#123; &#125;\n\nGeolocation插件&#x2F;&#x2F; 在app&#x2F;app.module.ts文件里面\nimport &#123; Geolocation &#125; from &#39;@ionic-native&#x2F;geolocation&#39;;\nimport &#123; Platform &#125; from &#39;ionic-angular&#39;;\n\nimport &#123; NgZone &#125; from &#39;@angular&#x2F;core&#39;;\n\n@Component(&#123; ... &#125;)\nexport class MyComponent &#123;\n\n  constructor(private geolocation: Geolocation, private platform: Platform, private ngZone: NgZone) &#123;\n\n    platform.ready().then(() &#x3D;&gt; &#123;\n\n      &#x2F;&#x2F; get position\n      geolocation.getCurrentPosition().then(pos &#x3D;&gt; &#123;\n\n        console.log(&#96;lat: $&#123;pos.coords.latitude&#125;, lon: $&#123;pos.coords.longitude&#125;&#96;)\n\n      &#125;);\n\n\n      &#x2F;&#x2F; watch position\n      const watch &#x3D; geolocation.watchPosition().subscribe(pos &#x3D;&gt; &#123;\n\n        console.log(&#96;lat: $&#123;pos.coords.latitude&#125;, lon: $&#123;pos.coords.longitude&#125;&#96;)\n\n        &#x2F;&#x2F; Currently, observables from Ionic Native plugins\n        &#x2F;&#x2F; need to run inside of zone to trigger change detection\n        ngZone.run(() &#x3D;&gt; &#123;\n          this.position &#x3D; pos;\n        &#125;)\n\n      &#125;);\n\n      &#x2F;&#x2F; to stop watching\n      watch.unsubscribe();\n\n    &#125;);\n\n  &#125;\n\n&#125;\n\n\n\n\n\n\n\n\n\n\n更详细的文档可以参考官方的修改日记 https://github.com/driftyco/ionic-native/blob/master/README.md\n组件Component更变新网格\n\n\n\n\n\n\n\n\n旧的网格体系已经废除, 新的网格组件请参考官方文档 http://blog.ionic.io/build-awesome-desktop-apps-with-ionics-new-responsive-grid/\n标签的color属性更变\n\n\n\n\n\n\n\n\n以下标签的color属性在新的版本里面会不起效果了, 现在必须要使用ion-text才会起效果, 详细说明请看官方文档 http://ionicframework.com/docs/api/components/typography/Typography/\nh1[color], h2[color], h3[color], h4[color], h5[color], h6[color], a[color]:not([ion-button]):not([ion-item]):not([ion-fab]), p[color], span[color], b[color], i[color], strong[color], em[color], small[color], sub[color], sup[color]\n\nSlides组件更变\n\n\n\n\n\n\n\n\n以下的Slides属性和方法已经正式在新版本里面移除了\n\nSlides的input的options属性已经废除, 请使用标签的属性;\nSlide的事件ionWillChange方法已经废除, 请使用ionSlideWillChange;\nSlide的事件ionDidChange方法已经废除, 请使用ionSlideDidChange;\nSlide的事件ionDrag方法已经废除, 请使用ionSlideDrag;\nSlides的getSlider()方法已经废除, 请使用ion-slides实例;\n\n","slug":"ionic/upgrade-guide","date":"2017-04-10T00:00:00.000Z","categories_index":"Ionic","tags_index":"Hybird App,Ionic 3,Angular 4","author_index":"三钻"},{"id":"b0927e1c3835a3a3456ac936677ed5d9","title":"IONIC 2 - 确认密码","content":"开发过程中一般在注册或者修改密码都要写一个密码确认的表格, 这篇文章就是记录怎么在Ionic2里面使用FormBuilder和Validators判断密码是否一致.\n首先这篇文章是默认您已经了解怎么使用Angualr2的FormBuilder和Validator, 如果你还没了解这两个类的用法可以前去看Ionic2的文档\n实例一个FormGroup\n\n\n\n\n\n\n\n\n第一步首先我们需要实例了FormBuilder的一个FormGroup\n\n这里我们定义了passwordForm的这个表格里面的input.\n在最后我们加入了自定义认证方法 { validator: AdvanceValidator.matchingPasswords(‘password’, ‘rePassword’) }\n这里我们把password, 和rePassword 传给了 AdvanceValidator 方法, 这里传的是密码和确认密码在FormGroup里面定义的名字.\n现在我们看看这个password.ts怎么写.\n\nimport &#123; FormBuilder, Validators, FormGroup &#125; from &#39;@angular&#x2F;forms&#39;;\nimport &#123; AdvanceValidator &#125; from &#39;..&#x2F;..&#x2F;validators&#x2F;advance-validator&#39;;\n\n@Component(&#123;\n  selector: &#39;page-password&#39;,\n  templateUrl: &#39;password.html&#39;\n&#125;)\n\n&#x2F;&#x2F;密码修改页\nexport class PasswordPage &#123;\n  passwordForm: FormGroup;\n\n  constructor(private fb: FormBuilder) \n  &#123;\n    \n    this.passwordForm &#x3D; fb.group(&#123;\n        username: [&#39;&#39;, Validators.required],\n        password: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],\n        rePassword: [&#39;&#39;, Validators.compose([Validators.maxLength(30), Validators.minLength(7), Validators.required])],\n    &#125;, &#123; validator: AdvanceValidator.matchingPasswords(&#39;password&#39;, &#39;rePassword&#39;) &#125;);\n    \n  &#125;\n&#125;\n\n创建自定义认证器\n我们首先在项目根目录创建 validators 的文件夹\n然后在里面创建 advance-validators.ts 的ts文件\n在 advance-validators.ts 里面编以下代码\n\nimport &#123; FormGroup &#125; from &#39;@angular&#x2F;forms&#39;;\n\nexport class AdvanceValidator &#123;\n\n\tstatic matchingPasswords(passwordKey: string, rePasswordKey: string) &#123;\n    return (group: FormGroup) &#x3D;&gt; &#123;\n      let password &#x3D; group.controls[passwordKey]; &#x2F;&#x2F;获取密码值\n      let rePassword &#x3D; group.controls[rePasswordKey]; &#x2F;&#x2F;获取确认密码值\n\n      if(password.value !&#x3D;&#x3D; rePassword.value) &#123;\n        &#x2F;&#x2F;如果密码和确认密码的值不一致就返回给FormBuild rePassword有错误\n        return rePassword.setErrors(&#123;notEquivalent: true&#125;) \n      &#125;\n    &#125;\n  &#125;\n&#125;\n\n前端表格示例&lt;form [formGroup] &#x3D; &quot;passwordForm&quot;&gt;\n  &lt;ion-list inset&gt;\n\n    &lt;ion-item&gt;\n      &lt;ion-input type&#x3D;&quot;tel&quot; placeholder&#x3D;&quot;用户名&quot; formControlName&#x3D;&quot;username&quot;&gt;&lt;&#x2F;ion-input&gt;\n      &lt;div item-right *ngIf&#x3D;&quot;!passwordForm.controls.username.valid  &amp;&amp; (passwordForm.controls.username.dirty)&quot;&gt;\n        &lt;ion-icon name&#x3D;&quot;alert&quot;&gt;&lt;&#x2F;ion-icon&gt; 用户名必填\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;ion-item&gt;\n\n    &lt;ion-item&gt;\n      &lt;ion-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;新密码&quot; formControlName&#x3D;&quot;password&quot;&gt;&lt;&#x2F;ion-input&gt;\n      &lt;div item-right *ngIf&#x3D;&quot;!passwordForm.controls.password.valid  &amp;&amp; (passwordForm.controls.password.dirty)&quot; &gt;\n        &lt;ion-icon name&#x3D;&quot;alert&quot;&gt;&lt;&#x2F;ion-icon&gt; 密码必须7个字以上\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;ion-item&gt;\n\n    &lt;ion-item&gt;\n      &lt;ion-input type&#x3D;&quot;password&quot; placeholder&#x3D;&quot;确认密码&quot; formControlName&#x3D;&quot;rePassword&quot;&gt;&lt;&#x2F;ion-input&gt;\n      &lt;div item-right *ngIf&#x3D;&quot;!passwordForm.controls.rePassword.valid  &amp;&amp; (passwordForm.controls.rePassword.dirty)&quot; &gt;\n        &lt;ion-icon name&#x3D;&quot;alert&quot;&gt;&lt;&#x2F;ion-icon&gt; 密码必须一致\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;ion-item&gt;\n\n  &lt;&#x2F;ion-list&gt;\n&lt;&#x2F;form&gt;\n","slug":"ionic/comfirm-password-validators","date":"2017-03-19T00:00:00.000Z","categories_index":"Ionic","tags_index":"Ionic 2,Angular 2,Hybird App","author_index":"三钻"},{"id":"125c86bde17506b74edca579610bbf0d","title":"Laravel 5.4 开发笔记","content":"Laravel最近出的Laravel5.4新加了挺多功能的, 比起我用了1年的5.1完善多了. 比较吸引我使用最新的5.4的有几点:\n\n5.4 添加了谷歌内核的浏览器模拟操作\n自带API认证类”PASSPORT”\n路由自动分类, 现有有了Route自己的文件夹然后里面分类好了WEB和API的路由这一篇记录会分享一些我在尝试Laravel 5.4的过程中遇到的问题和经验\n\n开发记录移植(Migrate)用户和API认证表格是出现sql错误[Illuminate\\Database\\QueryException]                                                         \n  SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key  \n   length is 767 bytes (SQL: alter table &#96;users&#96; add unique &#96;users_email_unique&#96;(&#96;email&#96;))   \n\n[PDOException]                                                                               \n  SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key  \n   length is 767 bytes  \n\n解决办法就是在app&#x2F;Providers&#x2F;AppServiceProvider.php的这个文件里面的boot方法里面添加一下代码:\nuse Illuminate\\Support\\Facades\\Schema;\n\nfunction boot()\n&#123;\n    Schema::defaultStringLength(191);\n&#125;\n\n怎么不使用Laravel5.4自带的用户登录字段每次使用laravel自带的用户认证体系都会纠结, 怎么不用它自带的email作为用户名!这次适用Laravel5.4 又遇到了这个问题, 而且解决办法和5.1,5.2的不一样了, 因为Laravel的Auth Provider变动了.解决办法就是在自带的User.php(用户模型)里面使用findForPassport, 参考一下例子:\nclass User extends Authenticatable\n&#123;\n    use HasApiTokens, Notifiable;\n\n    &#x2F;&#x2F; ... some code\n\n    public function findForPassport($username) &#123;\n        return $this-&gt;where(&#39;id&#39;, $username)-&gt;first();\n    &#125;\n&#125;\n\n","slug":"laravel/laravel5.4-passport-and-authen","date":"2017-02-26T00:00:00.000Z","categories_index":"Laravel","tags_index":"Laravel 5.4,Laravel Passport","author_index":"三钻"},{"id":"a148b49e403314cabbbd91168179ddad","title":"IONIC 2 开发笔记","content":"因为IONIC2才刚刚开始进入正式版, 中文文档基本都是不全的, 我现在开发都是在看英文文档在开发的过程中遇到了很多文档没有描述的问题, 而且开发的过程中遇到一些框架本身没有完善的功能和存在的BUG\n我会在这个日记里面记录一些文档没有写的, 和我开发过程中遇到的一些坑和经验, 希望可以帮助那些刚刚接触IONIC2的程序猿们!\nAPP配置域名配置因为跨域问题，在开发时如果要用到本地环境进行开发(ionic serve)，必须配置proxy\n\nProxy位于项目根目录下的 ionic.config.json\n\n\n只需要把proxyUrl改为你本地环境的API地址\n\n&#123;\n  &quot;name&quot;: &quot;rlph&quot;,\n  &quot;app_id&quot;: &quot;&quot;,\n  &quot;v2&quot;: true,\n  &quot;typescript&quot;: true,\n  &quot;proxies&quot;: [\n    &#123;\n      &quot;path&quot;: &quot;&#x2F;api&quot;,\n      &quot;proxyUrl&quot;: &quot;http:&#x2F;&#x2F;api.dev&quot;\n    &#125;\n  ]\n&#125;\n\n\n然后把API地址的常量制定为**&#x2F;api&#x2F;**这个proxy\n\n\n在根目录下**&#x2F;src&#x2F;config.ts里面把“API_SERVER”的值改为“&#x2F;api&#x2F;“**\n\nexport let data &#x3D; &#123;\n    &quot;API_SERVER&quot; : &quot;&#x2F;api&#x2F;&quot;\n&#125;\n\n\n上线APP配置\n首先你需要配置真是服务器API地址配置API地址是在根目录下**&#x2F;src&#x2F;config.ts里面把“API_SERVER”**的值改为线上API地址\n\nexport let data &#x3D; &#123;\n    &quot;API_SERVER&quot; : &quot;http:&#x2F;&#x2F;api.domain.com&#x2F;&quot;\n&#125;\n\n开发常见问题APP run 失败当运行ionic run android的时候可能会遇到该报错：\nError: Failed to install apk to device: [  1%] &#x2F;data&#x2F;local&#x2F;tmp&#x2F;android-debug.apk\n[  2%] &#x2F;data&#x2F;local&#x2F;tmp&#x2F;android-debug.apk\n...\n[100%] &#x2F;data&#x2F;local&#x2F;tmp&#x2F;android-debug.apk\n        pkg: &#x2F;data&#x2F;local&#x2F;tmp&#x2F;android-debug.apk\nFailure [INSTALL_FAILED_UPDATE_INCOMPATIBLE]\n\n\n此问题是因为已有签名的APP存在手机上， 需要想删除该APP才能安装测试（debug）版的apk\n在cmd运行以下代码即可解决问题：\n\nadb uninstall my.package.id\n\n\nIonic 2 自带的native文件上传(FILE TRANSFER)插件无法获取成功返回内容这个是Ionic 2 核心代码里面的一个BUG, 在一下版本下是有问题的Ionic CLI Version: 2.2.1\n\n首先找到项目根目录下以下路径里面的filetransfer.d.ts文件\n\nnode_modules\\ionic-native\\dist\\es5\\plugins\\filetransfer.d.ts\nnode_modules\\ionic-native\\dist\\esm\\plugins\\filetransfer.d.ts\n\n\n分别修改以上两个文件里面的代码\n\n&#x2F;&#x2F;把这一行:\nupload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult | FileTransferError&gt;\n&#x2F;&#x2F;改为: \nupload(fileUrl: string, url: string, options?: FileUploadOptions, trustAllHosts?: boolean): Promise&lt;FileUploadResult&gt;\n\n\n在安卓下使用相册选择时, 返回的图片路径不能再显示问题\n首先在这个例子使用的是cordova-plugin-camera组件(Cordova的相机插件)\n首先引入需要的类\nFilePath 这个类就是用来修复安卓上图片URI的问题的\n\nimport &#123; Camera, File, FilePath &#125; from &#39;ionic-native&#39;;\n\n\n使用 FilePath.resolveNativePath(imagePath) 这个方法来纠正图片URI\n\nCamera.getPicture(options).then((imagePath) &#x3D;&gt; &#123;\n &#x2F;&#x2F; 特殊安卓图片库的处理\n this.nativeFilePath &#x3D; imagePath;\n if (this.pl.is(&#39;android&#39;) &amp;&amp; sourceType &#x3D;&#x3D;&#x3D; Camera.PictureSourceType.PHOTOLIBRARY) &#123;\n   FilePath.resolveNativePath(imagePath)\n   .then(filePath &#x3D;&gt; &#123;\n       this.nativeFilePath &#x3D; filePath;\n       let currentName &#x3D; imagePath.substring(imagePath.lastIndexOf(&#39;&#x2F;&#39;) + 1, imagePath.lastIndexOf(&#39;?&#39;));\n   &#125;);\n &#125; else &#123;\n   var currentName &#x3D; imagePath.substr(imagePath.lastIndexOf(&#39;&#x2F;&#39;) + 1);\n &#125;\n&#125;, err &#x3D;&gt; &#123;\n &#x2F;&#x2F; this.presentToast(&#39;选择图片失败.&#39;);\n&#125;);\n\n","slug":"ionic/dev-note","date":"2017-02-25T00:00:00.000Z","categories_index":"Ionic","tags_index":"Ionic 2,Angular 2,Hybird App","author_index":"三钻"}]